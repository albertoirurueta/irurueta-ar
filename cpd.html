<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0 from org.apache.maven.plugins:maven-pmd-plugin:3.27.0:cpd at 2025-12-18
 | Rendered using Apache Maven Fluido Skin 2.0.0-M9
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0" />
    <title>CPD Results â€“ com.irurueta:irurueta-ar</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-2.0.0-M9.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-2.0.0-M9.min.js"></script>
  </head>
  <body>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h1>com.irurueta:irurueta-ar</h1></div></div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2025-12-18<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.5.0-SNAPSHOT</li>
        <li class="pull-right"><a href="./">com.irurueta:irurueta-ar</a></li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html"><span class="icon-chevron-down"></span>Project Reports</a>
     <ul class="nav nav-list">
      <li><a href="apidocs/index.html">Javadoc</a></li>
      <li><a href="testapidocs/index.html">Test Javadoc</a></li>
      <li><a href="surefire.html">Surefire</a></li>
      <li><a href="checkstyle.html">Checkstyle</a></li>
      <li><a href="spotbugs.html">SpotBugs</a></li>
      <li class="active"><a>CPD</a></li>
      <li><a href="pmd.html">PMD</a></li>
      <li><a href="xref/index.html">Source Xref</a></li>
      <li><a href="xref-test/index.html">Test Source Xref</a></li>
     </ul></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
<a href="https://maven.apache.org/" class="builtBy" target="_blank"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn" class="span10">
<section><a id="CPD_Results"></a>
<h1>CPD Results</h1>
<p>The following document contains the results of PMD's  <a class="externalLink" href="https://pmd.github.io/latest/pmd_userdocs_cpd.html">CPD</a> 7.14.0.</p><section><a id="Duplications"></a>
<h2>Duplications</h2>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/KruppaDualImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/KruppaDualImageOfAbsoluteConicEstimator.html#L482">482</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/KruppaDualImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/KruppaDualImageOfAbsoluteConicEstimator.html#L838">838</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>private void estimateUnknownAspectRatio(final DualImageOfAbsoluteConic result)
            throws KruppaDualImageOfAbsoluteConicEstimatorException {
        try {
            final var x0 = principalPointX;
            final var y0 = principalPointY;

            // SVD decompose fundamental matrix
            fundamentalMatrix.normalize();
            final var decomposer = new SingularValueDecomposer(fundamentalMatrix.getInternalMatrix());
            decomposer.decompose();

            final var sigmas = decomposer.getSingularValues();
            final var u = decomposer.getU();
            final var v = decomposer.getV();

            final var sigma1 = sigmas[0];
            final var sigma2 = sigmas[1];

            // Column u1
            final var u11 = u.getElementAt(0, 0);
            final var u21 = u.getElementAt(1, 0);
            final var u31 = u.getElementAt(2, 0);

            // Column u2
            final var u12 = u.getElementAt(0, 1);
            final var u22 = u.getElementAt(1, 1);
            final var u32 = u.getElementAt(2, 1);

            // Column v1
            final var v11 = v.getElementAt(0, 0);
            final var v21 = v.getElementAt(1, 0);
            final var v31 = v.getElementAt(2, 0);

            // Column v2
            final var v12 = v.getElementAt(0, 1);
            final var v22 = v.getElementAt(1, 1);
            final var v32 = v.getElementAt(2, 1);

            // build Kruppa equations
            final var polyA = u12 * u11;
            final var polyB = u22 * u21;
            final var polyC = Math.pow(x0, 2.0) * u12 * u11 + x0 * y0 * u22 * u11 + x0 * u32 * u11
                    + x0 * y0 * u12 * u21 + Math.pow(y0, 2.0) * u22 * u21 + y0 * u32 * u21
                    + x0 * u12 * u31 + y0 * u22 * u31 + u32 * u31;
            final var polyD = Math.pow(sigma2, 2.0) * v12 * v12;
            final var polyE = Math.pow(sigma2, 2.0) * v22 * v22;
            final var polyF = Math.pow(sigma2 * x0, 2.0) * v12 * v12
                    + Math.pow(sigma2, 2.0) * x0 * y0 * v22 * v12
                    + Math.pow(sigma2, 2.0) * x0 * v32 * v12
                    + Math.pow(sigma2, 2.0) * x0 * y0 * v12 * v22
                    + Math.pow(sigma2 * y0, 2.0) * v22 * v22
                    + Math.pow(sigma2, 2.0) * y0 * v32 * v22
                    + Math.pow(sigma2, 2.0) * x0 * v12 * v32
                    + Math.pow(sigma2, 2.0) * y0 * v22 * v32
                    + Math.pow(sigma2, 2.0) * v32 * v32;
            final var polyG = u11 * u11;
            final var polyH = u21 * u21;
            final var polyI = Math.pow(x0, 2.0) * u11 * u11 + x0 * y0 * u21 * u11 + x0 * u31 * u11
                    + x0 * y0 * u11 * u21 + Math.pow(y0, 2.0) * u21 * u21 + y0 * u31 * u21
                    + x0 * u11 * u31 + y0 * u21 * u31 + u31 * u31;
            final var polyJ = sigma1 * sigma2 * v12 * v11;
            final var polyK = sigma1 * sigma2 * v22 * v21;
            final var polyL = sigma1 * sigma2 * Math.pow(x0, 2.0) * v12 * v11
                    + sigma1 * sigma2 * x0 * y0 * v22 * v11 + sigma1 * sigma2 * x0 * v32 * v11
                    + sigma1 * sigma2 * x0 * y0 * v12 * v21
                    + sigma1 * sigma2 * Math.pow(y0, 2.0) * v22 * v21
                    + sigma1 * sigma2 * y0 * v32 * v21 + sigma1 * sigma2 * x0 * v12 * v31
                    + sigma1 * sigma2 * y0 * v22 * v31 + sigma1 * sigma2 * v32 * v31;
            final var polyM = Math.pow(sigma1, 2.0) * v11 * v11;
            final var polyN = Math.pow(sigma1, 2.0) * v21 * v21;
            final var polyO = Math.pow(sigma1 * x0, 2.0) * v11 * v11
                    + Math.pow(sigma1, 2.0) * x0 * y0 * v21 * v11
                    + Math.pow(sigma1, 2.0) * x0 * v31 * v11
                    + Math.pow(sigma1, 2.0) * x0 * y0 * v11 * v21
                    + Math.pow(sigma1 * y0, 2.0) * v21 * v21
                    + Math.pow(sigma1, 2.0) * y0 * v31 * v21
                    + Math.pow(sigma1, 2.0) * x0 * v11 * v31
                    + Math.pow(sigma1, 2.0) * y0 * v21 * v31
                    + Math.pow(sigma1, 2.0) * v31 * v31;
            final var polyP = u12 * u12;
            final var polyQ = u22 * u22;
            final var polyR = Math.pow(x0, 2.0) * u12 * u12 + x0 * y0 * u22 * u12 + x0 * u32 * u12
                    + x0 * y0 * u12 * u22 + Math.pow(y0, 2.0) * u22 * u22 + y0 * u32 * u22
                    + x0 * u12 * u32 + y0 * u22 * u32 + u32 * u32;


            final var tmp = (polyP * polyJ + polyA * polyM) / (polyG * polyM - polyP * polyD);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructorConfiguration.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructorConfiguration.html#L835">835</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructorConfiguration.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructorConfiguration.html#L410">410</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>protected BaseSparseReconstructorConfiguration() {
    }

    /**
     * Gets method to use for non-robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @return method to use for non-robust fundamental matrix estimation.
     */
    public FundamentalMatrixEstimatorMethod getNonRobustFundamentalMatrixEstimatorMethod() {
        return mNonRobustFundamentalMatrixEstimatorMethod;
    }

    /**
     * Sets method to use for non-robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @param method method to use for non-robust fundamental matrix estimation.
     * @return this instance so that method can be easily chained.
     */
    public T setNonRobustFundamentalMatrixEstimatorMethod(final FundamentalMatrixEstimatorMethod method) {
        mNonRobustFundamentalMatrixEstimatorMethod = method;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets method to use for robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @return method to use for robust fundamental matrix estimation.
     */
    public RobustEstimatorMethod getRobustFundamentalMatrixEstimatorMethod() {
        return mRobustFundamentalMatrixEstimatorMethod;
    }

    /**
     * Sets method to use for robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @param method method to use for robust fundamental matrix estimation.
     * @return this instance so that method can be easily chained.
     */
    public T setRobustFundamentalMatrixEstimatorMethod(final RobustEstimatorMethod method) {
        mRobustFundamentalMatrixEstimatorMethod = method;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether estimated fundamental matrix is refined among all found inliers.
     * This is only used when general scenes are allowed.
     *
     * @return true if fundamental matrix is refined, false otherwise.
     */
    public boolean isFundamentalMatrixRefined() {
        return refineFundamentalMatrix;
    }

    /**
     * Specifies whether estimated fundamental matrix is refined among all found inliers.
     * This is only used when general scenes are allowed.
     *
     * @param refineFundamentalMatrix true if fundamental matrix is refined, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixRefined(final boolean refineFundamentalMatrix) {
        this.refineFundamentalMatrix = refineFundamentalMatrix;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether covariance of estimated fundamental matrix is kept after the estimation.
     * This is only used when general scenes are allowed.
     *
     * @return true if covariance is kept, false otherwise.
     */
    public boolean isFundamentalMatrixCovarianceKept() {
        return keepFundamentalMatrixCovariance;
    }

    /**
     * Specifies whether covariance of estimated fundamental matrix is kept after the
     * estimation.
     * This is only used when general scenes are allowed.
     *
     * @param keepFundamentalMatrixCovariance true if covariance is kept, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixCovarianceKept(final boolean keepFundamentalMatrixCovariance) {
        this.keepFundamentalMatrixCovariance = keepFundamentalMatrixCovariance;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets confidence of robustly estimated fundamental matrix.
     * This is only used when general scenes are allowed.
     *
     * @return confidence of robustly estimated fundamental matrix.
     */
    public double getFundamentalMatrixConfidence() {
        return fundamentalMatrixConfidence;
    }

    /**
     * Sets confidence of robustly estimated fundamental matrix.
     * This is only used when general scenes are allowed.
     *
     * @param fundamentalMatrixConfidence confidence of robustly estimated fundamental matrix.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixConfidence(final double fundamentalMatrixConfidence) {
        this.fundamentalMatrixConfidence = fundamentalMatrixConfidence;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets maximum number of iterations to robustly estimate fundamental matrix.
     * This is only used when general scenes are allowed.
     *
     * @return maximum number of iterations to robustly estimate fundamental matrix.
     */
    public int getFundamentalMatrixMaxIterations() {
        return fundamentalMatrixMaxIterations;
    }

    /**
     * Sets maximum number of iterations to robustly estimate fundamental matrix.
     * This is only used when general scenes are allowed.
     *
     * @param fundamentalMatrixMaxIterations maximum number of iterations to robustly estimate
     *                                       fundamental matrix.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixMaxIterations(final int fundamentalMatrixMaxIterations) {
        this.fundamentalMatrixMaxIterations = fundamentalMatrixMaxIterations;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets threshold to determine whether samples for robust fundamental matrix estimation
     * are inliers or not.
     * This is only used when general scenes are allowed.
     *
     * @return threshold to determine whether samples for robust fundamental matrix
     * estimation are inliers or not.
     */
    public double getFundamentalMatrixThreshold() {
        return fundamentalMatrixThreshold;
    }

    /**
     * Sets threshold to determine whether samples for robust fundamental matrix
     * estimation are inliers or not.
     * This is only used when general scenes are allowed.
     *
     * @param fundamentalMatrixThreshold threshold to determine whether samples for
     *                                   robust fundamental matrix estimation are inliers
     *                                   or not.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixThreshold(final double fundamentalMatrixThreshold) {
        this.fundamentalMatrixThreshold = fundamentalMatrixThreshold;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether inliers must be kept during robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @return true if inliers must be kept during robust fundamental matrix estimation,
     * false otherwise.
     */
    public boolean getFundamentalMatrixComputeAndKeepInliers() {
        return fundamentalMatrixComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be kept during robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @param fundamentalMatrixComputeAndKeepInliers true if inliers must be kept during
     *                                               robust fundamental matrix estimation, false
     *                                               otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixComputeAndKeepInliers(final boolean fundamentalMatrixComputeAndKeepInliers) {
        this.fundamentalMatrixComputeAndKeepInliers = fundamentalMatrixComputeAndKeepInliers;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether residuals must be computed and kept during robust fundamental
     * matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @return true if residuals must be computed and kept, false otherwise.
     */
    public boolean getFundamentalMatrixComputeAndKeepResiduals() {
        return fundamentalMatrixComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept during robust fundamental
     * matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @param fundamentalMatrixComputeAndKeepResiduals true if residuals must be
     *                                                 computed and kept, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixComputeAndKeepResiduals(final boolean fundamentalMatrixComputeAndKeepResiduals) {
        this.fundamentalMatrixComputeAndKeepResiduals = fundamentalMatrixComputeAndKeepResiduals;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets method to use for initial cameras' estimation.
     *
     * @return method to use for initial cameras' estimation.
     */
    public InitialCamerasEstimatorMethod getInitialCamerasEstimatorMethod() {
        return initialCamerasEstimatorMethod;
    }

    /**
     * Sets method to use for initial cameras' estimation.
     *
     * @param method method to use for initial cameras' estimation.
     * @return this instance so that method can be easily chained.
     */
    public T setInitialCamerasEstimatorMethod(final InitialCamerasEstimatorMethod method) {
        initialCamerasEstimatorMethod = method;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether an homogeneous point triangulator is used for point triangulation
     * when Dual Absolute Quadric (DAQ) camera initialization is used.
     *
     * @return true if homogeneous point triangulator is used, false if an inhomogeneous
     * point triangulator is used instead.
     */
    public boolean getDaqUseHomogeneousPointTriangulator() {
        return daqUseHomogeneousPointTriangulator;
    }

    /**
     * Specifies whether an homogeneous point triangulator is used for point
     * triangulation when Dual Absolute Quadric (DAQ) camera initialization is used.
     *
     * @param daqUseHomogeneousPointTriangulator true if homogeneous point triangulator
     *                                           is used, false if inhomogeneous point
     *                                           triangulator is used instead.
     * @return this instance so that method can be easily chained.
     */
    public T setDaqUseHomogeneousPointTriangulator(final boolean daqUseHomogeneousPointTriangulator) {
        this.daqUseHomogeneousPointTriangulator = daqUseHomogeneousPointTriangulator;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets aspect ratio for initial cameras estimation using DAQ or DIAC methods.
     *
     * @return aspect ratio for initial cameras using DAQ or DIAC methods.
     */
    public double getInitialCamerasAspectRatio() {
        return initialCamerasAspectRatio;
    }

    /**
     * Sets aspect ratio for initial cameras using DAQ or DIAC methods.
     *
     * @param initialCamerasAspectRatio aspect ratio for initial cameras using DAQ or DIAC
     *                                  methods.
     * @return this instance so that method can be easily chained.
     */
    public T setInitialCamerasAspectRatio(final double initialCamerasAspectRatio) {
        this.initialCamerasAspectRatio = initialCamerasAspectRatio;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets horizontal principal point value to use for initial cameras estimation
     * using DIAC or DAQ methods.
     *
     * @return horizontal principal point value to use for initial cameras estimation
     * using DIAC or DAQ methods.
     */
    public double getPrincipalPointX() {
        return principalPointX;
    }

    /**
     * Sets horizontal principal point value to use for initial cameras estimation
     * using DIAC or DAQ methods.
     *
     * @param principalPointX horizontal principal point value to use for initial
     *                        cameras estimation using DIAC or DAQ methods.
     * @return this instance so that method can be easily chained.
     */
    public T setPrincipalPointX(final double principalPointX) {
        this.principalPointX = principalPointX;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets vertical principal point value to use for initial cameras estimation
     * using DIAC or DAQ methods.
     *
     * @return vertical principal point value to use for initial cameras
     * estimation using DIAC or DAQ methods.
     */
    public double getPrincipalPointY() {
        return principalPointY;
    }

    /**
     * Sets vertical principal point value to use for initial cameras estimation using
     * DIAC or DAQ methods.
     *
     * @param principalPointY vertical principal point value to use for initial cameras
     *                        estimation using DIAC or DAQ methods.
     * @return this instance so that method can be easily chained.
     */
    public T setPrincipalPointY(final double principalPointY) {
        this.principalPointY = principalPointY;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets corrector type to use for point triangulation when initial cameras are being
     * estimated using either DIAC or essential matrix methods or null if no corrector is
     * used.
     *
     * @return corrector type to use for point triangulation when initial cameras are
     * being estimated using either DIAC or essential matrix methods or null if no
     * corrector is used.
     */
    public CorrectorType getInitialCamerasCorrectorType() {
        return initialCamerasCorrectorType;
    }

    /**
     * Sets corrector type to use for point triangulation when initial cameras are being
     * estimated using either DIAC or essential matrix methods or null if no corrector
     * is used.
     *
     * @param type corrector type to use for point triangulation when initial cameras
     *             are being estimated using either DIAC or essential matrix methods
     *             or null if no corrector is used.
     * @return this instance so that method can be easily chained.
     */
    public T setInitialCamerasCorrectorType(final CorrectorType type) {
        initialCamerasCorrectorType = type;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets value indicating whether valid triangulated points are marked during initial
     * cameras estimation using either DIAC or essential matrix methods.
     *
     * @return value indicating whether valid triangulated points are marked during
     * initial cameras estimation using either DIAC or essential matrix methods.
     */
    public boolean getInitialCamerasMarkValidTriangulatedPoints() {
        return initialCamerasMarkValidTriangulatedPoints;
    }

    /**
     * Sets value indicating whether valid triangulated points are marked during initial
     * cameras estimation using either DIAC or essential matrix methods.
     *
     * @param initialCamerasMarkValidTriangulatedPoints value indicating whether valid
     *                                                  triangulated points are marked during
     *                                                  initial cameras estimation using
     *                                                  either DIAC or essential matrix
     *                                                  methods.
     * @return this instance so that method can be easily chained.
     */
    public T setInitialCamerasMarkValidTriangulatedPoints(final boolean initialCamerasMarkValidTriangulatedPoints) {
        this.initialCamerasMarkValidTriangulatedPoints = initialCamerasMarkValidTriangulatedPoints;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Intrinsic parameters of first camera estimated using the essential matrix method.
     *
     * @return parameters of first camera estimated using the essential matrix method.
     */
    public PinholeCameraIntrinsicParameters getInitialIntrinsic1() {
        return initialIntrinsic1;
    }

    /**
     * Sets intrinsic parameters of first camera estimated using the essential matrix
     * method.
     *
     * @param initialIntrinsic1 parameters of first camera estimated using the essential
     *                          matrix method.
     * @return this instance so that method can be easily chained.
     */
    public T setInitialIntrinsic1(final PinholeCameraIntrinsicParameters initialIntrinsic1) {
        this.initialIntrinsic1 = initialIntrinsic1;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Intrinsic parameters of second camera estimated using the essential matrix method.
     *
     * @return parameters of second camera estimated using the essential matrix method.
     */
    public PinholeCameraIntrinsicParameters getInitialIntrinsic2() {
        return initialIntrinsic2;
    }

    /**
     * Sets intrinsic parameters of second camera estimated using the essential matrix
     * method.
     *
     * @param initialIntrinsic2 parameters of second camera estimated using the essential
     *                          matrix method.
     * @return this instance so that method can be easily chained.
     */
    public T setInitialIntrinsic2(final PinholeCameraIntrinsicParameters initialIntrinsic2) {
        this.initialIntrinsic2 = initialIntrinsic2;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether a general scene (points laying in a general 3D position) is
     * allowed.
     * When true, an initial geometry estimation is attempted for general points.
     *
     * @return true if general scene is allowed, false otherwise.
     */
    public boolean isGeneralSceneAllowed() {
        return allowGeneralScene;
    }

    /**
     * Specifies whether a general scene (points laying in a general 3D position) is
     * allowed.
     * When true, an initial geometry estimation is attempted for general points.
     *
     * @param allowGeneralScene true if general scene is allowed, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setGeneralSceneAllowed(final boolean allowGeneralScene) {
        this.allowGeneralScene = allowGeneralScene;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether a planar scene (points laying in a 3D plane) is allowed or not.
     * When true, an initial geometry estimation is attempted for planar points.
     *
     * @return true if planar scene is allowed, false otherwise.
     */
    public boolean isPlanarSceneAllowed() {
        return allowPlanarScene;
    }

    /**
     * Specifies whether a planar scene (points laying in a 3D plane) is allowed or not.
     * When true, an initial geometry estimation is attempted for planar points.
     *
     * @param allowPlanarScene true if planar scene is allowed, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarSceneAllowed(final boolean allowPlanarScene) {
        this.allowPlanarScene = allowPlanarScene;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets robust method to use for planar homography estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return robust method to use for planar homography estimation.
     */
    public RobustEstimatorMethod getRobustPlanarHomographyEstimatorMethod() {
        return robustPlanarHomographyEstimatorMethod;
    }

    /**
     * Sets robust method to use for planar homography estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param robustPlanarHomographyEstimatorMethod robust method to use for planar
     *                                              homography estimation.
     * @return this instance so that method can be easily chained.
     */
    public T setRobustPlanarHomographyEstimatorMethod(
            final RobustEstimatorMethod robustPlanarHomographyEstimatorMethod) {
        this.robustPlanarHomographyEstimatorMethod = robustPlanarHomographyEstimatorMethod;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether planar homography is refined using all found inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @return true if planar homography is refined, false otherwise.
     */
    public boolean isPlanarHomographyRefined() {
        return refinePlanarHomography;
    }

    /**
     * Specifies whether planar homography is refined using all found inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @param refinePlanarHomography true if planar homography must be refined, false
     *                               otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyRefined(final boolean refinePlanarHomography) {
        this.refinePlanarHomography = refinePlanarHomography;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether planar homography covariance is kept after estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return true if planar homography covariance is kept, false otherwise.
     */
    public boolean isPlanarHomographyCovarianceKept() {
        return keepPlanarHomographyCovariance;
    }

    /**
     * Specifies whether planar homography covariance is kept after estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param keepPlanarHomographyCovariance true if planar homography covariance is
     *                                       kept, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyCovarianceKept(final boolean keepPlanarHomographyCovariance) {
        this.keepPlanarHomographyCovariance = keepPlanarHomographyCovariance;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets confidence of robustly estimated planar homography. By default, this is 99%.
     * This is only used when planar scenes are allowed.
     *
     * @return confidence of robustly estimated planar homography.
     */
    public double getPlanarHomographyConfidence() {
        return planarHomographyConfidence;
    }

    /**
     * Sets confidence of robustly estimated planar homography. By default, this is 99%.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyConfidence confidence of robustly estimated planar
     *                                   homography.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyConfidence(final double planarHomographyConfidence) {
        this.planarHomographyConfidence = planarHomographyConfidence;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets maximum number of iterations to make while robustly estimating planar
     * homography. By default, this is 5000.
     * This is only used when planar scenes are allowed.
     *
     * @return maximum number of iterations to make while robustly estimating planar
     * homography.
     */
    public int getPlanarHomographyMaxIterations() {
        return planarHomographyMaxIterations;
    }

    /**
     * Sets maximum number of iterations to make while robustly estimating planar
     * homography. By default, this is 5000.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyMaxIterations maximum number of iterations to make while
     *                                      robustly estimating planar homography.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyMaxIterations(final int planarHomographyMaxIterations) {
        this.planarHomographyMaxIterations = planarHomographyMaxIterations;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets threshold to determine whether samples for robust projective 2D
     * transformation estimation are inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @return threshold to robustly estimate projective 2D transformation.
     */
    public double getPlanarHomographyThreshold() {
        return planarHomographyThreshold;
    }

    /**
     * Sets threshold to determine whether samples for robust projective 2D
     * transformation estimation are inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyThreshold threshold to robustly estimate projective 2D
     *                                  transformation.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyThreshold(final double planarHomographyThreshold) {
        this.planarHomographyThreshold = planarHomographyThreshold;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets value indicating that inlier data is kept after robust planar homography
     * estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return true if inlier data is kept, false otherwise.
     */
    public boolean getPlanarHomographyComputeAndKeepInliers() {
        return planarHomographyComputeAndKeepInliers;
    }

    /**
     * Specifies whether inlier data is kept after robust planar homography estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyComputeAndKeepInliers true if inlier data is kept, false
     *                                              otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyComputeAndKeepInliers(final boolean planarHomographyComputeAndKeepInliers) {
        this.planarHomographyComputeAndKeepInliers = planarHomographyComputeAndKeepInliers;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets value indicating that residual data is kept after robust planar homography
     * estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return true if residual data is kept, false otherwise.
     */
    public boolean getPlanarHomographyComputeAndKeepResiduals() {
        return planarHomographyComputeAndKeepResiduals;
    }

    /**
     * Sets value indicating that residual data is kept after robust planar homography
     * estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyComputeAndKeepResiduals true if residual data is kept,
     *                                                false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyComputeAndKeepResiduals(final boolean planarHomographyComputeAndKeepResiduals) {
        this.planarHomographyComputeAndKeepResiduals = planarHomographyComputeAndKeepResiduals;
        //noinspection unchecked
        return (T) this;
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/BaseSlamCalibrator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/BaseSlamCalibrator.html#L379">379</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/BaseSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/BaseSlamEstimator.html#L644">644</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Indicates whether accumulation of samples is enabled or not.
     *
     * @return true if accumulation of samples is enabled, false otherwise.
     */
    public boolean isAccumulationEnabled() {
        return accumulationEnabled;
    }

    /**
     * Specifies whether accumulation of samples is enabled or not.
     *
     * @param accumulationEnabled true if accumulation of samples is enabled,
     *                            false otherwise.
     */
    public void setAccumulationEnabled(final boolean accumulationEnabled) {
        this.accumulationEnabled = accumulationEnabled;
    }

    /**
     * Gets timestamp expressed in nanoseconds since the epoch time of the last
     * accelerometer sample, or -1 if no sample has been set yet.
     *
     * @return timestamp expressed in nanoseconds since the epoch time of the
     * last accelerometer sample, or -1.
     */
    public long getAccelerometerTimestampNanos() {
        return accelerometerTimestampNanos;
    }

    /**
     * Gets timestamp expressed in nanoseconds since the epoch time of the last
     * gyroscope sample, or -1 if no sample has been set yet.
     *
     * @return timestamp expressed in nanoseconds since the epoch time of the
     * last gyroscope sample, or -1.
     */
    public long getGyroscopeTimestampNanos() {
        return gyroscopeTimestampNanos;
    }

    /**
     * Gets number of accelerometer samples accumulated since last full sample.
     *
     * @return number of accelerometer samples accumulated since last full
     * sample.
     */
    public int getAccumulatedAccelerometerSamples() {
        return accumulatedAccelerometerSamples;
    }

    /**
     * Gets number of gyroscope samples accumulated since last full sample.
     *
     * @return number of gyroscope samples accumulated since last full sample.
     */
    public int getAccumulatedGyroscopeSamples() {
        return accumulatedGyroscopeSamples;
    }

    /**
     * Indicates whether the accelerometer sample has been received since the
     * last full sample (accelerometer + gyroscope).
     *
     * @return true if accelerometer sample has been received, false otherwise.
     */
    public boolean isAccelerometerSampleReceived() {
        return accumulatedAccelerometerSamples &gt; 0;
    }

    /**
     * Indicates whether the gyroscope sample has been received since the last
     * full sample (accelerometer + gyroscope).
     *
     * @return true if gyroscope sample has been received, false otherwise.
     */
    public boolean isGyroscopeSampleReceived() {
        return accumulatedGyroscopeSamples &gt; 0;
    }

    /**
     * Indicates whether a full sample (accelerometer + gyroscope) has been
     * received or not.
     *
     * @return true if full sample has been received, false otherwise.
     */
    public boolean isFullSampleAvailable() {
        return isAccelerometerSampleReceived() &amp;&amp; isGyroscopeSampleReceived();
    }

    /**
     * Gets average acceleration along x-axis accumulated since last full
     * sample. Expressed in meters per squared second (m/s^2).
     *
     * @return average acceleration along x-axis accumulated since last full
     * sample.
     */
    public double getAccumulatedAccelerationSampleX() {
        return accumulatedAccelerationSampleX;
    }

    /**
     * Gets average acceleration along y-axis accumulated since last full
     * sample. Expressed in meters per squared second (m/s^2).
     *
     * @return average acceleration along y-axis accumulated since last full
     * sample.
     */
    public double getAccumulatedAccelerationSampleY() {
        return accumulatedAccelerationSampleY;
    }

    /**
     * Gets average acceleration along z-axis accumulated since last full
     * sample. Expressed in meters per squared second (m/s^2).
     *
     * @return average acceleration along z-axis accumulated since last full
     * sample.
     */
    public double getAccumulatedAccelerationSampleZ() {
        return accumulatedAccelerationSampleZ;
    }

    /**
     * Gets average acceleration along x,y,z axes accumulated since last full
     * sample. Expressed in meters per squared second (m/s^2).
     *
     * @return average acceleration along x,y,z axes expressed in meters per
     * squared second (m/s^2).
     */
    public double[] getAccumulatedAccelerationSample() {
        return new double[]{
                accumulatedAccelerationSampleX,
                accumulatedAccelerationSampleY,
                accumulatedAccelerationSampleZ
        };
    }

    /**
     * Gets average acceleration along x,yz axes accumulated since last full
     * sample. Expressed in meters per squared second (m/s^2).
     *
     * @param result array where average acceleration along x,y,z axes will be
     *               stored.
     * @throws IllegalArgumentException if provided array does not have length
     *                                  3.
     */
    public void getAccumulatedAccelerationSample(final double[] result) {
        if (result.length != N_COMPONENTS_3D) {
            throw new IllegalArgumentException(&quot;result must have length 3&quot;);
        }
        result[0] = accumulatedAccelerationSampleX;
        result[1] = accumulatedAccelerationSampleY;
        result[2] = accumulatedAccelerationSampleZ;
    }

    /**
     * Gets average angular speed along x-axis accumulated since last full
     * sample. Expressed in radians per second (rad/s).
     *
     * @return average angular speed along x-axis expressed in radians per
     * second (rad/s).
     */
    public double getAccumulatedAngularSpeedSampleX() {
        return accumulatedAngularSpeedSampleX;
    }

    /**
     * Gets average angular speed along y-axis accumulated since last full
     * sample. Expressed in radians per second (rad/s).
     *
     * @return average angular speed along y-axis expressed in radians per
     * second (rad/s).
     */
    public double getAccumulatedAngularSpeedSampleY() {
        return accumulatedAngularSpeedSampleY;
    }

    /**
     * Gets average angular speed along z-axis accumulated since last full
     * sample. Expressed in radians per second (rad/s).
     *
     * @return average angular speed along z-axis expressed in radians per
     * second (rad/s).
     */
    public double getAccumulatedAngularSpeedSampleZ() {
        return accumulatedAngularSpeedSampleZ;
    }

    /**
     * Gets average angular speed along x,y,z axes accumulated since last full
     * sample. Expressed in radians per second (rad/s).
     *
     * @return average angular speed along x,y,z axes expressed in radians per
     * second.
     */
    public double[] getAccumulatedAngularSpeedSample() {
        return new double[]{
                accumulatedAngularSpeedSampleX,
                accumulatedAngularSpeedSampleY,
                accumulatedAngularSpeedSampleZ
        };
    }

    /**
     * Gets average angular speed along x,y,z axes accumulated since last full
     * sample. Expressed in radians per second (rad/s).
     *
     * @param result array where average angular speed along x,y,z axes will be
     *               stored.
     * @throws IllegalArgumentException if provided array does not have length
     *                                  3.
     */
    public void getAccumulatedAngularSpeedSample(final double[] result) {
        if (result.length != N_COMPONENTS_3D) {
            throw new IllegalArgumentException(&quot;result must have length 3&quot;);
        }
        result[0] = accumulatedAngularSpeedSampleX;
        result[1] = accumulatedAngularSpeedSampleY;
        result[2] = accumulatedAngularSpeedSampleZ;
    }

    /**
     * Provides a new accelerometer sample.
     * If accumulation is enabled, samples are averaged until a full sample is
     * received.
     * When a full sample (accelerometer + gyroscope) is received, internal
     * state gets also updated.
     *
     * @param timestamp     timestamp of accelerometer sample since epoch time and
     * @param accelerationX linear acceleration along x-axis expressed in meters
     *                      per squared second (m/s^2).
     * @param accelerationY linear acceleration along y-axis expressed in meters
     *                      per squared second (m/s^2).
     * @param accelerationZ linear acceleration along z-axis expressed in meters
     *                      per squared second (m/s^2).
     */
    public void updateAccelerometerSample(
            final long timestamp, final float accelerationX, final float accelerationY, final float accelerationZ) {
        if (!isFullSampleAvailable()) {
            accelerometerTimestampNanos = timestamp;
            if (isAccumulationEnabled() &amp;&amp; isAccelerometerSampleReceived()) {
                // accumulation enabled
                final var nextSamples = accumulatedAccelerometerSamples + 1;
                accumulatedAccelerationSampleX = (accumulatedAccelerationSampleX * accumulatedAccelerometerSamples
                        + accelerationX) / nextSamples;
                accumulatedAccelerationSampleY = (accumulatedAccelerationSampleY * accumulatedAccelerometerSamples
                        + accelerationY) / nextSamples;
                accumulatedAccelerationSampleZ = (accumulatedAccelerationSampleZ * accumulatedAccelerometerSamples
                        + accelerationZ) / nextSamples;
                accumulatedAccelerometerSamples = nextSamples;
            } else {
                // accumulation disabled
                accumulatedAccelerationSampleX = accelerationX;
                accumulatedAccelerationSampleY = accelerationY;
                accumulatedAccelerationSampleZ = accelerationZ;
                accumulatedAccelerometerSamples++;
            }
            notifyFullSampleAndResetSampleReceive();
        }
    }

    /**
     * Provides a new accelerometer sample.
     * If accumulation is enabled, samples are averaged until a full sample is
     * received.
     * When a full sample (accelerometer + gyroscope) is received, internal
     * state gets also updated.
     *
     * @param timestamp timestamp of accelerometer sample since epoch time and
     *                  expressed in nanoseconds.
     * @param data      array containing x,y,z components of linear acceleration
     *                  expressed in meters per squared second (m/s^2).
     * @throws IllegalArgumentException if provided array does not have length
     *                                  3.
     */
    public void updateAccelerometerSample(final long timestamp, final float[] data) {
        if (data.length != N_COMPONENTS_3D) {
            throw new IllegalArgumentException(&quot;acceleration must have length 3&quot;);
        }
        updateAccelerometerSample(timestamp, data[0], data[1], data[2]);
    }

    /**
     * Provides a new gyroscope sample.
     * If accumulation is enabled, samples are averaged until a full sample is
     * received.
     * When a full sample (accelerometer + gyroscope) is received, internal
     * state gets also updated.
     *
     * @param timestamp     timestamp of accelerometer sample since epoch time and
     *                      expressed in nanoseconds.
     * @param angularSpeedX angular speed of rotation along x-axis expressed in
     *                      radians per second (rad/s).
     * @param angularSpeedY angular speed of rotation along y-axis expressed in
     *                      radians per second (rad/s).
     * @param angularSpeedZ angular speed of rotation along z-axis expressed in
     *                      radians per second (rad/s).
     */
    public void updateGyroscopeSample(
            final long timestamp, final float angularSpeedX, final float angularSpeedY, final float angularSpeedZ) {
        if (!isFullSampleAvailable()) {
            gyroscopeTimestampNanos = timestamp;
            if (isAccumulationEnabled() &amp;&amp; isGyroscopeSampleReceived()) {
                // accumulation enabled
                final var nextSamples = accumulatedGyroscopeSamples + 1;
                accumulatedAngularSpeedSampleX = (accumulatedAngularSpeedSampleX * accumulatedGyroscopeSamples
                        + angularSpeedX) / nextSamples;
                accumulatedAngularSpeedSampleY = (accumulatedAngularSpeedSampleY * accumulatedGyroscopeSamples
                        + angularSpeedY) / nextSamples;
                accumulatedAngularSpeedSampleZ = (accumulatedAngularSpeedSampleZ * accumulatedGyroscopeSamples
                        + angularSpeedZ) / nextSamples;
                accumulatedGyroscopeSamples = nextSamples;
            } else {
                // accumulation disabled
                accumulatedAngularSpeedSampleX = angularSpeedX;
                accumulatedAngularSpeedSampleY = angularSpeedY;
                accumulatedAngularSpeedSampleZ = angularSpeedZ;
                accumulatedGyroscopeSamples++;
            }
            notifyFullSampleAndResetSampleReceive();
        }
    }

    /**
     * Provides a new gyroscope sample.
     * If accumulation is enabled, samples are averaged until a full sample is
     * received.
     * When a full sample (accelerometer + gyroscope) is received, internal
     * state gets also updated.
     *
     * @param timestamp timestamp of gyroscope sample since epoch time and
     *                  expressed in nanoseconds.
     * @param data      angular speed of rotation along x,y,z axes expressed in
     *                  radians per second (rad/s).
     * @throws IllegalArgumentException if provided array does not have length
     *                                  3.
     */
    public void updateGyroscopeSample(final long timestamp, final float[] data) {
        if (data.length != N_COMPONENTS_3D) {
            throw new IllegalArgumentException(&quot;angular speed must have length 3&quot;);
        }
        updateGyroscopeSample(timestamp, data[0], data[1], data[2]);
    }

    /**
     * Gets most recent timestamp of received partial samples (accelerometer or
     * gyroscope).
     *
     * @return most recent timestamp of received partial sample.
     */
    public long getMostRecentTimestampNanos() {
        return Math.max(accelerometerTimestampNanos, gyroscopeTimestampNanos);
    }

    /**
     * Gets listener in charge of handling events raised by instances of this
     * class.
     *
     * @return listener in charge of handling events raised by instances of this
     * class.
     */
    public BaseSlamCalibratorListener&lt;D&gt; getListener() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/EightPointsFundamentalMatrixEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/EightPointsFundamentalMatrixEstimator.html#L192">192</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/SevenPointsFundamentalMatrixEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/SevenPointsFundamentalMatrixEstimator.html#L238">238</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>if (listener != null) {
            listener.onEstimateStart(this);
        }

        final var nPoints = leftPoints.size();

        try {
            ProjectiveTransformation2D leftNormalization = null;
            ProjectiveTransformation2D rightNormalization = null;
            final List&lt;Point2D&gt; leftPoints;
            final List&lt;Point2D&gt; rightPoints;
            if (normalizePoints) {
                // normalize points on left view
                final var normalizer = new Point2DNormalizer(this.leftPoints);
                normalizer.compute();

                leftNormalization = normalizer.getTransformation();

                // normalize points on right view
                normalizer.setPoints(this.rightPoints);
                normalizer.compute();

                rightNormalization = normalizer.getTransformation();

                // normalize to increase accuracy
                leftNormalization.normalize();
                rightNormalization.normalize();

                leftPoints = leftNormalization.transformPointsAndReturnNew(this.leftPoints);
                rightPoints = rightNormalization.transformPointsAndReturnNew(this.rightPoints);
            } else {
                leftPoints = this.leftPoints;
                rightPoints = this.rightPoints;
            }

            final Matrix a;
            if (isLMSESolutionAllowed()) {
                a = new Matrix(nPoints, 9);
            } else {
                a = new Matrix(MIN_REQUIRED_POINTS, 9);
            }

            Point2D leftPoint;
            Point2D rightPoint;
            double homLeftX;
            double homLeftY;
            double homLeftW;
            double homRightX;
            double homRightY;
            double homRightW;
            double value0;
            double value1;
            double value2;
            double value3;
            double value4;
            double value5;
            double value6;
            double value7;
            double value8;
            double rowNorm;
            for (var i = 0; i &lt; nPoints; i++) {
                leftPoint = leftPoints.get(i);
                rightPoint = rightPoints.get(i);

                // normalize points to increase accuracy
                leftPoint.normalize();
                rightPoint.normalize();

                homLeftX = leftPoint.getHomX();
                homLeftY = leftPoint.getHomY();
                homLeftW = leftPoint.getHomW();

                homRightX = rightPoint.getHomX();
                homRightY = rightPoint.getHomY();
                homRightW = rightPoint.getHomW();

                // set a row values
                value0 = homLeftX * homRightX;
                value1 = homLeftY * homRightX;
                value2 = homLeftW * homRightX;

                value3 = homLeftX * homRightY;
                value4 = homLeftY * homRightY;
                value5 = homLeftW * homRightY;

                value6 = homLeftX * homRightW;
                value7 = homLeftY * homRightW;
                value8 = homLeftW * homRightW;

                // normalize row to increase accuracy
                rowNorm = Math.sqrt(Math.pow(value0, 2.0)
                        + Math.pow(value1, 2.0) + Math.pow(value2, 2.0)
                        + Math.pow(value3, 2.0) + Math.pow(value4, 2.0)
                        + Math.pow(value5, 2.0) + Math.pow(value6, 2.0)
                        + Math.pow(value7, 2.0) + Math.pow(value8, 2.0));

                a.setElementAt(i, 0, value0 / rowNorm);
                a.setElementAt(i, 1, value1 / rowNorm);
                a.setElementAt(i, 2, value2 / rowNorm);
                a.setElementAt(i, 3, value3 / rowNorm);
                a.setElementAt(i, 4, value4 / rowNorm);
                a.setElementAt(i, 5, value5 / rowNorm);
                a.setElementAt(i, 6, value6 / rowNorm);
                a.setElementAt(i, 7, value7 / rowNorm);
                a.setElementAt(i, 8, value8 / rowNorm);

                if (!isLMSESolutionAllowed() &amp;&amp; i == (MIN_REQUIRED_POINTS - 1)) {
                    break;
                }
            }

            final var decomposer = new SingularValueDecomposer(a);

            decomposer.decompose();

            // if nullity of provided a matrix is not of dimension 1 (number of
            // dimensions of null-space), then epipolar geometry is degenerate
            // because there is more than one possible solution (up to scale).
            // This is typically due to co-linearities or co-planarities on
            // projected 2D points. In this case we throw an exception
            if (decomposer.getNullity() &gt; 1) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/LMSEHomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/LMSEHomogeneousSinglePoint3DTriangulator.html#L197">197</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/WeightedHomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/WeightedHomogeneousSinglePoint3DTriangulator.html#L347">347</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>camera.fixCameraSign();

                final var homX = point.getHomX();
                final var homY = point.getHomY();
                final var homW = point.getHomW();

                // pick rows of camera corresponding to different planes
                // (we do not normalize planes, as it would introduce errors)

                // 1st camera row (p1T)
                camera.verticalAxisPlane(verticalAxisPlane);
                // 2nd camera row (p2T)
                camera.horizontalAxisPlane(horizontalAxisPlane);
                // 3rd camera row (p3T)
                camera.principalPlane(principalPlane);

                // 1st equation
                a.setElementAt(row, 0, homX * principalPlane.getA() - homW * verticalAxisPlane.getA());
                a.setElementAt(row, 1, homX * principalPlane.getB() - homW * verticalAxisPlane.getB());
                a.setElementAt(row, 2, homX * principalPlane.getC() - homW * verticalAxisPlane.getC());
                a.setElementAt(row, 3, homX * principalPlane.getD() - homW * verticalAxisPlane.getD());

                // normalize row (equation) to increase accuracy
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(row, 0), 2.0)
                        + Math.pow(a.getElementAt(row, 1), 2.0)
                        + Math.pow(a.getElementAt(row, 2), 2.0)
                        + Math.pow(a.getElementAt(row, 3), 2.0));

                a.setElementAt(row, 0, a.getElementAt(row, 0) / rowNorm);
                a.setElementAt(row, 1, a.getElementAt(row, 1) / rowNorm);
                a.setElementAt(row, 2, a.getElementAt(row, 2) / rowNorm);
                a.setElementAt(row, 3, a.getElementAt(row, 3) / rowNorm);

                // 2nd equation
                row++;

                a.setElementAt(row, 0, homY * principalPlane.getA() - homW * horizontalAxisPlane.getA());
                a.setElementAt(row, 1, homY * principalPlane.getB() - homW * horizontalAxisPlane.getB());
                a.setElementAt(row, 2, homY * principalPlane.getC() - homW * horizontalAxisPlane.getC());
                a.setElementAt(row, 3, homY * principalPlane.getD() - homW * horizontalAxisPlane.getD());

                // normalize row (equation) to increase accuracy
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(row, 0), 2.0)
                        + Math.pow(a.getElementAt(row, 1), 2.0)
                        + Math.pow(a.getElementAt(row, 2), 2.0)
                        + Math.pow(a.getElementAt(row, 3), 2.0));

                a.setElementAt(row, 0, a.getElementAt(row, 0) / rowNorm);
                a.setElementAt(row, 1, a.getElementAt(row, 1) / rowNorm);
                a.setElementAt(row, 2, a.getElementAt(row, 2) / rowNorm);
                a.setElementAt(row, 3, a.getElementAt(row, 3) / rowNorm);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/LMSEInhomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/LMSEInhomogeneousSinglePoint3DTriangulator.html#L192">192</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/WeightedInhomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/WeightedInhomogeneousSinglePoint3DTriangulator.html#L345">345</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>for (var i = 0; i &lt; numViews; i++) {
                point = points2D.get(i);
                camera = cameras.get(i);

                // to increase accuracy
                point.normalize();
                camera.normalize();

                final var homX = point.getHomX();
                final var homY = point.getHomY();
                final var homW = point.getHomW();

                // pick rows of camera corresponding to different planes
                // (we do not normalize planes, as it would introduce errors)

                // 1st camera row (p1T)
                camera.verticalAxisPlane(verticalAxisPlane);
                // 2nd camera row (p2T)
                camera.horizontalAxisPlane(horizontalAxisPlane);
                // 3rd camera row (p3T)
                camera.principalPlane(principalPlane);

                // 1st equation
                a.setElementAt(row, 0, homX * principalPlane.getA() - homW * verticalAxisPlane.getA());
                a.setElementAt(row, 1, homX * principalPlane.getB() - homW * verticalAxisPlane.getB());
                a.setElementAt(row, 2, homX * principalPlane.getC() - homW * verticalAxisPlane.getC());

                b[row] = homW * verticalAxisPlane.getD() - homX * principalPlane.getD();

                // normalize equation to increase accuracy
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(row, 0), 2.0)
                        + Math.pow(a.getElementAt(row, 1), 2.0)
                        + Math.pow(a.getElementAt(row, 2), 2.0));

                a.setElementAt(row, 0, a.getElementAt(row, 0) / rowNorm);
                a.setElementAt(row, 1, a.getElementAt(row, 1) / rowNorm);
                a.setElementAt(row, 2, a.getElementAt(row, 2) / rowNorm);
                b[row] /= rowNorm;

                // 2nd equation
                row++;

                a.setElementAt(row, 0, homY * principalPlane.getA() - homW * horizontalAxisPlane.getA());
                a.setElementAt(row, 1, homY * principalPlane.getB() - homW * horizontalAxisPlane.getB());
                a.setElementAt(row, 2, homY * principalPlane.getC() - homW * horizontalAxisPlane.getC());

                b[row] = homW * horizontalAxisPlane.getD() - homY * principalPlane.getD();

                // normalize equation to increase accuracy
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(row, 0), 2.0)
                        + Math.pow(a.getElementAt(row, 1), 2.0)
                        + Math.pow(a.getElementAt(row, 2), 2.0));

                a.setElementAt(row, 0, a.getElementAt(row, 0) / rowNorm);
                a.setElementAt(row, 1, a.getElementAt(row, 1) / rowNorm);
                a.setElementAt(row, 2, a.getElementAt(row, 2) / rowNorm);
                b[row] /= rowNorm;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/AlternatingCameraCalibrator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/AlternatingCameraCalibrator.html#L228">228</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/ErrorOptimizationCameraCalibrator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/ErrorOptimizationCameraCalibrator.html#L247">247</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Returns robust estimator method to be used for radial distortion
     * estimation.
     *
     * @return robust estimator method to be used for radial distortion
     * estimation.
     */
    public RobustEstimatorMethod getDistortionMethod() {
        return distortionMethod;
    }

    /**
     * Sets robust estimator method to be used for radial distortion
     * estimation.
     *
     * @param distortionMethod robust estimator method to be used for
     *                         radial distortion estimation.
     * @throws LockedException if this instance is locked.
     */
    public void setDistortionMethod(final RobustEstimatorMethod distortionMethod) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetDistortionMethod(distortionMethod);
    }

    /**
     * Returns radial distortion estimator, which can be retrieved in case
     * that some additional parameter needed to be adjusted.
     * It is discouraged to directly access the distortion estimator during
     * camera calibration, as it might interfere with the results.
     *
     * @return radial distortion estimator.
     */
    public RadialDistortionRobustEstimator getDistortionEstimator() {
        return distortionEstimator;
    }

    /**
     * Returns threshold to robustly estimate radial distortion.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @return threshold to robustly estimate radial distortion.
     */
    public double getDistortionEstimatorThreshold() {
        return switch (distortionEstimator.getMethod()) {
            case LMEDS -&gt; ((LMedSRadialDistortionRobustEstimator) distortionEstimator).getStopThreshold();
            case MSAC -&gt; ((MSACRadialDistortionRobustEstimator) distortionEstimator).getThreshold();
            case PROSAC -&gt; ((PROSACRadialDistortionRobustEstimator) distortionEstimator).getThreshold();
            case PROMEDS -&gt; ((PROMedSRadialDistortionRobustEstimator) distortionEstimator).getStopThreshold();
            default -&gt; ((RANSACRadialDistortionRobustEstimator) distortionEstimator).getThreshold();
        };
    }

    /**
     * Sets threshold to robustly estimate radial distortion.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finder adjustments.
     *
     * @param distortionEstimatorThreshold threshold to robustly estimate
     *                                     radial distortion .
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setDistortionEstimatorThreshold(final double distortionEstimatorThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        switch (distortionEstimator.getMethod()) {
            case LMEDS:
                ((LMedSRadialDistortionRobustEstimator) distortionEstimator)
                        .setStopThreshold(distortionEstimatorThreshold);
                break;
            case MSAC:
                ((MSACRadialDistortionRobustEstimator) distortionEstimator).setThreshold(distortionEstimatorThreshold);
                break;
            case PROSAC:
                ((PROSACRadialDistortionRobustEstimator) distortionEstimator)
                        .setThreshold(distortionEstimatorThreshold);
                break;
            case PROMEDS:
                ((PROMedSRadialDistortionRobustEstimator) distortionEstimator)
                        .setStopThreshold(distortionEstimatorThreshold);
                break;
            case RANSAC:
            default:
                ((RANSACRadialDistortionRobustEstimator) distortionEstimator)
                        .setThreshold(distortionEstimatorThreshold);
                break;
        }
    }

    /**
     * Returns confidence to robustly estimate radial distortion.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     * Confidence is expressed as a value between 0.0 (0%) and 1.0 (100%). The
     * amount of confidence indicates the probability that the estimated
     * homography is correct (i.e. no outliers were used for the estimation,
     * because they were successfully discarded).
     * Typically, this value will be close to 1.0, but not exactly 1.0, because
     * a 100% confidence would require an infinite number of iterations.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @return confidence to robustly estimate homographies.
     */
    public double getDistortionEstimatorConfidence() {
        return distortionEstimator.getConfidence();
    }

    /**
     * Sets confidence to robustly estimate radial distortion.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     * Confidence is expressed as a value between 0.0 (0%) and 1.0 (100%). The
     * amount of confidence indicates the probability that the estimated
     * homography is correct (i.e. no outliers were used for the estimation,
     * because they were successfully discarded).
     * Typically, this value will be close to 1.0, but not exactly 1.0, because
     * a 100% confidence would require an infinite number of iterations.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @param distortionEstimatorConfidence confidence to robustly estimate
     *                                      radial distortion.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided value is not between 0.0 and
     *                                  1.0.
     */
    public void setDistortionEstimatorConfidence(final double distortionEstimatorConfidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        distortionEstimator.setConfidence(distortionEstimatorConfidence);
    }

    /**
     * Returns the maximum number of iterations to be done when estimating
     * the radial distortion.
     * If the maximum allowed number of iterations is reached, resulting
     * estimation might not have desired confidence.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @return maximum number of iterations to be done when estimating the
     * homographies.
     */
    public int getDistortionEstimatorMaxIterations() {
        return distortionEstimator.getMaxIterations();
    }

    /**
     * Sets the maximum number of iterations to be done when estimating the
     * radial distortion.
     * If the maximum allowed number of iterations is reached, resulting
     * estimation might not have desired confidence.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @param distortionEstimatorMaxIterations maximum number of iterations to
     *                                         be done when estimating radial distortion.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided value is negative or zero.
     */
    public void setDistortionEstimatorMaxIterations(final int distortionEstimatorMaxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        distortionEstimator.setMaxIterations(distortionEstimatorMaxIterations);
    }

    /**
     * Starts the calibration process.
     * Depending on the settings the following will be estimated:
     * intrinsic pinhole camera parameters, radial distortion of lens,
     * camera pose (rotation and translation) for each sample, and the
     * associated homobraphy of sampled points respect to the ideal pattern
     * samples.
     *
     * @throws CalibrationException if calibration fails for some reason.
     * @throws LockedException      if this instance is locked because calibration is
     *                              already in progress.
     * @throws NotReadyException    if this instance does not have enough data to
     *                              start camera calibration.
     */
    @Override
    public void calibrate() throws CalibrationException, LockedException, NotReadyException {

        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        locked = true;

        homographyQualityScoresRequired = (distortionEstimator.getMethod() == RobustEstimatorMethod.PROSAC
                || distortionEstimator.getMethod() == RobustEstimatorMethod.PROMEDS);

        if (listener != null) {
            listener.onCalibrateStart(this);
        }

        reset();
        radialDistortionProgress = iterProgress = previousNotifiedProgress = 0.0f;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L234">234</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L277">277</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

            if (jacobianU != null) {
                jacobianU.initialize(0.0);

                for (int i = 7, j = 0; i &lt; STATE_COMPONENTS; i++, j++) {
                    jacobianU.setElementAt(i, j, 1.0);
                }
            }
        } catch (final WrongSizeException ignore) {
            // never thrown
        }
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration).
     *
     * @param x      initial system state containing: position-x, position-y,
     *               position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *               linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *               angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *               length 13.
     * @param u      linear and angular velocity perturbations or controls:
     *               linear-velocity-change-x, linear-velocity-change-y,
     *               linear-velocity-change-z, angular-velocity-change-x,
     *               angular-velocity-change-y, angular-velocity-change-z. Must have length 6.
     * @param dt     time interval to compute prediction expressed in seconds.
     * @param result instance where updated system model will be stored. Must
     *               have length 13.
     * @throws IllegalArgumentException if system state array or control array
     *                                  or result do not have proper size.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;constVel.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void predict(final double[] x, final double[] u, final double dt, final double[] result) {
        predict(x, u, dt, result, null, null);
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration).
     *
     * @param x         initial system state containing: position-x, position-y,
     *                  position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *                  linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *                  angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *                  length 13.
     * @param u         linear and angular velocity perturbations or controls:
     *                  linear-velocity-change-x, linear-velocity-change-y,
     *                  linear-velocity-change-z, angular-velocity-change-x,
     *                  angular-velocity-change-y, angular-velocity-change-z. Must have length 6.
     * @param dt        time interval to compute prediction expressed in seconds.
     * @param jacobianX jacobian wrt system state. Must be 13x13.
     * @param jacobianU jacobian wrt control. Must be 13x6.
     * @return instance where updated system model will be stored.
     * @throws IllegalArgumentException if system state array, control array or
     *                                  jacobians do not have proper size.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;constVel.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static double[] predict(final double[] x, final double[] u, final double dt, final Matrix jacobianX,
                                   final Matrix jacobianU) {
        final var result = new double[STATE_COMPONENTS];
        predict(x, u, dt, result, jacobianX, jacobianU);
        return result;
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration).
     *
     * @param x  initial system state containing: position-x, position-y,
     *           position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *           linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *           angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *           length 13.
     * @param u  linear and angular velocity perturbations or controls:
     *           linear-velocity-change-x, linear-velocity-change-y,
     *           linear-velocity-change-z, angular-velocity-change-x,
     *           angular-velocity-change-y, angular-velocity-change-z. Must have length 6.
     * @param dt time interval to compute prediction expressed in seconds.
     * @return a new instance containing the updated system state.
     * @throws IllegalArgumentException if system state array, control array or
     *                                  jacobians do not have proper size.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;constVel.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static double[] predict(final double[] x, final double[] u, final double dt) {
        final var result = new double[STATE_COMPONENTS];
        predict(x, u, dt, result);
        return result;
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration) when no velocity control signal is present.
     *
     * @param x         initial system state containing: position-x, position-y,
     *                  position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *                  linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *                  angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *                  length 13.
     * @param u         linear ang angular velocity perturbations or controls and
     *                  position perturbations or controls: position-change-x, position-change-y,
     *                  position-change-z, linear-velocity-change-x, linear-velocity-change-y,
     *                  linear-velocity-change-z, angular-velocity-change-x,
     *                  angular-velocity-change-y, angular-velocity-change-z. Must have length 9.
     * @param dt        time interval to compute prediction expressed in seconds.
     * @param result    instance where updated system model will be stored. Must
     *                  have length 13.
     * @param jacobianX jacobian wrt system state. Must be 13x13.
     * @param jacobianU jacobian wrt control. Must be 13x9.
     * @throws IllegalArgumentException if system state array, control array,
     *                                  result or jacobians do not have proper size.
     */
    public static void predictWithPositionAdjustment(
            final double[] x, final double[] u, final double dt, final double[] result, final Matrix jacobianX,
            final Matrix jacobianU) {
        if (x.length != STATE_WITH_POSITION_ADJUSTMENT_COMPONENTS) {
            // x must have length 13
            throw new IllegalArgumentException();
        }
        if (u.length != CONTROL_WITH_POSITION_ADJUSTMENT_COMPONENTS) {
            // u must have length 9
            throw new IllegalArgumentException();
        }
        if (result.length != STATE_WITH_POSITION_ADJUSTMENT_COMPONENTS) {
            // result must have length 13
            throw new IllegalArgumentException();
        }
        if (jacobianX != null &amp;&amp; (jacobianX.getRows() != STATE_WITH_POSITION_ADJUSTMENT_COMPONENTS ||
                jacobianX.getColumns() != STATE_WITH_POSITION_ADJUSTMENT_COMPONENTS)) {
            // jacobian wrt x must be 13x13
            throw new IllegalArgumentException();
        }
        if (jacobianU != null &amp;&amp; (jacobianU.getRows() != STATE_WITH_POSITION_ADJUSTMENT_COMPONENTS ||
                jacobianU.getColumns() != CONTROL_WITH_POSITION_ADJUSTMENT_COMPONENTS)) {
            // jacobian wrt u must be 13x9
            throw new IllegalArgumentException();
        }

        // position
        final var r = new InhomogeneousPoint3D(x[0], x[1], x[2]);

        // orientation
        var q = new Quaternion(x[3], x[4], x[5], x[6]);

        // linear velocity
        var vx = x[7];
        var vy = x[8];
        var vz = x[9];

        // angular velocity
        var wx = x[10];</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L780">780</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L1082">1082</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>PositionPredictor.predict(r, vx, vy, vz, ax, ay, az, dt, r, rr, rv, ra);

            // update orientation
            Matrix qq = null;
            Matrix qdq = null;
            Matrix qw = null;
            if (jacobianX != null) {
                qq = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);
                qw = new Matrix(Quaternion.N_PARAMS, ANGULAR_SPEED_COMPONENTS);
            }
            if (jacobianU != null) {
                qdq = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);
            }
            q = QuaternionPredictor.predictWithRotationAdjustment(q, dq, wx, wy, wz, dt, qq, qdq, qw);


            // set updated linear velocity
            vx = v[0];
            vy = v[1];
            vz = v[2];

            // apply control signals
            vx += uvx;
            vy += uvy;
            vz += uvz;

            ax += uax;
            ay += uay;
            az += uaz;

            wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = ax;
            result[11] = ay;
            result[12] = az;

            result[13] = wx;
            result[14] = wy;
            result[15] = wz;

            // jacobians
            if (jacobianX != null) {
                // [Rr   0   Rv  Ra  0  ]
                // [0    Qq  0   0   Qw ]
                // [0    0   Vv  Va  0  ]
                // [0    0   0   eye 0  ]
                // [0    0   0   0   eye]
                jacobianX.initialize(0.0);
                jacobianX.setSubmatrix(0, 0, 2, 2, rr);

                jacobianX.setSubmatrix(3, 3, 6, 6, qq);

                jacobianX.setSubmatrix(0, 7, 2, 9, rv);

                jacobianX.setSubmatrix(7, 7, 9, 9, vv);

                jacobianX.setSubmatrix(0, 10, 2, 12, ra);

                jacobianX.setSubmatrix(7, 10, 9, 12, va);

                jacobianX.setSubmatrix(3, 13, 6, 15, qw);

                for (var i = 10; i &lt; STATE_WITH_ROTATION_ADJUSTMENT_COMPONENTS; i++) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationBaseSlamCalibrator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationBaseSlamCalibrator.html#L63">63</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/AbsoluteOrientationBaseSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationBaseSlamEstimator.html#L64">64</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>accumulatedOrientation = new Quaternion();
    }

    /**
     * Gets timestamp expressed in nanoseconds since the epoch time of the last
     * orientation sample, or -1 if no sample has been set yet.
     *
     * @return timestamp expressed in nanoseconds since the epoch time of the
     * last orientation sample, or -1.
     */
    public long getOrientationTimestampNanos() {
        return orientationTimestampNanos;
    }

    /**
     * Gets average orientation accumulated since last full sample.
     *
     * @return orientation accumulated since last full sample.
     */
    public Rotation3D getAccumulatedOrientation() {
        return accumulatedOrientation.toQuaternion();
    }

    /**
     * Gets average orientation accumulated since last full sample.
     *
     * @param result instance where orientation accumulated since last full
     *               sample will be stored.
     */
    public void getAccumulatedOrientation(final Rotation3D result) {
        result.fromRotation(accumulatedOrientation);
    }

    /**
     * Gets number of orientation samples accumulated since last full sample.
     *
     * @return number of orientation samples accumulated since last full sample.
     */
    public int getAccumulatedOrientationSamples() {
        return accumulatedOrientationSamples;
    }

    /**
     * Indicates whether the orientation sample has been received since last
     * full sample (accelerometer + gyroscope + orientation).
     *
     * @return true if orientation sample has been received, false otherwise.
     */
    public boolean isOrientationSampleReceived() {
        return accumulatedOrientationSamples &gt; 0;
    }

    /**
     * Indicates whether a full sample (accelerometer + gyroscope +
     * magnetic field) has been received or not.
     *
     * @return true if full sample has been received, false otherwise.
     */
    @Override
    public boolean isFullSampleAvailable() {
        return super.isFullSampleAvailable() &amp;&amp; isOrientationSampleReceived();
    }

    /**
     * Provides a new orientation sample.
     * If accumulation is enabled, samples are averaged until a full sample is
     * received.
     * When a full sample (accelerometer + gyroscope + orientation) is
     * received, internal state gets also updated.
     *
     * @param timestamp   timestamp of accelerometer sample since epoch time and
     *                    expressed in nanoseconds.
     * @param orientation new orientation.
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    public void updateOrientationSample(final long timestamp, final Rotation3D orientation) {
        if (!isFullSampleAvailable()) {
            orientationTimestampNanos = timestamp;
            if (isAccumulationEnabled() &amp;&amp; isOrientationSampleReceived()) {
                // accumulation enabled
                final var nextSamples = accumulatedOrientationSamples + 1;

                var accumA = accumulatedOrientation.getA();
                var accumB = accumulatedOrientation.getB();
                var accumC = accumulatedOrientation.getC();
                var accumD = accumulatedOrientation.getD();

                if (tempQ == null) {
                    tempQ = new Quaternion();
                }
                tempQ.fromRotation(orientation);
                tempQ.normalize();
                final var a = tempQ.getA();
                final var b = tempQ.getB();
                final var c = tempQ.getC();
                final var d = tempQ.getD();

                accumA = (accumA * accumulatedOrientationSamples + a) / nextSamples;
                accumB = (accumB * accumulatedOrientationSamples + b) / nextSamples;
                accumC = (accumC * accumulatedOrientationSamples + c) / nextSamples;
                accumD = (accumD * accumulatedOrientationSamples + d) / nextSamples;

                accumulatedOrientation.setA(accumA);
                accumulatedOrientation.setB(accumB);
                accumulatedOrientation.setC(accumC);
                accumulatedOrientation.setD(accumD);
                accumulatedOrientationSamples = nextSamples;
            } else {
                // accumulation disabled
                accumulatedOrientation.fromRotation(orientation);
                accumulatedOrientationSamples++;
            }
            notifyFullSampleAndResetSampleReceive();
        }
    }

    /**
     * Gets most recent timestamp of received partial samples (accelerometer,
     * gyroscope or magnetic field).
     *
     * @return most recent timestamp of received partial sample.
     */
    @Override
    public long getMostRecentTimestampNanos() {
        final var mostRecent = super.getMostRecentTimestampNanos();
        return Math.max(mostRecent, orientationTimestampNanos);
    }

    /**
     * Notifies that a full sample has been received and resets flags indicating
     * whether partial samples have been received.
     */
    @Override
    protected void notifyFullSampleAndResetSampleReceive() {
        if (isFullSampleAvailable()) {
            processFullSample();
            accumulatedAccelerometerSamples = accumulatedGyroscopeSamples = accumulatedOrientationSamples = 0;
        }
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L201">201</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L488">488</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>PositionPredictor.predict(r, vx, vy, vz, ax, ay, az, dt, r, rr, rv, ra);

            // update orientation
            Matrix qq = null;
            Matrix qw = null;
            if (jacobianX != null) {
                qq = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);
                qw = new Matrix(Quaternion.N_PARAMS, ANGULAR_SPEED_COMPONENTS);
            }
            q = QuaternionPredictor.predict(q, wx, wy, wz, dt, true, qq, qw);

            // set updated linear velocity
            vx = v[0];
            vy = v[1];
            vz = v[2];

            // apply control signals
            vx += uvx;
            vy += uvy;
            vz += uvz;

            ax += uax;
            ay += uay;
            az += uaz;

            wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = ax;
            result[11] = ay;
            result[12] = az;

            result[13] = wx;
            result[14] = wy;
            result[15] = wz;

            // jacobians
            if (jacobianX != null) {
                // [Rr   0   Rv  Ra  0  ]
                // [0    Qq  0   0   Qw ]
                // [0    0   Vv  Va  0  ]
                // [0    0   0   eye 0  ]
                // [0    0   0   0   eye]
                jacobianX.initialize(0.0);
                jacobianX.setSubmatrix(0, 0, 2, 2, rr);

                jacobianX.setSubmatrix(3, 3, 6, 6, qq);

                jacobianX.setSubmatrix(0, 7, 2, 9, rv);

                jacobianX.setSubmatrix(7, 7, 9, 9, vv);

                jacobianX.setSubmatrix(0, 10, 2, 12, ra);

                jacobianX.setSubmatrix(7, 10, 9, 12, va);

                jacobianX.setSubmatrix(3, 13, 6, 15, qw);

                for (var i = 10; i &lt; STATE_COMPONENTS; i++) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/AffineFundamentalMatrixEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/AffineFundamentalMatrixEstimator.html#L84">84</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/EightPointsFundamentalMatrixEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/EightPointsFundamentalMatrixEstimator.html#L86">86</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public AffineFundamentalMatrixEstimator(final List&lt;Point2D&gt; leftPoints, final List&lt;Point2D&gt; rightPoints) {
        super(leftPoints, rightPoints);
        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;
        normalizePoints = DEFAULT_NORMALIZE_POINT_CORRESPONDENCES;
    }

    /**
     * Returns boolean indicating whether an LMSE (the Least Mean Square Error)
     * solution is allowed or not. When an LMSE solution is allowed, more than 8
     * matched points can be used for fundamental matrix estimation. If LMSE
     * solution is not allowed then only the 4 former matched points will be
     * taken into account.
     *
     * @return true if an LMSE solution is allowed, false otherwise.
     */
    public boolean isLMSESolutionAllowed() {
        return allowLMSESolution;
    }

    /**
     * Sets boolean indicating whether an LMSE (the Least Mean Square Error)
     * solution is allowed or not. When an LMSE solution is allowed, more than 8
     * matched points can be used for fundamental matrix estimation. If LMSE
     * solution is not allowed then only the 4 former matched points will be
     * taken into account.
     *
     * @param allowed true if an LMSE solution is allowed, false otherwise.
     * @throws LockedException if this instance is locked because an estimation
     *                         is in progress.
     */
    public void setLMSESolutionAllowed(final boolean allowed) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        allowLMSESolution = allowed;
    }

    /**
     * Indicates whether provided matched 2D points must be normalized to
     * increase the accuracy of the estimation.
     *
     * @return true if points must be normalized, false otherwise.
     */
    public boolean arePointsNormalized() {
        return normalizePoints;
    }

    /**
     * Sets boolean indicating whether provided matched 2D points must be
     * normalized to increase the accuracy of the estimation.
     *
     * @param normalizePoints true if points must be normalized, false
     *                        otherwise.
     * @throws LockedException if this instance is locked because an estimation
     *                         is in progress.
     */
    public void setPointsNormalized(final boolean normalizePoints) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.normalizePoints = normalizePoints;
    }

    /**
     * Returns boolean indicating whether estimator is ready to start the
     * fundamental matrix estimation.
     * This is true when the required minimum number of matched points is
     * provided to obtain a solution and both left and right views have the
     * same number of matched points.
     *
     * @return true if estimator is ready to start the fundamental matrix
     * estimation, false otherwise.
     */
    @Override
    public boolean isReady() {
        return leftPoints != null &amp;&amp; rightPoints != null &amp;&amp; leftPoints.size() == rightPoints.size()
                &amp;&amp; leftPoints.size() &gt;= MIN_REQUIRED_POINTS;
    }

    /**
     * Estimates a fundamental matrix using provided lists of matched points on
     * left and right views.
     *
     * @return a fundamental matrix.
     * @throws LockedException                     if estimator is locked doing an estimation.
     * @throws NotReadyException                   if estimator is not ready because required
     *                                             input points have not already been provided.
     * @throws FundamentalMatrixEstimatorException if configuration of provided
     *                                             2D points is degenerate and fundamental matrix
     *                                             estimation fails.
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public FundamentalMatrix estimate() throws LockedException, NotReadyException, FundamentalMatrixEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        locked = true;

        if (listener != null) {
            listener.onEstimateStart(this);
        }

        final var nPoints = leftPoints.size();

        try {
            ProjectiveTransformation2D leftNormalization = null;
            ProjectiveTransformation2D rightNormalization = null;
            final List&lt;Point2D&gt; leftPoints;
            final List&lt;Point2D&gt; rightPoints;
            if (normalizePoints) {
                // normalize points on left view
                final var normalizer = new Point2DNormalizer(this.leftPoints);
                normalizer.compute();

                leftNormalization = normalizer.getTransformation();

                // normalize points on right view
                normalizer.setPoints(this.rightPoints);
                normalizer.compute();

                rightNormalization = normalizer.getTransformation();

                // normalize to increase accuracy
                leftNormalization.normalize();
                rightNormalization.normalize();

                leftPoints = leftNormalization.transformPointsAndReturnNew(this.leftPoints);
                rightPoints = rightNormalization.transformPointsAndReturnNew(this.rightPoints);
            } else {
                leftPoints = this.leftPoints;
                rightPoints = this.rightPoints;
            }

            final Matrix a;
            if (isLMSESolutionAllowed()) {
                a = new Matrix(nPoints, 5);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.html#L164">164</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.html#L180">180</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.html#L141">141</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/SlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/SlamEstimator.html#L160">160</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public AbsoluteOrientationConstantVelocityModelSlamEstimator() {
        super();
        x = new double[STATE_LENGTH];
        // initial value of quaternion.
        x[3] = 1.0;
        u = new double[CONTROL_LENGTH];
        try {
            jacobianPredictionX = new Matrix(STATE_LENGTH, STATE_LENGTH);
            jacobianPredictionU = new Matrix(STATE_LENGTH, CONTROL_LENGTH);
            control = new Matrix(CONTROL_LENGTH, 1);
            measurement = new Matrix(MEASUREMENT_LENGTH, 1);
            measurementMatrix = Matrix.identity(MEASUREMENT_LENGTH, STATE_LENGTH);

        } catch (final WrongSizeException ignore) {
            // never thrown
        }

        try {
            kalmanFilter = new KalmanFilter(STATE_LENGTH, MEASUREMENT_LENGTH, CONTROL_LENGTH);
            // setup matrix relating position measures with internal status.
            kalmanFilter.setMeasurementMatrix(measurementMatrix);
        } catch (final SignalProcessingException ignore) {
            // never thrown
        }

        try {
            // set initial Kalman filter state (state pre and pro must be two
            // different instances!)
            kalmanFilter.getStatePre().fromArray(x);
            kalmanFilter.getStatePost().fromArray(x);

        } catch (final WrongSizeException ignore) {
            // never thrown
        }
    }

    /**
     * Gets covariance matrix of state variables (position, velocity, acceleration, orientation and
     * angular speed).
     * Diagonal elements of matrix returned by this method are in the following order:
     * position-x, position-y, position-z, quaternion-a, quaternion-b, quaternion-c,
     * quaternion-d, linear-velocity-x, linear-velocity-y, linear-velocity-z,
     * angular-velocity-x, angular-velocity-y, angular-velocity-z.
     * Off-diagonal elements correspond to cross-correlation values of diagonal ones.
     *
     * @return covariance matrix of state variables.
     */
    @Override
    public Matrix getStateCovariance() {
        return kalmanFilter.getStatePre();
    }

    /**
     * Updates covariance matrix of position measures.
     * If null is provided, covariance matrix is not updated.
     *
     * @param positionCovariance new position covariance determining position
     *                           accuracy or null if last available covariance does not need to be
     *                           updated.
     * @throws IllegalArgumentException if provided covariance matrix is not
     *                                  3x3.
     */
    @Override
    public void setPositionCovarianceMatrix(final Matrix positionCovariance) {
        if (positionCovariance != null) {
            kalmanFilter.setMeasurementNoiseCov(positionCovariance);
        }
    }

    /**
     * Gets current covariance matrix of position measures determining current
     * accuracy of provided position measures.
     *
     * @return covariance matrix of position measures.
     */
    @Override
    public Matrix getPositionCovarianceMatrix() {
        return kalmanFilter.getMeasurementNoiseCov();
    }

    /**
     * Corrects system state with provided position measure using current
     * position accuracy.
     *
     * @param positionX new position along x-axis expressed in meters (m).
     * @param positionY new position along y-axis expressed in meters (m).
     * @param positionZ new position along z-axis expressed in meters (m).
     */
    @Override
    public void correctWithPositionMeasure(final double positionX, final double positionY, final double positionZ) {
        if (!predictionAvailable) {
            return;
        }

        if (listener != null) {
            listener.onCorrectWithPositionMeasure(this);
        }

        try {
            measurement.setElementAtIndex(0, positionX);
            measurement.setElementAtIndex(1, positionY);
            measurement.setElementAtIndex(2, positionZ);

            updateCorrectedState(kalmanFilter.correct(measurement));

            // copy corrected state to predicted state
            kalmanFilter.getStatePost().copyTo(kalmanFilter.getStatePre());
            kalmanFilter.getErrorCovPost().copyTo(kalmanFilter.getErrorCovPre());

        } catch (final SignalProcessingException e) {
            error = true;
        }

        if (listener != null) {
            listener.onCorrectedWithPositionMeasure(this);
        }
    }

    /**
     * Creates an instance of a calibrator to be used with this SLAM estimator.
     *
     * @return a calibrator.
     */
    public static AbsoluteOrientationConstantVelocityModelSlamCalibrator createCalibrator() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1427">1427</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1589">1589</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final double principalPointY;
        if (isInitialPairOfViews) {
            if (configuration.getInitialCamerasEstimatorMethod() == InitialCamerasEstimatorMethod.DUAL_ABSOLUTE_QUADRIC
                    || configuration.getInitialCamerasEstimatorMethod()
                    == InitialCamerasEstimatorMethod.DUAL_ABSOLUTE_QUADRIC_AND_ESSENTIAL_MATRIX) {
                principalPointX = configuration.getPrincipalPointX();
                principalPointY = configuration.getPrincipalPointY();
            } else {
                principalPointX = principalPointY = 0.0;
            }
        } else {
            if (configuration.getUseDIACForAdditionalCamerasIntrinsics()
                    || configuration.getUseDAQForAdditionalCamerasIntrinsics()) {
                principalPointX = configuration.getAdditionalCamerasHorizontalPrincipalPoint();
                principalPointY = configuration.getAdditionalCamerasVerticalPrincipalPoint();
            } else {
                principalPointX = principalPointY = 0.0;
            }
        }

        var i = 0;
        for (final var match : matches) {
            final var samples = match.getSamples();
            if (samples.length &lt; MIN_NUMBER_OF_VIEWS) {
                return false;
            }

            final var viewIds = match.getViewIds();
            final var pos1 = getPositionForViewId(viewIds, viewId1);
            if (pos1 &lt; 0) {
                return false;
            }

            final var pos2 = getPositionForViewId(viewIds, viewId2);
            if (pos2 &lt; 0) {
                return false;
            }

            final var leftSample = samples[pos1];
            final var rightSample = samples[pos2];
            final var p1 = leftSample.getPoint();
            final var p2 = rightSample.getPoint();

            leftSamples.add(leftSample);
            rightSamples.add(rightSample);

            final var leftPoint = Point2D.create();
            leftPoint.setInhomogeneousCoordinates(p1.getInhomX() - principalPointX,
                    p1.getInhomY() - principalPointY);
            leftPoints.add(leftPoint);

            final var rightPoint = Point2D.create();
            rightPoint.setInhomogeneousCoordinates(p2.getInhomX() - principalPointX,
                    p2.getInhomY() - principalPointY);
            rightPoints.add(rightPoint);

            qualityScores[i] = match.getQualityScore();
            i++;
        }

        try {
            final var estimator = FundamentalMatrixRobustEstimator.create(leftPoints, rightPoints, qualityScores,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructorConfiguration.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructorConfiguration.html#L841">841</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructorConfiguration.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructorConfiguration.html#L869">869</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>return (T) this;
    }

    /**
     * Indicates whether a general scene (points laying in a general 3D position) is
     * allowed.
     * When true, an initial geometry estimation is attempted for general points.
     *
     * @return true if general scene is allowed, false otherwise.
     */
    public boolean isGeneralSceneAllowed() {
        return allowGeneralScene;
    }

    /**
     * Specifies whether a general scene (points laying in a general 3D position) is
     * allowed.
     * When true, an initial geometry estimation is attempted for general points.
     *
     * @param allowGeneralScene true if general scene is allowed, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setGeneralSceneAllowed(final boolean allowGeneralScene) {
        this.allowGeneralScene = allowGeneralScene;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether a planar scene (points laying in a 3D plane) is allowed or
     * not.
     * When true, an initial geometry estimation is attempted for planar points.
     *
     * @return true if planar scene is allowed, false otherwise.
     */
    public boolean isPlanarSceneAllowed() {
        return allowPlanarScene;
    }

    /**
     * specifies whether a planar scene (points laying in a 3D plane) is allowed or
     * not.
     * When true, an initial geometry estimation is attempted for planar points.
     *
     * @param allowPlanarScene true if planar scene is allowed, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarSceneAllowed(final boolean allowPlanarScene) {
        this.allowPlanarScene = allowPlanarScene;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets robust method to use for planar homography estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return robust method to use for planar homography estimation.
     */
    public RobustEstimatorMethod getRobustPlanarHomographyEstimatorMethod() {
        return robustPlanarHomographyEstimatorMethod;
    }

    /**
     * Sets robust method to use for planar homography estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param robustPlanarHomographyEstimatorMethod robust method to use for planar
     *                                              homography estimation.
     * @return this instance so that method can be easily chained.
     */
    public T setRobustPlanarHomographyEstimatorMethod(
            final RobustEstimatorMethod robustPlanarHomographyEstimatorMethod) {
        this.robustPlanarHomographyEstimatorMethod = robustPlanarHomographyEstimatorMethod;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether planar homography is refined using all found inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @return true if planar homography is refined, false otherwise.
     */
    public boolean isPlanarHomographyRefined() {
        return refinePlanarHomography;
    }

    /**
     * Specifies whether planar homography is refined using all found inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @param refinePlanarHomography true if planar homography must be refined, false
     *                               otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyRefined(final boolean refinePlanarHomography) {
        this.refinePlanarHomography = refinePlanarHomography;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether planar homography covariance is kept after estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return true if planar homography covariance is kept, false otherwise.
     */
    public boolean isPlanarHomographyCovarianceKept() {
        return keepPlanarHomographyCovariance;
    }

    /**
     * Specifies whether planar homography covariance is kept after estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param keepPlanarHomographyCovariance true if planar homography covariance is
     *                                       kept, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyCovarianceKept(final boolean keepPlanarHomographyCovariance) {
        this.keepPlanarHomographyCovariance = keepPlanarHomographyCovariance;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets confidence of robustly estimated planar homography. By default, this is 99%.
     * This is only used when planar scenes are allowed.
     *
     * @return confidence of robustly estimated planar homography.
     */
    public double getPlanarHomographyConfidence() {
        return planarHomographyConfidence;
    }

    /**
     * Sets confidence of robustly estimated planar homography. By default, this is 99%.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyConfidence confidence of robustly estimated planar
     *                                   homography.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyConfidence(final double planarHomographyConfidence) {
        this.planarHomographyConfidence = planarHomographyConfidence;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets maximum number of iterations to make while robustly estimating planar
     * homography. By default, this is 5000.
     * This is only used when planar scenes are allowed.
     *
     * @return maximum number of iterations to make while robustly estimating planar
     * homography.
     */
    public int getPlanarHomographyMaxIterations() {
        return planarHomographyMaxIterations;
    }

    /**
     * Sets maximum number of iterations to make while robustly estimating planar
     * homography. By default, this is 5000.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyMaxIterations maximum number of iterations to make while
     *                                      robustly estimating planar homography.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyMaxIterations(final int planarHomographyMaxIterations) {
        this.planarHomographyMaxIterations = planarHomographyMaxIterations;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets threshold to determine whether samples for robust projective 2D
     * transformation estimation are inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @return threshold to robustly estimate projective 2D transformation.
     */
    public double getPlanarHomographyThreshold() {
        return planarHomographyThreshold;
    }

    /**
     * Sets threshold to determine whether samples for robust projective 2D
     * transformation estimation are inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyThreshold threshold to robustly estimate projective 2D
     *                                  transformation.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyThreshold(final double planarHomographyThreshold) {
        this.planarHomographyThreshold = planarHomographyThreshold;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets value indicating that inlier data is kept after robust planar homography
     * estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return true if inlier data is kept, false otherwise.
     */
    public boolean getPlanarHomographyComputeAndKeepInliers() {
        return planarHomographyComputeAndKeepInliers;
    }

    /**
     * Specifies whether inlier data is kept after robust planar homography estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyComputeAndKeepInliers true if inlier data is kept, false
     *                                              otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyComputeAndKeepInliers(final boolean planarHomographyComputeAndKeepInliers) {
        this.planarHomographyComputeAndKeepInliers = planarHomographyComputeAndKeepInliers;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets value indicating that residual data is kept after robust planar homography
     * estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return true if residual data is kept, false otherwise.
     */
    public boolean getPlanarHomographyComputeAndKeepResiduals() {
        return planarHomographyComputeAndKeepResiduals;
    }

    /**
     * Sets value indicating that residual data is kept after robust planar homography
     * estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyComputeAndKeepResiduals true if residual data is kept, false
     *                                                otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyComputeAndKeepResiduals(final boolean planarHomographyComputeAndKeepResiduals) {
        this.planarHomographyComputeAndKeepResiduals = planarHomographyComputeAndKeepResiduals;
        //noinspection unchecked
        return (T) this;
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructorConfiguration.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructorConfiguration.html#L841">841</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructorConfiguration.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructorConfiguration.html#L1277">1277</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>return (T) this;
    }

    /**
     * Indicates whether a general scene (points laying in a general 3D position) is
     * allowed.
     * When true, an initial geometry estimation is attempted for general points.
     *
     * @return true if general scene is allowed, false otherwise.
     */
    public boolean isGeneralSceneAllowed() {
        return allowGeneralScene;
    }

    /**
     * Specifies whether a general scene (points laying in a general 3D position) is
     * allowed.
     * When true, an initial geometry estimation is attempted for general points.
     *
     * @param allowGeneralScene true if general scene is allowed, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setGeneralSceneAllowed(final boolean allowGeneralScene) {
        this.allowGeneralScene = allowGeneralScene;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether a planar scene (points laying in a 3D plane) is allowed or
     * not.
     * When true, an initial geometry estimation is attempted for planar points.
     *
     * @return true if planar scene is allowed, false otherwise.
     */
    public boolean isPlanarSceneAllowed() {
        return allowPlanarScene;
    }

    /**
     * specifies whether a planar scene (points laying in a 3D plane) is allowed or
     * not.
     * When true, an initial geometry estimation is attempted for planar points.
     *
     * @param allowPlanarScene true if planar scene is allowed, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarSceneAllowed(final boolean allowPlanarScene) {
        this.allowPlanarScene = allowPlanarScene;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets robust method to use for planar homography estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return robust method to use for planar homography estimation.
     */
    public RobustEstimatorMethod getRobustPlanarHomographyEstimatorMethod() {
        return robustPlanarHomographyEstimatorMethod;
    }

    /**
     * Sets robust method to use for planar homography estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param robustPlanarHomographyEstimatorMethod robust method to use for planar
     *                                              homography estimation.
     * @return this instance so that method can be easily chained.
     */
    public T setRobustPlanarHomographyEstimatorMethod(
            final RobustEstimatorMethod robustPlanarHomographyEstimatorMethod) {
        this.robustPlanarHomographyEstimatorMethod = robustPlanarHomographyEstimatorMethod;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether planar homography is refined using all found inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @return true if planar homography is refined, false otherwise.
     */
    public boolean isPlanarHomographyRefined() {
        return refinePlanarHomography;
    }

    /**
     * Specifies whether planar homography is refined using all found inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @param refinePlanarHomography true if planar homography must be refined, false
     *                               otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyRefined(final boolean refinePlanarHomography) {
        this.refinePlanarHomography = refinePlanarHomography;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether planar homography covariance is kept after estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return true if planar homography covariance is kept, false otherwise.
     */
    public boolean isPlanarHomographyCovarianceKept() {
        return keepPlanarHomographyCovariance;
    }

    /**
     * Specifies whether planar homography covariance is kept after estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param keepPlanarHomographyCovariance true if planar homography covariance is
     *                                       kept, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyCovarianceKept(final boolean keepPlanarHomographyCovariance) {
        this.keepPlanarHomographyCovariance = keepPlanarHomographyCovariance;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets confidence of robustly estimated planar homography. By default, this is 99%.
     * This is only used when planar scenes are allowed.
     *
     * @return confidence of robustly estimated planar homography.
     */
    public double getPlanarHomographyConfidence() {
        return planarHomographyConfidence;
    }

    /**
     * Sets confidence of robustly estimated planar homography. By default, this is 99%.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyConfidence confidence of robustly estimated planar
     *                                   homography.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyConfidence(final double planarHomographyConfidence) {
        this.planarHomographyConfidence = planarHomographyConfidence;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets maximum number of iterations to make while robustly estimating planar
     * homography. By default, this is 5000.
     * This is only used when planar scenes are allowed.
     *
     * @return maximum number of iterations to make while robustly estimating planar
     * homography.
     */
    public int getPlanarHomographyMaxIterations() {
        return planarHomographyMaxIterations;
    }

    /**
     * Sets maximum number of iterations to make while robustly estimating planar
     * homography. By default, this is 5000.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyMaxIterations maximum number of iterations to make while
     *                                      robustly estimating planar homography.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyMaxIterations(final int planarHomographyMaxIterations) {
        this.planarHomographyMaxIterations = planarHomographyMaxIterations;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets threshold to determine whether samples for robust projective 2D
     * transformation estimation are inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @return threshold to robustly estimate projective 2D transformation.
     */
    public double getPlanarHomographyThreshold() {
        return planarHomographyThreshold;
    }

    /**
     * Sets threshold to determine whether samples for robust projective 2D
     * transformation estimation are inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyThreshold threshold to robustly estimate projective 2D
     *                                  transformation.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyThreshold(final double planarHomographyThreshold) {
        this.planarHomographyThreshold = planarHomographyThreshold;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets value indicating that inlier data is kept after robust planar homography
     * estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return true if inlier data is kept, false otherwise.
     */
    public boolean getPlanarHomographyComputeAndKeepInliers() {
        return planarHomographyComputeAndKeepInliers;
    }

    /**
     * Specifies whether inlier data is kept after robust planar homography estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyComputeAndKeepInliers true if inlier data is kept, false
     *                                              otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyComputeAndKeepInliers(final boolean planarHomographyComputeAndKeepInliers) {
        this.planarHomographyComputeAndKeepInliers = planarHomographyComputeAndKeepInliers;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets value indicating that residual data is kept after robust planar homography
     * estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return true if residual data is kept, false otherwise.
     */
    public boolean getPlanarHomographyComputeAndKeepResiduals() {
        return planarHomographyComputeAndKeepResiduals;
    }

    /**
     * Sets value indicating that residual data is kept after robust planar homography
     * estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyComputeAndKeepResiduals true if residual data is kept, false
     *                                                otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyComputeAndKeepResiduals(final boolean planarHomographyComputeAndKeepResiduals) {
        this.planarHomographyComputeAndKeepResiduals = planarHomographyComputeAndKeepResiduals;
        //noinspection unchecked
        return (T) this;
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L210">210</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L793">793</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>q = QuaternionPredictor.predict(q, wx, wy, wz, dt, true, qq, qw);

            // set updated linear velocity
            vx = v[0];
            vy = v[1];
            vz = v[2];

            // apply control signals
            vx += uvx;
            vy += uvy;
            vz += uvz;

            ax += uax;
            ay += uay;
            az += uaz;

            wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = ax;
            result[11] = ay;
            result[12] = az;

            result[13] = wx;
            result[14] = wy;
            result[15] = wz;

            // jacobians
            if (jacobianX != null) {
                // [Rr   0   Rv  Ra  0  ]
                // [0    Qq  0   0   Qw ]
                // [0    0   Vv  Va  0  ]
                // [0    0   0   eye 0  ]
                // [0    0   0   0   eye]
                jacobianX.initialize(0.0);
                jacobianX.setSubmatrix(0, 0, 2, 2, rr);

                jacobianX.setSubmatrix(3, 3, 6, 6, qq);

                jacobianX.setSubmatrix(0, 7, 2, 9, rv);

                jacobianX.setSubmatrix(7, 7, 9, 9, vv);

                jacobianX.setSubmatrix(0, 10, 2, 12, ra);

                jacobianX.setSubmatrix(7, 10, 9, 12, va);

                jacobianX.setSubmatrix(3, 13, 6, 15, qw);

                for (var i = 10; i &lt; STATE_COMPONENTS; i++) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L497">497</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L793">793</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>q = QuaternionPredictor.predict(q, wx, wy, wz, dt, true, qq, qw);

            // set updated linear velocity
            vx = v[0];
            vy = v[1];
            vz = v[2];

            // apply control signals
            vx += uvx;
            vy += uvy;
            vz += uvz;

            ax += uax;
            ay += uay;
            az += uaz;

            wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = ax;
            result[11] = ay;
            result[12] = az;

            result[13] = wx;
            result[14] = wy;
            result[15] = wz;

            // jacobians
            if (jacobianX != null) {
                // [Rr   0   Rv  Ra  0  ]
                // [0    Qq  0   0   Qw ]
                // [0    0   Vv  Va  0  ]
                // [0    0   0   eye 0  ]
                // [0    0   0   0   eye]
                jacobianX.initialize(0.0);
                jacobianX.setSubmatrix(0, 0, 2, 2, rr);

                jacobianX.setSubmatrix(3, 3, 6, 6, qq);

                jacobianX.setSubmatrix(0, 7, 2, 9, rv);

                jacobianX.setSubmatrix(7, 7, 9, 9, vv);

                jacobianX.setSubmatrix(0, 10, 2, 12, ra);

                jacobianX.setSubmatrix(7, 10, 9, 12, va);

                jacobianX.setSubmatrix(3, 13, 6, 15, qw);

                for (var i = 10; i &lt; STATE_WITH_POSITION_ADJUSTMENT_COMPONENTS; i++) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L210">210</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L1095">1095</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>q = QuaternionPredictor.predict(q, wx, wy, wz, dt, true, qq, qw);

            // set updated linear velocity
            vx = v[0];
            vy = v[1];
            vz = v[2];

            // apply control signals
            vx += uvx;
            vy += uvy;
            vz += uvz;

            ax += uax;
            ay += uay;
            az += uaz;

            wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = ax;
            result[11] = ay;
            result[12] = az;

            result[13] = wx;
            result[14] = wy;
            result[15] = wz;

            // jacobians
            if (jacobianX != null) {
                // [Rr   0   Rv  Ra  0  ]
                // [0    Qq  0   0   Qw ]
                // [0    0   Vv  Va  0  ]
                // [0    0   0   eye 0  ]
                // [0    0   0   0   eye]
                jacobianX.initialize(0.0);
                jacobianX.setSubmatrix(0, 0, 2, 2, rr);

                jacobianX.setSubmatrix(3, 3, 6, 6, qq);

                jacobianX.setSubmatrix(0, 7, 2, 9, rv);

                jacobianX.setSubmatrix(7, 7, 9, 9, vv);

                jacobianX.setSubmatrix(0, 10, 2, 12, ra);

                jacobianX.setSubmatrix(7, 10, 9, 12, va);

                jacobianX.setSubmatrix(3, 13, 6, 15, qw);

                for (var i = 10; i &lt; STATE_COMPONENTS; i++) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L497">497</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L1095">1095</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>q = QuaternionPredictor.predict(q, wx, wy, wz, dt, true, qq, qw);

            // set updated linear velocity
            vx = v[0];
            vy = v[1];
            vz = v[2];

            // apply control signals
            vx += uvx;
            vy += uvy;
            vz += uvz;

            ax += uax;
            ay += uay;
            az += uaz;

            wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = ax;
            result[11] = ay;
            result[12] = az;

            result[13] = wx;
            result[14] = wy;
            result[15] = wz;

            // jacobians
            if (jacobianX != null) {
                // [Rr   0   Rv  Ra  0  ]
                // [0    Qq  0   0   Qw ]
                // [0    0   Vv  Va  0  ]
                // [0    0   0   eye 0  ]
                // [0    0   0   0   eye]
                jacobianX.initialize(0.0);
                jacobianX.setSubmatrix(0, 0, 2, 2, rr);

                jacobianX.setSubmatrix(3, 3, 6, 6, qq);

                jacobianX.setSubmatrix(0, 7, 2, 9, rv);

                jacobianX.setSubmatrix(7, 7, 9, 9, vv);

                jacobianX.setSubmatrix(0, 10, 2, 12, ra);

                jacobianX.setSubmatrix(7, 10, 9, 12, va);

                jacobianX.setSubmatrix(3, 13, 6, 15, qw);

                for (var i = 10; i &lt; STATE_WITH_POSITION_ADJUSTMENT_COMPONENTS; i++) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/MSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/MSACRadialDistortionRobustEstimator.html#L211">211</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.html#L373">373</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var innerEstimator = new MSACRobustEstimator&lt;RadialDistortion&gt;(new MSACRobustEstimatorListener&lt;&gt;() {

            // point to be reused when computing residuals
            private final Point2D testPoint = Point2D.create(CoordinatesType.INHOMOGENEOUS_COORDINATES);

            // non-robust radial distortion estimator
            private final LMSERadialDistortionEstimator radialDistortionEstimator = new LMSERadialDistortionEstimator();

            // subset of distorted (i.e. measured) points
            private final List&lt;Point2D&gt; subsetDistorted = new ArrayList&lt;&gt;();

            // subset of undistorted (i.e. ideal) points
            private final List&lt;Point2D&gt; subsetUndistorted = new ArrayList&lt;&gt;();

            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return distortedPoints.size();
            }

            @Override
            public int getSubsetSize() {
                return RadialDistortionRobustEstimator.MIN_NUMBER_OF_POINTS;
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;RadialDistortion&gt; solutions) {
                subsetDistorted.clear();
                subsetDistorted.add(distortedPoints.get(samplesIndices[0]));
                subsetDistorted.add(distortedPoints.get(samplesIndices[1]));

                subsetUndistorted.clear();
                subsetUndistorted.add(undistortedPoints.get(samplesIndices[0]));
                subsetUndistorted.add(undistortedPoints.get(samplesIndices[1]));

                try {
                    radialDistortionEstimator.setPoints(distortedPoints, undistortedPoints);
                    radialDistortionEstimator.setPoints(subsetDistorted, subsetUndistorted);

                    final var distortion = radialDistortionEstimator.estimate();
                    solutions.add(distortion);
                } catch (final Exception e) {
                    // if anything fails, no solution is added
                }
            }

            @Override
            public double computeResidual(final RadialDistortion currentEstimation, final int i) {
                final var distortedPoint = distortedPoints.get(i);
                final var undistortedPoint = undistortedPoints.get(i);

                currentEstimation.distort(undistortedPoint, testPoint);

                return testPoint.distanceTo(distortedPoint);
            }

            @Override
            public boolean isReady() {
                return MSACRadialDistortionRobustEstimator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/MSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/MSACRobustSinglePoint3DTriangulator.html#L176">176</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.html#L292">292</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/RANSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/RANSACRobustSinglePoint3DTriangulator.html#L176">176</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final var innerEstimator = new MSACRobustEstimator&lt;Point3D&gt;(new MSACRobustEstimatorListener&lt;&gt;() {

            // point to be reused when computing residuals
            private final Point2D testPoint = Point2D.create(CoordinatesType.HOMOGENEOUS_COORDINATES);

            // non-robust 3D point triangulator
            private final SinglePoint3DTriangulator triangulator = SinglePoint3DTriangulator.create(
                    useHomogeneousSolution ? Point3DTriangulatorType.LMSE_HOMOGENEOUS_TRIANGULATOR
                            : Point3DTriangulatorType.LMSE_INHOMOGENEOUS_TRIANGULATOR);

            // subset of 2D points
            private final List&lt;Point2D&gt; subsetPoints = new ArrayList&lt;&gt;();

            // subst of cameras
            private final List&lt;PinholeCamera&gt; subsetCameras = new ArrayList&lt;&gt;();

            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return points2D.size();
            }

            @Override
            public int getSubsetSize() {
                return MIN_REQUIRED_VIEWS;
            }

            @Override
            public void estimatePreliminarSolutions(final int[] samplesIndices, final List&lt;Point3D&gt; solutions) {
                subsetPoints.clear();
                subsetPoints.add(points2D.get(samplesIndices[0]));
                subsetPoints.add(points2D.get(samplesIndices[1]));

                subsetCameras.clear();
                subsetCameras.add(cameras.get(samplesIndices[0]));
                subsetCameras.add(cameras.get(samplesIndices[1]));

                try {
                    triangulator.setPointsAndCameras(subsetPoints, subsetCameras);
                    final var triangulated = triangulator.triangulate();
                    solutions.add(triangulated);
                } catch (final Exception e) {
                    // if anything fails, no solution is added
                }
            }

            @Override
            public double computeResidual(final Point3D currentEstimation, final int i) {
                final var point2D = points2D.get(i);
                final var camera = cameras.get(i);

                // project estimated point with camera
                camera.project(currentEstimation, testPoint);

                // return distance of projected point respect to the original one
                // as a residual
                return testPoint.distanceTo(point2D);
            }

            @Override
            public boolean isReady() {
                return MSACRobustSinglePoint3DTriangulator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L247">247</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L389">389</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);
                a.setElementAt(counter, 1, h11 * h22 + h21 * h12);
                a.setElementAt(counter, 2, h21 * h22);
                a.setElementAt(counter, 3, h11 * h32 + h31 * h12);
                a.setElementAt(counter, 4, h21 * h32 + h31 * h22);
                a.setElementAt(counter, 5, h31 * h32);

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0)
                        + Math.pow(a.getElementAt(counter, 3), 2.0)
                        + Math.pow(a.getElementAt(counter, 4), 2.0)
                        + Math.pow(a.getElementAt(counter, 5), 2.0));</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L477">477</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L564">564</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

            if (jacobianU != null) {
                jacobianU.initialize(0.0);
                // variation of position
                for (var i = 0; i &lt; Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH; i++) {
                    jacobianU.setElementAt(i, i, 1.0);
                }
                // variation of linear and angular speed
                for (int i = 7, j = Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH;
                     i &lt; STATE_WITH_POSITION_ADJUSTMENT_COMPONENTS; i++, j++) {
                    jacobianU.setElementAt(i, j, 1.0);
                }
            }
        } catch (final WrongSizeException ignore) {
            // never thrown
        }
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration) when no velocity control signal is present.
     *
     * @param x      initial system state containing: position-x, position-y,
     *               position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *               linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *               angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *               length 13.
     * @param u      linear ang angular velocity perturbations or controls and
     *               position perturbations or controls: position-change-x, position-change-y,
     *               position-change-z, linear-velocity-change-x, linear-velocity-change-y,
     *               linear-velocity-change-z, angular-velocity-change-x,
     *               angular-velocity-change-y, angular-velocity-change-z. Must have length 9.
     * @param dt     time interval to compute prediction expressed in seconds.
     * @param result instance where updated system model will be stored. Must
     *               have length 13.
     * @throws IllegalArgumentException if system state array, control array
     *                                  or result array do not have proper size.
     */
    public static void predictWithPositionAdjustment(
            final double[] x, final double[] u, final double dt, final double[] result) {
        predictWithPositionAdjustment(x, u, dt, result, null, null);
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration) when no velocity control signal is present.
     *
     * @param x         initial system state containing: position-x, position-y,
     *                  position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *                  linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *                  angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *                  length 13.
     * @param u         linear ang angular velocity perturbations or controls and
     *                  position perturbations or controls: position-change-x, position-change-y,
     *                  position-change-z, linear-velocity-change-x, linear-velocity-change-y,
     *                  linear-velocity-change-z, angular-velocity-change-x,
     *                  angular-velocity-change-y, angular-velocity-change-z. Must have length 9.
     * @param dt        time interval to compute prediction expressed in seconds.
     * @param jacobianX jacobian wrt system state. Must be 13x13.
     * @param jacobianU jacobian wrt control. Must be 13x9.
     * @return a new instance containing updated system model.
     * @throws IllegalArgumentException if system state array, control array
     *                                  or jacobians do not have proper size.
     */
    public static double[] predictWithPositionAdjustment(
            final double[] x, final double[] u, final double dt, final Matrix jacobianX, final Matrix jacobianU) {
        final var result = new double[STATE_WITH_POSITION_ADJUSTMENT_COMPONENTS];
        predictWithPositionAdjustment(x, u, dt, result, jacobianX, jacobianU);
        return result;
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration) when no velocity control signal is present.
     *
     * @param x  initial system state containing: position-x, position-y,
     *           position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *           linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *           angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *           length 13.
     * @param u  linear ang angular velocity perturbations or controls and
     *           position perturbations or controls: position-change-x, position-change-y,
     *           position-change-z, linear-velocity-change-x, linear-velocity-change-y,
     *           linear-velocity-change-z, angular-velocity-change-x,
     *           angular-velocity-change-y, angular-velocity-change-z. Must have length 9.
     * @param dt time interval to compute prediction expressed in seconds.
     * @return a new instance containing updated system model.
     * @throws IllegalArgumentException if system state or control array do not
     *                                  have proper size.
     */
    public static double[] predictWithPositionAdjustment(final double[] x, final double[] u, final double dt) {
        final var result = new double[STATE_WITH_POSITION_ADJUSTMENT_COMPONENTS];
        predictWithPositionAdjustment(x, u, dt, result);
        return result;
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration) when no velocity control signal is present.
     *
     * @param x         initial system state containing: position-x, position-y,
     *                  position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *                  linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *                  angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *                  length 13.
     * @param u         linear and angular velocity perturbations or controls, and
     *                  rotation perturbations or controls: quaternion-change-a,
     *                  quaternion-change-b, quaternion-change-c, quaternion-change-d,
     *                  linear-velocity-change-x, linear-velocity-change-y,
     *                  linear-velocity-change-z, angular-velocity-change-x,
     *                  angular-velocity-change-y, angular-velocity-change-z. Must have length
     *                  10.
     * @param dt        time interval to compute prediction expressed in seconds.
     * @param result    instance where updated system model will be stored. Must
     *                  have length 13.
     * @param jacobianX jacobian wrt system state. Must be 13x13.
     * @param jacobianU jacobian wrt control. Must be 13x10.
     * @throws IllegalArgumentException if system state array, control array,
     *                                  result or jacobians do not have proper size.
     */
    public static void predictWithRotationAdjustment(
            final double[] x, final double[] u, final double dt, final double[] result, final Matrix jacobianX,
            final Matrix jacobianU) {
        if (x.length != STATE_WITH_ROTATION_ADJUSTMENT_COMPONENTS) {
            throw new IllegalArgumentException(&quot;x must have length 13&quot;);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L757">757</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L500">500</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>if (samples.length != MIN_NUMBER_OF_VIEWS) {
                return false;
            }

            leftSamples.add(samples[0]);
            rightSamples.add(samples[1]);

            final var leftPoint = Point2D.create();
            leftPoint.setInhomogeneousCoordinates(
                    samples[0].getPoint().getInhomX() - principalPointX,
                    samples[0].getPoint().getInhomY() - principalPointY);
            leftPoints.add(leftPoint);

            final var rightPoint = Point2D.create();
            rightPoint.setInhomogeneousCoordinates(
                    samples[1].getPoint().getInhomX() - principalPointX,
                    samples[1].getPoint().getInhomY() - principalPointY);
            rightPoints.add(rightPoint);

            qualityScores[i] = match.getQualityScore();
            i++;
        }

        try {
            final var estimator = FundamentalMatrixRobustEstimator.create(leftPoints, rightPoints, qualityScores,
                    configuration.getRobustFundamentalMatrixEstimatorMethod());
            estimator.setNonRobustFundamentalMatrixEstimatorMethod(
                    configuration.getNonRobustFundamentalMatrixEstimatorMethod());
            estimator.setResultRefined(configuration.isFundamentalMatrixRefined());
            estimator.setCovarianceKept(configuration.isFundamentalMatrixCovarianceKept());
            estimator.setConfidence(configuration.getFundamentalMatrixConfidence());
            estimator.setMaxIterations(configuration.getFundamentalMatrixMaxIterations());

            switch (configuration.getRobustFundamentalMatrixEstimatorMethod()) {
                case LMEDS:
                    ((LMedSFundamentalMatrixRobustEstimator) estimator).setStopThreshold(
                            configuration.getFundamentalMatrixThreshold());
                    break;
                case MSAC:
                    ((MSACFundamentalMatrixRobustEstimator) estimator).setThreshold(
                            configuration.getFundamentalMatrixThreshold());
                    break;
                case PROMEDS:
                    ((PROMedSFundamentalMatrixRobustEstimator) estimator).setStopThreshold(
                            configuration.getFundamentalMatrixThreshold());
                    break;
                case PROSAC:</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L666">666</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L924">924</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>PositionPredictor.predict(r, vx, vy, vz, dt, r, rr, rv, null);

            // update orientation
            Matrix qq = null;
            Matrix qdq = null;
            Matrix qw = null;
            if (jacobianX != null) {
                qq = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);
                qw = new Matrix(Quaternion.N_PARAMS, ANGULAR_SPEED_COMPONENTS);
            }
            if (jacobianU != null) {
                qdq = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);
            }
            q = QuaternionPredictor.predictWithRotationAdjustment(q, dq, wx, wy, wz, dt, qq, qdq, qw);

            // apply control signals
            vx += uvx;
            vy += uvy;
            vz += uvz;

            wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = wx;
            result[11] = wy;
            result[12] = wz;

            // jacobians
            if (jacobianX != null) {
                // [Rr   0   Rv  0  ]
                // [0    Qq  0   Qw ]
                // [0    0   eye 0  ]
                // [0    0   0   eye]
                jacobianX.initialize(0.0);
                jacobianX.setSubmatrix(0, 0, 2, 2, rr);

                jacobianX.setSubmatrix(3, 3, 6, 6, qq);

                jacobianX.setSubmatrix(0, 7, 2, 9, rv);

                for (var i = 7; i &lt; STATE_WITH_ROTATION_ADJUSTMENT_COMPONENTS; i++) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/DualImageOfAbsoluteConicInitialCamerasEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/DualImageOfAbsoluteConicInitialCamerasEstimator.html#L398">398</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/EssentialMatrixInitialCamerasEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/EssentialMatrixInitialCamerasEstimator.html#L535">535</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Gets matched 2D points on left view.
     *
     * @return matched 2D points on left view.
     */
    public List&lt;Point2D&gt; getLeftPoints() {
        return leftPoints;
    }

    /**
     * Sets matched 2D points on left view.
     *
     * @param leftPoints matched 2D points on left view.
     * @throws LockedException if estimator is locked.
     */
    public void setLeftPoints(final List&lt;Point2D&gt; leftPoints) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.leftPoints = leftPoints;
    }

    /**
     * Gets matched 2D points on right view.
     *
     * @return matched 2D points on right view.
     */
    public List&lt;Point2D&gt; getRightPoints() {
        return rightPoints;
    }

    /**
     * Sets matched 2D points on right view.
     *
     * @param rightPoints matched 2D points on right view.
     * @throws LockedException if estimator is locked.
     */
    public void setRightPoints(final List&lt;Point2D&gt; rightPoints) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.rightPoints = rightPoints;
    }

    /**
     * Sets matched 2D points on left and right views.
     *
     * @param leftPoints  matched 2D points on left view.
     * @param rightPoints matched 2D points on right view.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  size.
     */
    public void setLeftAndRightPoints(final List&lt;Point2D&gt; leftPoints, final List&lt;Point2D&gt; rightPoints)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetLeftAndRightPoints(leftPoints, rightPoints);
    }

    /**
     * Gets type of corrector to use to triangulate matched points or null if
     * no corrector needs to be used.
     *
     * @return type of corrector to use.
     */
    public CorrectorType getCorrectorType() {
        return correctorType;
    }

    /**
     * Sets type of corrector to use to triangulate matched points or null if
     * no corrector needs to be used.
     *
     * @param correctorType type of corrector to use.
     * @throws LockedException if estimator is locked.
     */
    public void setCorrectorType(final CorrectorType correctorType) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.correctorType = correctorType;
    }

    /**
     * Indicates whether matched 2D points need to be triangulated or not.
     *
     * @return true if 2D points need to be triangulated, false otherwise.
     */
    public boolean arePointsTriangulated() {
        return triangulatePoints;
    }

    /**
     * Specifies whether matched 2D points need to be triangulated or not.
     *
     * @param triangulatePoints true if 2D points need to be triangulated, false
     *                          otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPointsTriangulated(final boolean triangulatePoints) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.triangulatePoints = triangulatePoints;
    }

    /**
     * Indicates which triangulated points are marked as valid (lie in front
     * of both of the estimated cameras) and which ones aren't.
     *
     * @return true to mark valid and invalid triangulated points, false
     * otherwise.
     */
    public boolean areValidTriangulatedPointsMarked() {
        return markValidTriangulatedPoints;
    }

    /**
     * Specifies whether triangulated points are marked as valid (lie in front
     * of both of the estimated cameras) and which ones aren't.
     *
     * @param markValidTriangulatedPoints true to mark valid and invalid
     *                                    triangulated points, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setValidTriangulatedPointsMarked(final boolean markValidTriangulatedPoints) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.markValidTriangulatedPoints = markValidTriangulatedPoints;
    }

    /**
     * Gets triangulated points, if available.
     *
     * @return triangulated points or null.
     */
    public List&lt;Point3D&gt; getTriangulatedPoints() {
        return triangulatedPoints;
    }

    /**
     * Gets bitset indicating which of the triangulated points are valid and
     * which ones aren't.
     *
     * @return bitset indicating validity of triangulated points or null if not
     * available.
     */
    public BitSet getValidTriangulatedPoints() {
        return validTriangulatedPoints;
    }

    /**
     * Generates a pair of metric cameras (up to an arbitrary space) by
     * estimating the intrinsic parameters of the views by solving the Kruppa
     * equations to obtain the Dual Image of Absolute Conic (DIAC).
     * The estimated intrinsic parameters can later be used to find the
     * essential matrix (assuming that both views have the same intrinsic
     * parameters), and the essential matrix along with provided matched 2D
     * points can be used to determine the best pair of camera pose and
     * translation that yields the largest number of triangulated points laying
     * in front of both of the estimated cameras.
     * This method uses default corrector type, does not keep triangulated
     * points or valid triangulated points, and uses default aspect ratio (1.0).
     *
     * @param fundamentalMatrix fundamental matrix relating both left and right
     *                          views.
     * @param principalPointX   horizontal coordinate of principal point. This
     *                          value should be the coordinates of the center of an image assuming that
     *                          the coordinates start on the top-left or bottom-left corner. Using a
     *                          value close to zero will produce inaccurate results.
     * @param principalPointY   vertical coordinate of principal point. This
     *                          value should be the coordinates of the center of an image assuming that
     *                          the coordinates start on the top-left or bottom-left corner. Using a
     *                          value close to zero will produce inaccurate results.
     * @param leftPoints        points on left view matched with points on right view,
     *                          so they can be triangulated using estimated cameras. Both lists of points
     *                          must have the same size.
     * @param rightPoints       points on right view matched with points on left view,
     *                          so they can be triangulated using estimated cameras. Both lists of points
     *                          must have the same size.
     * @param leftCamera        instance where estimated left camera will be stored.
     * @param rightCamera       instance where estimated right camera will be stored.
     * @return number of valid triangulated points which lie in front of the two
     * estimated cameras.
     * @throws InitialCamerasEstimationFailedException if estimation of cameras
     *                                                 fails for some reason, typically due to numerical
     *                                                 instabilities.
     * @throws IllegalArgumentException                if provided lists of left and right
     *                                                 points don't have the same size.
     */
    public static int generateInitialMetricCamerasUsingDIAC(</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.html#L401">401</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.html#L425">425</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>lastAngularSpeedX = stateAngularSpeedX;
        lastAngularSpeedY = stateAngularSpeedY;
        lastAngularSpeedZ = stateAngularSpeedZ;
        lastTimestampNanos = timestamp;

        if (listener != null) {
            listener.onFullSampleProcessed(this);
        }
    }

    /**
     * Resets position, linear velocity, linear acceleration, orientation and
     * angular speed to provided values.
     * This method implementation also resets Kalman filter state.
     *
     * @param statePositionX     position along x-axis expressed in meters (m).
     * @param statePositionY     position along y-axis expressed in meters (m).
     * @param statePositionZ     position along z-axis expressed in meters (m).
     * @param stateVelocityX     linear velocity along x-axis expressed in meters
     *                           per second (m/s).
     * @param stateVelocityY     linear velocity along y-axis expressed in meters
     *                           per second (m/s).
     * @param stateVelocityZ     linear velocity along z-axis expressed in meters
     *                           per second (m/s).
     * @param stateAccelerationX linear acceleration along x-axis expressed in
     *                           meters per squared second (m/s^2).
     * @param stateAccelerationY linear acceleration along y-axis expressed in
     *                           meters per squared second (m/s^2).
     * @param stateAccelerationZ linear acceleration along z-axis expressed in
     *                           meters per squared second (m/s^2).
     * @param stateQuaternionA   A value of orientation quaternion.
     * @param stateQuaternionB   B value of orientation quaternion.
     * @param stateQuaternionC   C value of orientation quaternion.
     * @param stateQuaternionD   D value of orientation quaternion.
     * @param stateAngularSpeedX angular speed along x-axis expressed in radians
     *                           per second (rad/s).
     * @param stateAngularSpeedY angular speed along y-axis expressed in radians
     *                           per second (rad/s).
     * @param stateAngularSpeedZ angular speed along z-axis expressed in radians
     *                           per second (rad/s).
     */
    @Override
    protected void reset(
            final double statePositionX, final double statePositionY, final double statePositionZ,
            final double stateVelocityX, final double stateVelocityY, final double stateVelocityZ,
            final double stateAccelerationX, final double stateAccelerationY, final double stateAccelerationZ,
            final double stateQuaternionA, final double stateQuaternionB,
            final double stateQuaternionC, final double stateQuaternionD,
            final double stateAngularSpeedX, final double stateAngularSpeedY, final double stateAngularSpeedZ) {
        super.reset(statePositionX, statePositionY, statePositionZ, stateVelocityX, stateVelocityY, stateVelocityZ,
                stateAccelerationX, stateAccelerationY, stateAccelerationZ,
                stateQuaternionA, stateQuaternionB, stateQuaternionC, stateQuaternionD,
                stateAngularSpeedX, stateAngularSpeedY, stateAngularSpeedZ);
        //noinspection ConstantValue
        if (stateOrientation != null) {
            stateOrientation.setA(stateQuaternionA);
            stateOrientation.setB(stateQuaternionB);
            stateOrientation.setC(stateQuaternionC);
            stateOrientation.setD(stateQuaternionD);
        }

        //noinspection ConstantValue
        if (lastOrientation != null) {
            lastOrientation.setA(1.0);
            lastOrientation.setB(0.0);
            lastOrientation.setC(0.0);
            lastOrientation.setD(0.0);
        }

        if (x != null) {
            // position
            x[0] = statePositionX;
            x[1] = statePositionY;
            x[2] = statePositionZ;

            // quaternion
            x[3] = stateQuaternionA;
            x[4] = stateQuaternionB;
            x[5] = stateQuaternionC;
            x[6] = stateQuaternionD;

            // velocity
            x[7] = stateVelocityX;
            x[8] = stateVelocityY;
            x[9] = stateVelocityZ;

            // angular speed
            x[10] = stateAngularSpeedX;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L726">726</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L861">861</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

            if (jacobianU != null) {
                jacobianU.initialize(0.0);

                // variation of rotation
                jacobianU.setSubmatrix(3, 0, 6, 3, qdq);

                // variation of linear and angular speed
                for (int i = 7, j = Quaternion.N_PARAMS;
                     i &lt; STATE_WITH_ROTATION_ADJUSTMENT_COMPONENTS; i++, j++) {
                    jacobianU.setElementAt(i, j, 1.0);
                }
            }

        } catch (final WrongSizeException ignore) {
            // never thrown
        }
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration) when no velocity control signal is present.
     *
     * @param x      initial system state containing: position-x, position-y,
     *               position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *               linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *               angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *               length 13.
     * @param u      linear and angular velocity perturbations or controls, and
     *               rotation perturbations or controls: quaternion-change-a,
     *               quaternion-change-b, quaternion-change-c, quaternion-change-d,
     *               linear-velocity-change-x, linear-velocity-change-y,
     *               linear-velocity-change-z, angular-velocity-change-x,
     *               angular-velocity-change-y, angular-velocity-change-z. Must have length
     *               10.
     * @param dt     time interval to compute prediction expressed in seconds.
     * @param result instance where updated system model will be stored. Must
     *               have length 13.
     * @throws IllegalArgumentException if system state array, control array or
     *                                  result do not have proper length.
     */
    public static void predictWithRotationAdjustment(
            final double[] x, final double[] u, final double dt, final double[] result) {
        predictWithRotationAdjustment(x, u, dt, result, null, null);
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration) when no velocity control signal is present.
     *
     * @param x         initial system state containing: position-x, position-y,
     *                  position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *                  linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *                  angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *                  length 13.
     * @param u         linear and angular velocity perturbations or controls, and
     *                  rotation perturbations or controls: quaternion-change-a,
     *                  quaternion-change-b, quaternion-change-c, quaternion-change-d,
     *                  linear-velocity-change-x, linear-velocity-change-y,
     *                  linear-velocity-change-z, angular-velocity-change-x,
     *                  angular-velocity-change-y, angular-velocity-change-z. Must have length
     *                  10.
     * @param dt        time interval to compute prediction expressed in seconds.
     * @param jacobianX jacobian wrt system state. Must be 13x13.
     * @param jacobianU jacobian wrt control. Must be 13x10.
     * @return a new array containing updated system model.
     * @throws IllegalArgumentException if system state array, control array
     *                                  or jacobians do not have proper size.
     */
    public static double[] predictWithRotationAdjustment(
            final double[] x, final double[] u, final double dt, final Matrix jacobianX, final Matrix jacobianU) {
        final var result = new double[STATE_WITH_ROTATION_ADJUSTMENT_COMPONENTS];
        predictWithRotationAdjustment(x, u, dt, result, jacobianX, jacobianU);
        return result;
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration) when no velocity control signal is present.
     *
     * @param x  initial system state containing: position-x, position-y,
     *           position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *           linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *           angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *           length 13.
     * @param u  linear and angular velocity perturbations or controls, and
     *           rotation perturbations or controls: quaternion-change-a,
     *           quaternion-change-b, quaternion-change-c, quaternion-change-d,
     *           linear-velocity-change-x, linear-velocity-change-y,
     *           linear-velocity-change-z, angular-velocity-change-x,
     *           angular-velocity-change-y, angular-velocity-change-z. Must have length
     *           10.
     * @param dt time interval to compute prediction expressed in seconds.
     * @return a new array containing updated system model.
     * @throws IllegalArgumentException if system state array or control array
     *                                  do not have proper size.
     */
    public static double[] predictWithRotationAdjustment(final double[] x, final double[] u, final double dt) {
        final var result = new double[STATE_WITH_ROTATION_ADJUSTMENT_COMPONENTS];
        predictWithRotationAdjustment(x, u, dt, result);
        return result;
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration) when no velocity control signal is present.
     *
     * @param x         initial system state containing: position-x, position-y,
     *                  position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *                  linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *                  angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *                  length 13.
     * @param u         linear and angular velocity perturbations or controls, position
     *                  perturbations or controls and rotation perturbation or control:
     *                  position-change-x, position-change-y, position-change-z,
     *                  quaternion-change-a, quaternion-change-b, quaternion-change-c,
     *                  quaternion-change-d, linear-velocity-change-x, linear-velocity-change-y,
     *                  linear-velocity-change-z, angular-velocity-change-x,
     *                  angular-velocity-change-y, angular-velocity-change-z. Must have length
     *                  12.
     * @param dt        time interval to compute prediction expressed in seconds.
     * @param result    instance where updated system model will be stored. Must
     *                  have length 13.
     * @param jacobianX jacobian wrt system state. Must be 13x13.
     * @param jacobianU jacobian wrt control. Must be 13x13.
     * @throws IllegalArgumentException if system state array, control array,
     *                                  result or jacobians do not have proper size.
     */
    public static void predictWithPositionAndRotationAdjustment(
            final double[] x, final double[] u, final double dt, final double[] result, final Matrix jacobianX,
            final Matrix jacobianU) {
        if (x.length != STATE_WITH_POSITION_AND_ROTATION_ADJUSTMENT_COMPONENTS) {
            throw new IllegalArgumentException(&quot;x must have length 13&quot;);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/WeightedHomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/WeightedHomogeneousSinglePoint3DTriangulator.html#L161">161</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/WeightedInhomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/WeightedInhomogeneousSinglePoint3DTriangulator.html#L161">161</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public WeightedHomogeneousSinglePoint3DTriangulator(
            final List&lt;Point2D&gt; points2D, final List&lt;PinholeCamera&gt; cameras, final double[] weights,
            final SinglePoint3DTriangulatorListener listener) {
        this(listener);
        internalSetPointsCamerasAndWeights(points2D, cameras, weights);
    }

    /**
     * Returns weights assigned to each view.
     * The larger a weight is the more reliable a view is considered and
     * equations to triangulate a 3D point will be take precedence over other
     * views when estimating an averaged solution.
     *
     * @return weights assigned to each view.
     */
    public double[] getWeights() {
        return weights;
    }

    /**
     * Sets list of matched 2D points for each view and their corresponding
     * cameras used to project them along with their weights.
     *
     * @param points2D list of matched 2D points on each view. Each point in the
     *                 list is assumed to be projected by the corresponding camera in the list.
     * @param cameras  cameras for each view where 2D points are represented.
     * @param weights  weights assigned to each view.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  length or their length is less than 2 views, which is the minimum
     *                                  required to compute triangulation.
     */
    public void setPointsCamerasAndWeights(
            final List&lt;Point2D&gt; points2D, final List&lt;PinholeCamera&gt; cameras, final double[] weights)
            throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetPointsCamerasAndWeights(points2D, cameras, weights);
    }

    /**
     * Indicates whether this instance is ready to start the triangulation.
     * An instance is ready when both lists of 2D points and cameras are
     * provided, both lists have the same length, at least data for 2 views
     * is provided and the corresponding weights are also provided.
     *
     * @return true if this instance is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return areValidPointsCamerasAndWeights(points2D, cameras, weights);
    }

    /**
     * Indicates whether provided points, cameras and weights are valid to start
     * the triangulation.
     * In order to triangulate points, at least two cameras and their
     * corresponding 2 matched 2D points are required along with weights for
     * each view.
     * If more views are provided, an averaged solution can be found.
     *
     * @param points2D list of matched points on each view.
     * @param cameras  cameras for each view where 2D points are represented.
     * @param weights  weights assigned to each view.
     * @return true if data is enough to start triangulation, false otherwise.
     */
    public static boolean areValidPointsCamerasAndWeights(
            final List&lt;Point2D&gt; points2D, final List&lt;PinholeCamera&gt; cameras, final double[] weights) {
        return areValidPointsAndCameras(points2D, cameras) &amp;&amp; weights != null &amp;&amp; weights.length == points2D.size();
    }

    /**
     * Returns maximum number of correspondences to be weighted and taken into
     * account.
     *
     * @return maximum number of correspondences to be weighted.
     */
    public int getMaxCorrespondences() {
        return maxCorrespondences;
    }

    /**
     * Sets maximum number of correspondences to be weighted and taken into
     * account.
     *
     * @param maxCorrespondences maximum number of correspondences to be
     *                           weighted.
     * @throws IllegalArgumentException if provided value is less than the
     *                                  minimum required number of views, which is 2.
     * @throws LockedException          if this instance is locked.
     */
    public void setMaxCorrespondences(final int maxCorrespondences) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (maxCorrespondences &lt; MIN_REQUIRED_VIEWS) {
            throw new IllegalArgumentException();
        }

        this.maxCorrespondences = maxCorrespondences;
    }

    /**
     * Indicates if weights are sorted by so that largest weighted
     * correspondences are used first.
     *
     * @return true if weights are sorted, false otherwise.
     */
    public boolean isSortWeightsEnabled() {
        return sortWeights;
    }

    /**
     * Specifies whether weights are sorted by so that largest weighted
     * correspondences are used first.
     *
     * @param sortWeights true if weights are sorted, false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setSortWeightsEnabled(final boolean sortWeights) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.sortWeights = sortWeights;
    }

    /**
     * Returns type of triangulator.
     *
     * @return type of triangulator.
     */
    @Override
    public Point3DTriangulatorType getType() {
        return Point3DTriangulatorType.WEIGHTED_HOMOGENEOUS_TRIANGULATOR;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructor.html#L405">405</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamSparseReconstructor.html#L352">352</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var positionZ = lastPosZ + slamEstimator.getStatePositionZ();

        final var velocityX = slamEstimator.getStateVelocityX();
        final var velocityY = slamEstimator.getStateVelocityY();
        final var velocityZ = slamEstimator.getStateVelocityZ();

        final var accelerationX = slamEstimator.getStateAccelerationX();
        final var accelerationY = slamEstimator.getStateAccelerationY();
        final var accelerationZ = slamEstimator.getStateAccelerationZ();

        final var quaternionA = slamEstimator.getStateQuaternionA();
        final var quaternionB = slamEstimator.getStateQuaternionB();
        final var quaternionC = slamEstimator.getStateQuaternionC();
        final var quaternionD = slamEstimator.getStateQuaternionD();

        final var angularSpeedX = slamEstimator.getStateAngularSpeedX();
        final var angularSpeedY = slamEstimator.getStateAngularSpeedY();
        final var angularSpeedZ = slamEstimator.getStateAngularSpeedZ();

        //noinspection unchecked
        listener.onSlamDataAvailable((R) this, positionX, positionY, positionZ, velocityX, velocityY, velocityZ,
                accelerationX, accelerationY, accelerationZ, quaternionA, quaternionB, quaternionC, quaternionD,
                angularSpeedX, angularSpeedY, angularSpeedZ, slamEstimator.getStateCovariance());
    }

    /**
     * Notifies estimated camera by means of SLAM if notification is enabled at
     * configuration time and intrinsics are already available.
     */
    private void notifySlamCameraIfNeeded() {
        if (!configuration.isNotifyEstimatedSlamCameraEnabled()) {
            return;
        }

        // try with current camera
        var camera = currentEuclideanEstimatedCamera != null ? currentEuclideanEstimatedCamera.getCamera() : null;
        if (camera == null) {
            // if not available try with previous camera
            camera = previousEuclideanEstimatedCamera != null ? previousEuclideanEstimatedCamera.getCamera() : null;
        }

        try {
            PinholeCameraIntrinsicParameters intrinsicParameters = null;
            if (camera != null) {
                if (!camera.areIntrinsicParametersAvailable()) {
                    // decompose camera to obtain intrinsic parameters
                    camera.decompose();
                }

                intrinsicParameters = camera.getIntrinsicParameters();
            } else if (configuration.areIntrinsicParametersKnown()) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L896">896</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L637">637</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>if (samples.length != MIN_NUMBER_OF_VIEWS) {
                return false;
            }

            leftSamples.add(samples[0]);
            rightSamples.add(samples[1]);

            final var leftPoint = Point2D.create();
            leftPoint.setInhomogeneousCoordinates(
                    samples[0].getPoint().getInhomX() - principalPointX,
                    samples[0].getPoint().getInhomY() - principalPointY);
            leftPoints.add(leftPoint);

            final var rightPoint = Point2D.create();
            rightPoint.setInhomogeneousCoordinates(
                    samples[1].getPoint().getInhomX() - principalPointX,
                    samples[1].getPoint().getInhomY() - principalPointY);
            rightPoints.add(rightPoint);

            qualityScores[i] = match.getQualityScore();
            i++;
        }

        try {
            final var homographyEstimator = PointCorrespondenceProjectiveTransformation2DRobustEstimator.create(
                    configuration.getRobustPlanarHomographyEstimatorMethod());
            homographyEstimator.setResultRefined(configuration.isPlanarHomographyRefined());
            homographyEstimator.setCovarianceKept(configuration.isPlanarHomographyCovarianceKept());
            homographyEstimator.setConfidence(configuration.getPlanarHomographyConfidence());
            homographyEstimator.setMaxIterations(configuration.getPlanarHomographyMaxIterations());

            switch (configuration.getRobustPlanarHomographyEstimatorMethod()) {
                case LMEDS:
                    ((LMedSPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator)
                            .setStopThreshold(configuration.getPlanarHomographyThreshold());
                    break;
                case MSAC:
                    ((MSACPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator)
                            .setThreshold(configuration.getPlanarHomographyThreshold());
                    break;
                case PROMEDS:
                    ((PROMedSPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator)
                            .setStopThreshold(configuration.getPlanarHomographyThreshold());
                    break;
                case PROSAC:</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1480">1480</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L516">516</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>p2.getInhomY() - principalPointY);
            rightPoints.add(rightPoint);

            qualityScores[i] = match.getQualityScore();
            i++;
        }

        try {
            final var estimator = FundamentalMatrixRobustEstimator.create(leftPoints, rightPoints, qualityScores,
                    configuration.getRobustFundamentalMatrixEstimatorMethod());
            estimator.setNonRobustFundamentalMatrixEstimatorMethod(
                    configuration.getNonRobustFundamentalMatrixEstimatorMethod());
            estimator.setResultRefined(configuration.isFundamentalMatrixRefined());
            estimator.setCovarianceKept(configuration.isFundamentalMatrixCovarianceKept());
            estimator.setConfidence(configuration.getFundamentalMatrixConfidence());
            estimator.setMaxIterations(configuration.getFundamentalMatrixMaxIterations());

            switch (configuration.getRobustFundamentalMatrixEstimatorMethod()) {
                case LMEDS:
                    ((LMedSFundamentalMatrixRobustEstimator) estimator)
                            .setStopThreshold(configuration.getFundamentalMatrixThreshold());
                    break;
                case MSAC:
                    ((MSACFundamentalMatrixRobustEstimator) estimator)
                            .setThreshold(configuration.getFundamentalMatrixThreshold());
                    break;
                case PROMEDS:
                    ((PROMedSFundamentalMatrixRobustEstimator) estimator)
                            .setStopThreshold(configuration.getFundamentalMatrixThreshold());
                    break;
                case PROSAC:
                    var prosacEstimator = (PROSACFundamentalMatrixRobustEstimator) estimator;
                    prosacEstimator.setThreshold(configuration.getFundamentalMatrixThreshold());
                    prosacEstimator.setComputeAndKeepInliersEnabled(
                            configuration.getFundamentalMatrixComputeAndKeepInliers());
                    prosacEstimator.setComputeAndKeepResidualsEnabled(
                            configuration.getFundamentalMatrixComputeAndKeepResiduals());
                    break;
                case RANSAC:
                    var ransacEstimator = (RANSACFundamentalMatrixRobustEstimator) estimator;
                    ransacEstimator.setThreshold(configuration.getFundamentalMatrixThreshold());
                    ransacEstimator.setComputeAndKeepInliersEnabled(
                            configuration.getFundamentalMatrixComputeAndKeepInliers());
                    ransacEstimator.setComputeAndKeepResidualsEnabled(
                            configuration.getFundamentalMatrixComputeAndKeepResiduals());
                    break;
                default:
                    break;
            }

            final var fundamentalMatrix = estimator.estimate();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L978">978</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1701">1701</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>if (intrinsic1 == null &amp;&amp; intrinsic2 == null) {
                // estimate homography
                final var homography = homographyEstimator.estimate();

                // estimate intrinsic parameters using the Image of Absolute
                // Conic (IAC)
                final var homographies = new ArrayList&lt;Transformation2D&gt;();
                homographies.add(homography);

                final var iacEstimator = new LMSEImageOfAbsoluteConicEstimator(homographies);
                final var iac = iacEstimator.estimate();

                intrinsic1 = intrinsic2 = iac.getIntrinsicParameters();

            } else if (intrinsic1 == null) { // &amp;&amp; intrinsic2 != null
                intrinsic1 = intrinsic2;
            } else if (intrinsic2 == null) { // &amp;&amp; intrinsic1 != null
                intrinsic2 = intrinsic1;
            }
            fundamentalMatrixEstimator.setLeftIntrinsics(intrinsic1);
            fundamentalMatrixEstimator.setRightIntrinsics(intrinsic2);

            fundamentalMatrixEstimator.estimateAndReconstruct();

            final var fundamentalMatrix = fundamentalMatrixEstimator.getFundamentalMatrix();

            currentEstimatedFundamentalMatrix = new EstimatedFundamentalMatrix();
            currentEstimatedFundamentalMatrix.setFundamentalMatrix(fundamentalMatrix);
            currentEstimatedFundamentalMatrix.setViewId1(viewId1);
            currentEstimatedFundamentalMatrix.setViewId2(viewId2);

            // determine quality score and inliers
            final var inliersData = homographyEstimator.getInliersData();
            if (inliersData != null) {
                final var numInliers = inliersData.getNumInliers();
                final var inliers = inliersData.getInliers();
                final var length = inliers.length();
                var fundamentalMatrixQualityScore = 0.0;
                for (i = 0; i &lt; length; i++) {
                    if (inliers.get(i)) {
                        // inlier
                        fundamentalMatrixQualityScore += qualityScores[i] / numInliers;
                    }
                }
                currentEstimatedFundamentalMatrix.setQualityScore(
                        fundamentalMatrixQualityScore);
                currentEstimatedFundamentalMatrix.setInliers(inliers);
            }

            // store left/right samples
            currentEstimatedFundamentalMatrix.setLeftSamples(leftSamples);
            currentEstimatedFundamentalMatrix.setRightSamples(rightSamples);

            return true;
        } catch (final Exception e) {
            return false;
        }
    }

    /**
     * Estimates a pair of cameras and reconstructed points.
     *
     * @param isInitialPairOfViews true if initial pair of views is being processed,
     *                             false otherwise.
     * @return true if cameras and points could be estimated, false if something
     * failed.
     */
    private boolean estimatePairOfCamerasAndPoints(final boolean isInitialPairOfViews) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.html#L244">244</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.html#L335">335</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a = new Matrix(singularityEnforced ? 8 : 12, BaseQuadric.N_PARAMS);
            }

            Matrix cameraMatrix;
            double p11;
            double p12;
            double p13;
            double p14;
            double p21;
            double p22;
            double p23;
            double p24;
            double p31;
            double p32;
            double p33;
            double p34;
            var eqCounter = 0;
            final var minReqEqs = getMinRequiredEquations();
            for (final var camera : cameras) {

                // normalize cameras to increase accuracy
                camera.normalize();

                cameraMatrix = camera.getInternalMatrix();

                p11 = cameraMatrix.getElementAt(0, 0);
                p21 = cameraMatrix.getElementAt(1, 0);
                p31 = cameraMatrix.getElementAt(2, 0);

                p12 = cameraMatrix.getElementAt(0, 1);
                p22 = cameraMatrix.getElementAt(1, 1);
                p32 = cameraMatrix.getElementAt(2, 1);

                p13 = cameraMatrix.getElementAt(0, 2);
                p23 = cameraMatrix.getElementAt(1, 2);
                p33 = cameraMatrix.getElementAt(2, 2);

                p14 = cameraMatrix.getElementAt(0, 3);
                p24 = cameraMatrix.getElementAt(1, 3);
                p34 = cameraMatrix.getElementAt(2, 3);

                // 1st row
                fill2ndRowAnd1stRowEquation(p11, p21, p12, p22, p13, p23, p14, p24, a, eqCounter);
                eqCounter++;

                // 2nd row
                fill3rdRowAnd1stRowEquation(p11, p31, p12, p32, p13, p33, p14, p34, a, eqCounter);
                eqCounter++;

                // 3rd row
                fill3rdRowAnd2ndRowEquation(p21, p31, p22, p32, p23, p33, p24, p34, a, eqCounter);
                eqCounter++;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamSparseReconstructor.html#L329">329</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.html#L251">251</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>activeEuclideanReconstructedPoints.add(euclideanPoint);
            }

            return true;
        } catch (final Exception e) {
            failed = true;
            //noinspection unchecked
            listener.onFail((R) this);

            return false;
        }
    }

    /**
     * Notifies SLAM state if notification is enabled at configuration time.
     */
    private void notifySlamStateIfNeeded() {
        if (!configuration.isNotifyAvailableSlamDataEnabled()) {
            return;
        }

        final var positionX = slamEstimator.getStatePositionX();
        final var positionY = slamEstimator.getStatePositionY();
        final var positionZ = slamEstimator.getStatePositionZ();

        final var velocityX = slamEstimator.getStateVelocityX();
        final var velocityY = slamEstimator.getStateVelocityY();
        final var velocityZ = slamEstimator.getStateVelocityZ();

        final var accelerationX = slamEstimator.getStateAccelerationX();
        final var accelerationY = slamEstimator.getStateAccelerationY();
        final var accelerationZ = slamEstimator.getStateAccelerationZ();

        final var quaternionA = slamEstimator.getStateQuaternionA();
        final var quaternionB = slamEstimator.getStateQuaternionB();
        final var quaternionC = slamEstimator.getStateQuaternionC();
        final var quaternionD = slamEstimator.getStateQuaternionD();

        final var angularSpeedX = slamEstimator.getStateAngularSpeedX();
        final var angularSpeedY = slamEstimator.getStateAngularSpeedY();
        final var angularSpeedZ = slamEstimator.getStateAngularSpeedZ();

        //noinspection unchecked
        listener.onSlamDataAvailable((R) this, positionX, positionY, positionZ,
                velocityX, velocityY, velocityZ,
                accelerationX, accelerationY, accelerationZ,
                quaternionA, quaternionB, quaternionC, quaternionD,
                angularSpeedX, angularSpeedY, angularSpeedZ, slamEstimator.getStateCovariance());
    }

    /**
     * Notifies estimated camera by means of SLAM if notification is enabled at
     * configuration time and intrinsics are already available.
     */
    private void notifySlamCameraIfNeeded() {
        if (!configuration.isNotifyEstimatedSlamCameraEnabled()) {
            return;
        }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.html#L575">575</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/SlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/SlamEstimator.html#L523">523</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>stateVelocityX = x[7];
        x[7] = state.getElementAtIndex(7);
        stateVelocityY = x[8];
        x[8] = state.getElementAtIndex(8);
        stateVelocityZ = x[9];
        x[9] = state.getElementAtIndex(9);

        // linear acceleration
        stateAccelerationX = x[10];
        x[10] = state.getElementAtIndex(10);
        stateAccelerationY = x[11];
        x[11] = state.getElementAtIndex(11);
        stateAccelerationZ = x[12];
        x[12] = state.getElementAtIndex(12);

        // angular velocity
        stateAngularSpeedX = x[13];
        x[13] = state.getElementAtIndex(13);
        stateAngularSpeedY = x[14];
        x[14] = state.getElementAtIndex(14);
        stateAngularSpeedZ = x[15];
        x[15] = state.getElementAtIndex(15);
    }

    /**
     * Updates state data of the device by using state matrix obtained from
     * Kalman filter after correction.
     *
     * @param state state matrix obtained from Kalman filter.
     */
    private void updateCorrectedState(final Matrix state) {
        // position
        statePositionX = x[0] = state.getElementAtIndex(0);
        statePositionY = x[1] = state.getElementAtIndex(1);
        statePositionZ = x[2] = state.getElementAtIndex(2);

        // quaternion
        stateQuaternionA = x[3] = state.getElementAtIndex(3);
        stateQuaternionB = x[4] = state.getElementAtIndex(4);
        stateQuaternionC = x[5] = state.getElementAtIndex(5);
        stateQuaternionD = x[6] = state.getElementAtIndex(6);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L178">178</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L421">421</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>PositionPredictor.predict(r, vx, vy, vz, dt, r, rr, rv, null);

            // update orientation
            Matrix qq = null;
            Matrix qw = null;
            if (jacobianX != null) {
                qq = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);
                qw = new Matrix(Quaternion.N_PARAMS, ANGULAR_SPEED_COMPONENTS);
            }
            q = QuaternionPredictor.predict(q, wx, wy, wz, dt, true, qq, qw);

            // apply control signals
            vx += uvx;
            vy += uvy;
            vz += uvz;

            wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = wx;
            result[11] = wy;
            result[12] = wz;

            // jacobians
            if (jacobianX != null) {
                // [Rr   0   Rv  0  ]
                // [0    Qq  0   Qw ]
                // [0    0   eye 0  ]
                // [0    0   0   eye]
                jacobianX.initialize(0.0);
                jacobianX.setSubmatrix(0, 0, 2, 2, rr);

                jacobianX.setSubmatrix(3, 3, 6, 6, qq);

                jacobianX.setSubmatrix(0, 7, 2, 9, rv);

                for (int i = 7; i &lt; STATE_COMPONENTS; i++) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L396">396</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L539">539</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);
                a.setElementAt(counter, 1, h21 * h22);
                a.setElementAt(counter, 2, h11 * h32 + h31 * h12);
                a.setElementAt(counter, 3, h21 * h32 + h31 * h22);
                a.setElementAt(counter, 4, h31 * h32);

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0)
                        + Math.pow(a.getElementAt(counter, 3), 2.0)
                        + Math.pow(a.getElementAt(counter, 4), 2.0));</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L301">301</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L438">438</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0));
                a.setElementAt(counter, 1, 2.0 * (h11 * h21 - h12 * h22));
                a.setElementAt(counter, 2, Math.pow(h21, 2.0) - Math.pow(h22, 2.0));
                a.setElementAt(counter, 3, 2.0 * (h11 * h31 - h12 * h32));
                a.setElementAt(counter, 4, 2.0 * (h21 * h31 - h22 * h32));
                a.setElementAt(counter, 5, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0)
                        + Math.pow(a.getElementAt(counter, 3), 2.0)
                        + Math.pow(a.getElementAt(counter, 4), 2.0)
                        + Math.pow(a.getElementAt(counter, 5), 2.0));</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/AffineFundamentalMatrixEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/AffineFundamentalMatrixEstimator.html#L307">307</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/EightPointsFundamentalMatrixEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/EightPointsFundamentalMatrixEstimator.html#L330">330</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>fundMatrix.setElementAt(2, 2, v.getElementAt(4, 4));

            if (normalizePoints &amp;&amp; leftNormalization != null) {
                // denormalize fundMatrix
                final var transposedRightTransformationMatrix = rightNormalization.asMatrix().transposeAndReturnNew();
                final var leftTransformationMatrix = leftNormalization.asMatrix();

                // compute fundMatrix = transposedRightTransformationMatrix *
                // fundMatrix * leftTransformationMatrix
                fundMatrix.multiply(leftTransformationMatrix);
                transposedRightTransformationMatrix.multiply(fundMatrix);
                fundMatrix = transposedRightTransformationMatrix;

                // normalize by Frobenius norm to increase accuracy after point
                // de-normalization
                final var norm = Utils.normF(fundMatrix);
                fundMatrix.multiplyByScalar(1.0 / norm);
            }

            // enforce rank 2
            decomposer.setInputMatrix(fundMatrix);

            decomposer.decompose();

            // if rank is not already correct, then we enforce it
            final var rank = decomposer.getRank();
            if (rank &gt; FundamentalMatrix.FUNDAMENTAL_MATRIX_RANK) {
                // rank needs to be reduced
                final var u = decomposer.getU();
                final var w = decomposer.getW();
                v = decomposer.getV();

                // transpose V
                v.transpose();
                final var transV = v;

                // set last singular value to zero to enforce rank 2
                w.setElementAt(2, 2, 0.0);

                // compute fundMatrix = U * W * V'
                w.multiply(transV);
                u.multiply(w);
                fundMatrix = u;
            } else if (rank &lt; FundamentalMatrix.FUNDAMENTAL_MATRIX_RANK) {
                // rank is 1, which is lower than required fundamental matrix
                // rank (rank 2)
                throw new FundamentalMatrixEstimatorException();
            }

            final var result = new FundamentalMatrix(fundMatrix);

            if (listener != null) {
                listener.onEstimateEnd(this, result);
            }

            return result;

        } catch (final InvalidFundamentalMatrixException | AlgebraException | NormalizerException e) {
            throw new FundamentalMatrixEstimatorException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method of non-robust fundamental matrix estimator.
     *
     * @return method of fundamental matrix estimator.
     */
    @Override
    public FundamentalMatrixEstimatorMethod getMethod() {
        return FundamentalMatrixEstimatorMethod.AFFINE_ALGORITHM;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L984">984</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L1162">1162</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

            if (jacobianU != null) {
                jacobianU.initialize(0.0);
                // variation of position
                for (var i = 0; i &lt; Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH; i++) {
                    jacobianU.setElementAt(i, i, 1.0);
                }

                // variation of rotation
                jacobianU.setSubmatrix(3, 3, 6, 6, qdq);

                // variation of linear and angular speed
                for (var i = 7; i &lt; STATE_WITH_POSITION_AND_ROTATION_ADJUSTMENT_COMPONENTS; i++) {
                    jacobianU.setElementAt(i, i, 1.0);
                }
            }

        } catch (final WrongSizeException ignore) {
            // never thrown
        }
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration) when no velocity control signal is present.
     *
     * @param x      initial system state containing: position-x, position-y,
     *               position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *               linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *               angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *               length 13.
     * @param u      linear and angular velocity perturbations or controls, position
     *               perturbations or controls and rotation perturbation or control:
     *               position-change-x, position-change-y, position-change-z,
     *               quaternion-change-a, quaternion-change-b, quaternion-change-c,
     *               quaternion-change-d, linear-velocity-change-x, linear-velocity-change-y,
     *               linear-velocity-change-z, angular-velocity-change-x,
     *               angular-velocity-change-y, angular-velocity-change-z. Must have length
     *               12.
     * @param dt     time interval to compute prediction expressed in seconds.
     * @param result instance where updated system model will be stored. Must
     *               have length 13.
     * @throws IllegalArgumentException if system state array, control array,
     *                                  result or jacobians do not have proper size.
     */
    public static void predictWithPositionAndRotationAdjustment(
            final double[] x, final double[] u, final double dt, final double[] result) {
        predictWithPositionAndRotationAdjustment(x, u, dt, result, null, null);
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration) when no velocity control signal is present.
     *
     * @param x         initial system state containing: position-x, position-y,
     *                  position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *                  linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *                  angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *                  length 13.
     * @param u         linear and angular velocity perturbations or controls, position
     *                  perturbations or controls and rotation perturbation or control:
     *                  position-change-x, position-change-y, position-change-z,
     *                  quaternion-change-a, quaternion-change-b, quaternion-change-c,
     *                  quaternion-change-d, linear-velocity-change-x, linear-velocity-change-y,
     *                  linear-velocity-change-z, angular-velocity-change-x,
     *                  angular-velocity-change-y, angular-velocity-change-z. Must have length
     *                  12.
     * @param dt        time interval to compute prediction expressed in seconds.
     * @param jacobianX jacobian wrt system state. Must be 13x13.
     * @param jacobianU jacobian wrt control. Must be 13x13.
     * @return a new array containing updated system model.
     * @throws IllegalArgumentException if system state array, control array
     *                                  or jacobians do not have proper size.
     */
    public static double[] predictWithPositionAndRotationAdjustment(
            final double[] x, final double[] u, final double dt, final Matrix jacobianX, final Matrix jacobianU) {
        final var result = new double[STATE_WITH_POSITION_AND_ROTATION_ADJUSTMENT_COMPONENTS];
        predictWithPositionAndRotationAdjustment(x, u, dt, result, jacobianX, jacobianU);
        return result;
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration) when no velocity control signal is present.
     *
     * @param x  initial system state containing: position-x, position-y,
     *           position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *           linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *           angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *           length 13.
     * @param u  linear and angular velocity perturbations or controls, position
     *           perturbations or controls and rotation perturbation or control:
     *           position-change-x, position-change-y, position-change-z,
     *           quaternion-change-a, quaternion-change-b, quaternion-change-c,
     *           quaternion-change-d, linear-velocity-change-x, linear-velocity-change-y,
     *           linear-velocity-change-z, angular-velocity-change-x,
     *           angular-velocity-change-y, angular-velocity-change-z. Must have length
     *           12.
     * @param dt time interval to compute prediction expressed in seconds.
     * @return a new array containing updated system model. Must have length 13.
     * @throws IllegalArgumentException if system state array, control array or
     *                                  result do not have proper size.
     */
    public static double[] predictWithPositionAndRotationAdjustment(
            final double[] x, final double[] u, final double dt) {
        final var result = new double[STATE_WITH_POSITION_AND_ROTATION_ADJUSTMENT_COMPONENTS];
        predictWithPositionAndRotationAdjustment(x, u, dt, result);
        return result;
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L676">676</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L419">419</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>protected abstract boolean hasAbsoluteOrientation();

    /**
     * Indicates whether there are enough samples to estimate a fundamental
     * matrix.
     *
     * @param samples samples to check.
     * @return true if there are enough samples, false otherwise.
     */
    private boolean hasEnoughSamples(final List&lt;Sample2D&gt; samples) {
        return hasEnoughSamplesOrMatches(samples != null ? samples.size() : 0);
    }

    /**
     * Indicates whether there are enough matches to estimate a fundamental
     * matrix.
     *
     * @param matches matches to check.
     * @return true if there are enough matches, false otherwise.
     */
    private boolean hasEnoughMatches(final List&lt;MatchedSamples&gt; matches) {
        return hasEnoughSamplesOrMatches(matches != null ? matches.size() : 0);
    }

    /**
     * Indicates whether there are enough matches or samples to estimate a
     * fundamental matrix.
     *
     * @param count number of matches or samples.
     * @return true if there are enough matches or samples, false otherwise.
     */
    private boolean hasEnoughSamplesOrMatches(final int count) {
        if (configuration.isGeneralSceneAllowed()) {
            if (configuration.getNonRobustFundamentalMatrixEstimatorMethod()
                    == FundamentalMatrixEstimatorMethod.EIGHT_POINTS_ALGORITHM) {
                return count &gt;= EightPointsFundamentalMatrixEstimator.MIN_REQUIRED_POINTS;
            } else if (configuration.getNonRobustFundamentalMatrixEstimatorMethod()
                    == FundamentalMatrixEstimatorMethod.SEVEN_POINTS_ALGORITHM) {
                return count &gt;= SevenPointsFundamentalMatrixEstimator.MIN_REQUIRED_POINTS;
            }
        } else if (configuration.isPlanarSceneAllowed()) {
            return count &gt;= ProjectiveTransformation2DRobustEstimator.MINIMUM_SIZE;
        }
        return false;
    }

    /**
     * Estimates fundamental matrix for provided matches, when 3D points lay in
     * a general non-degenerate 3D configuration.
     *
     * @param matches pairs of matches to find fundamental matrix.
     * @param viewId1 id of first view.
     * @param viewId2 id of second view.
     * @return true if estimation succeeded, false otherwise.
     */
    private boolean estimateFundamentalMatrix(final List&lt;MatchedSamples&gt; matches, final int viewId1,
                                              final int viewId2) {
        if (matches == null) {
            return false;
        }

        final var count = matches.size();
        final var leftSamples = new ArrayList&lt;Sample2D&gt;(count);
        final var rightSamples = new ArrayList&lt;Sample2D&gt;(count);
        final var leftPoints = new ArrayList&lt;Point2D&gt;(count);
        final var rightPoints = new ArrayList&lt;Point2D&gt;(count);
        final var qualityScores = new double[count];</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1168">1168</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1892">1892</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>corrector = Corrector.create(fundamentalMatrix, configuration.getPairedCamerasCorrectorType());
            }

            // use all points used for fundamental matrix estimation
            final var samples1 = currentEstimatedFundamentalMatrix.getLeftSamples();
            final var samples2 = currentEstimatedFundamentalMatrix.getRightSamples();

            final var points1 = new ArrayList&lt;Point2D&gt;();
            final var points2 = new ArrayList&lt;Point2D&gt;();
            final var length = samples1.size();
            for (var i = 0; i &lt; length; i++) {
                final var sample1 = samples1.get(i);
                final var sample2 = samples2.get(i);

                final var point1 = sample1.getPoint();
                final var point2 = sample2.getPoint();

                points1.add(point1);
                points2.add(point2);
            }

            // correct points if needed
            final List&lt;Point2D&gt; correctedPoints1;
            final List&lt;Point2D&gt; correctedPoints2;
            if (corrector != null) {
                corrector.setLeftAndRightPoints(points1, points2);
                corrector.correct();

                correctedPoints1 = corrector.getLeftCorrectedPoints();
                correctedPoints2 = corrector.getRightCorrectedPoints();
            } else {
                correctedPoints1 = points1;
                correctedPoints2 = points2;
            }

            // triangulate points
            final SinglePoint3DTriangulator triangulator;
            if (configuration.getDaqUseHomogeneousPointTriangulator()) {
                triangulator = SinglePoint3DTriangulator.create(Point3DTriangulatorType.LMSE_HOMOGENEOUS_TRIANGULATOR);
            } else {
                triangulator = SinglePoint3DTriangulator.create(
                        Point3DTriangulatorType.LMSE_INHOMOGENEOUS_TRIANGULATOR);
            }

            final var cameras = new ArrayList&lt;PinholeCamera&gt;();
            cameras.add(camera1);
            cameras.add(camera2);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L591">591</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L866">866</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 2, Math.pow(h21, 2.0) - Math.pow(h22, 2.0));
                a.setElementAt(counter, 3, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0)
                        + Math.pow(a.getElementAt(counter, 3), 2.0));

                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);
                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);
                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);
                a.setElementAt(counter, 3, a.getElementAt(counter, 3) / rowNorm);

                counter++;
            }

            final var decomposer = new SingularValueDecomposer(a);
            decomposer.decompose();

            if (decomposer.getNullity() &gt; 1) {
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
                throw new ImageOfAbsoluteConicEstimatorException();
            }

            final var v = decomposer.getV();

            // use last column of V as IAC vector

            // the last column of V contains IAC matrix (B), which is symmetric
            // and positive definite, ordered as follows: B11, B12, B22, B13,
            // B23, B33
            final var b11 = v.getElementAt(0, 3);
            final var b12 = v.getElementAt(1, 3);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L415">415</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L528">528</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var transRow = new Matrix(BaseQuadric.N_PARAMS, 4);
            final var tmp = new Matrix(BaseQuadric.N_PARAMS, BaseQuadric.N_PARAMS);

            Matrix cameraMatrix;
            double p11;
            double p12;
            double p13;
            double p14;
            double p21;
            double p22;
            double p23;
            double p24;
            double p31;
            double p32;
            double p33;
            double p34;
            int eqCounter;
            var cameraCounter = 0;
            double weight;
            var previousNorm = 1.0;
            for (final var camera : cameras) {
                if (selected[cameraCounter]) {
                    eqCounter = 0;

                    // normalize cameras to increase accuracy
                    camera.normalize();

                    cameraMatrix = camera.getInternalMatrix();

                    p11 = cameraMatrix.getElementAt(0, 0);
                    p21 = cameraMatrix.getElementAt(1, 0);
                    p31 = cameraMatrix.getElementAt(2, 0);

                    p12 = cameraMatrix.getElementAt(0, 1);
                    p22 = cameraMatrix.getElementAt(1, 1);
                    p32 = cameraMatrix.getElementAt(2, 1);

                    p13 = cameraMatrix.getElementAt(0, 2);
                    p23 = cameraMatrix.getElementAt(1, 2);
                    p33 = cameraMatrix.getElementAt(2, 2);

                    p14 = cameraMatrix.getElementAt(0, 3);
                    p24 = cameraMatrix.getElementAt(1, 3);
                    p34 = cameraMatrix.getElementAt(2, 3);

                    weight = weights[cameraCounter];

                    // 1st row
                    fill2ndRowAnd1stRowEquation(p11, p21, p12, p22, p13, p23, p14, p24, row, eqCounter);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.html#L496">496</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/SlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/SlamEstimator.html#L450">450</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>if (x != null) {
            // position
            x[0] = statePositionX;
            x[1] = statePositionY;
            x[2] = statePositionZ;

            // quaternion
            x[3] = stateQuaternionA;
            x[4] = stateQuaternionB;
            x[5] = stateQuaternionC;
            x[6] = stateQuaternionD;

            // velocity
            x[7] = stateVelocityX;
            x[8] = stateVelocityY;
            x[9] = stateVelocityZ;

            // linear acceleration
            x[10] = stateAccelerationX;
            x[11] = stateAccelerationY;
            x[12] = stateAccelerationZ;

            // angular speed
            x[13] = stateAngularSpeedX;
            x[14] = stateAngularSpeedY;
            x[15] = stateAngularSpeedZ;

            try {
                // set initial Kalman filter state (state pre and pro must be two
                // different instances!)
                kalmanFilter.getStatePre().fromArray(x);
                kalmanFilter.getStatePost().fromArray(x);
            } catch (final WrongSizeException ignore) {
                // never thrown
            }
        }

        error = false;
        lastTimestampNanos = -1;
        predictionAvailable = false;
    }

    /**
     * Updates state data of the device by using state matrix obtained after
     * prediction from Kalman filter.
     * to ensure that state follows proper values (specially on quaternions),
     * we keep x values, which have been predicted using the state predictor,
     * which uses analytical values.
     * We then updated x using latest Kalman filter state for next iteration
     * on state predictor.
     *
     * @param state state matrix obtained from Kalman filter.
     */
    private void updatePredictedState(final Matrix state) {
        // position
        statePositionX = x[0];
        x[0] = state.getElementAtIndex(0);
        statePositionY = x[1];
        x[1] = state.getElementAtIndex(1);
        statePositionZ = x[2];
        x[2] = state.getElementAtIndex(2);

        // quaternion state predictor is more reliable than Kalman filter, for
        // that reason we ignore predicted quaternion values on Kalman filter and
        // simply keep predicted ones. Besides, typically gyroscope samples are
        // much more reliable than accelerometer ones. For that reason state
        // elements corresponding to quaternion (3 to 6) are not copied into mX
        // array.
        stateQuaternionA = x[3];
        stateQuaternionB = x[4];
        stateQuaternionC = x[5];
        stateQuaternionD = x[6];</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L484">484</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L621">621</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var rightPoints = new ArrayList&lt;Point2D&gt;(count);
        final var qualityScores = new double[count];
        final double principalPointX;
        final double principalPointY;
        if (configuration.getInitialCamerasEstimatorMethod() == InitialCamerasEstimatorMethod.DUAL_ABSOLUTE_QUADRIC
                || configuration.getInitialCamerasEstimatorMethod()
                == InitialCamerasEstimatorMethod.DUAL_ABSOLUTE_QUADRIC_AND_ESSENTIAL_MATRIX) {
            principalPointX = configuration.getPrincipalPointX();
            principalPointY = configuration.getPrincipalPointY();
        } else {
            principalPointX = principalPointY = 0.0;
        }

        var i = 0;
        for (final var match : matches) {
            final var samples = match.getSamples();
            if (samples.length != NUMBER_OF_VIEWS) {
                return false;
            }

            leftSamples.add(samples[0]);
            rightSamples.add(samples[1]);

            final var leftPoint = Point2D.create();
            leftPoint.setInhomogeneousCoordinates(
                    samples[0].getPoint().getInhomX() - principalPointX,
                    samples[0].getPoint().getInhomY() - principalPointY);
            leftPoints.add(leftPoint);

            final var rightPoint = Point2D.create();
            rightPoint.setInhomogeneousCoordinates(
                    samples[1].getPoint().getInhomX() - principalPointX,
                    samples[1].getPoint().getInhomY() - principalPointY);
            rightPoints.add(rightPoint);

            qualityScores[i] = match.getQualityScore();
            i++;
        }

        try {
            final var estimator = FundamentalMatrixRobustEstimator.create(leftPoints, rightPoints, qualityScores,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L815">815</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L960">960</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12 + h21 * h22 / sqrAspectRatio);
                a.setElementAt(counter, 1, h11 * h32 + h31 * h12);
                a.setElementAt(counter, 2, h21 * h32 + h31 * h22);
                a.setElementAt(counter, 3, h31 * h32);

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0)
                        + Math.pow(a.getElementAt(counter, 3), 2.0));</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L813">813</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1519">1519</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final RANSACFundamentalMatrixRobustEstimator ransacEstimator =
                            (RANSACFundamentalMatrixRobustEstimator) estimator;
                    ransacEstimator.setThreshold(configuration.getFundamentalMatrixThreshold());
                    ransacEstimator.setComputeAndKeepInliersEnabled(
                            configuration.getFundamentalMatrixComputeAndKeepInliers());
                    ransacEstimator.setComputeAndKeepResidualsEnabled(
                            configuration.getFundamentalMatrixComputeAndKeepResiduals());
                    break;
                default:
                    break;
            }


            final var fundamentalMatrix = estimator.estimate();

            currentEstimatedFundamentalMatrix = new EstimatedFundamentalMatrix();
            currentEstimatedFundamentalMatrix.setFundamentalMatrix(fundamentalMatrix);
            currentEstimatedFundamentalMatrix.setViewId1(viewId1);
            currentEstimatedFundamentalMatrix.setViewId2(viewId2);
            currentEstimatedFundamentalMatrix.setCovariance(estimator.getCovariance());

            // determine quality score and inliers
            final var inliersData = estimator.getInliersData();
            if (inliersData != null) {
                final var numInliers = inliersData.getNumInliers();
                final var inliers = inliersData.getInliers();
                final var length = inliers.length();
                var fundamentalMatrixQualityScore = 0.0;
                for (i = 0; i &lt; length; i++) {
                    if (inliers.get(i)) {
                        // inlier
                        fundamentalMatrixQualityScore += qualityScores[i] / numInliers;
                    }
                }
                currentEstimatedFundamentalMatrix.setQualityScore(fundamentalMatrixQualityScore);
                currentEstimatedFundamentalMatrix.setInliers(inliers);
            }

            // store left/right samples
            currentEstimatedFundamentalMatrix.setLeftSamples(leftSamples);
            currentEstimatedFundamentalMatrix.setRightSamples(rightSamples);

            return true;
        } catch (final Exception e) {
            return false;
        }
    }

    /**
     * Estimates fundamental matrix for provided matches, when 3D points lay in
     * a planar 3D scene.
     *
     * @param matches pairs of matches to find fundamental matrix.
     * @param viewId1 id of first view.
     * @param viewId2 id of second view.
     * @return true if estimation succeeded, false otherwise.
     */
    private boolean estimatePlanarFundamentalMatrix(final List&lt;MatchedSamples&gt; matches, final int viewId1,
                                                    final int viewId2) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L275">275</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L306">306</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 5, h31 * h32);

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0)
                        + Math.pow(a.getElementAt(counter, 3), 2.0)
                        + Math.pow(a.getElementAt(counter, 4), 2.0)
                        + Math.pow(a.getElementAt(counter, 5), 2.0));

                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);
                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);
                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);
                a.setElementAt(counter, 3, a.getElementAt(counter, 3) / rowNorm);
                a.setElementAt(counter, 4, a.getElementAt(counter, 4) / rowNorm);
                a.setElementAt(counter, 5, a.getElementAt(counter, 5) / rowNorm);

                counter++;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/MSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/MSACRadialDistortionRobustEstimator.html#L228">228</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROMedSRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSRadialDistortionRobustEstimator.html#L429">429</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.html#L390">390</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

            @Override
            public int getTotalSamples() {
                return distortedPoints.size();
            }

            @Override
            public int getSubsetSize() {
                return RadialDistortionRobustEstimator.MIN_NUMBER_OF_POINTS;
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;RadialDistortion&gt; solutions) {
                subsetDistorted.clear();
                subsetDistorted.add(distortedPoints.get(samplesIndices[0]));
                subsetDistorted.add(distortedPoints.get(samplesIndices[1]));

                subsetUndistorted.clear();
                subsetUndistorted.add(undistortedPoints.get(samplesIndices[0]));
                subsetUndistorted.add(undistortedPoints.get(samplesIndices[1]));

                try {
                    radialDistortionEstimator.setPoints(distortedPoints, undistortedPoints);
                    radialDistortionEstimator.setPoints(subsetDistorted, subsetUndistorted);

                    final var distortion = radialDistortionEstimator.estimate();
                    solutions.add(distortion);
                } catch (final Exception e) {
                    // if anything fails, no solution is added
                }
            }

            @Override
            public double computeResidual(final RadialDistortion currentEstimation, final int i) {
                final var distortedPoint = distortedPoints.get(i);
                final var undistortedPoint = undistortedPoints.get(i);

                currentEstimation.distort(undistortedPoint, testPoint);

                return testPoint.distanceTo(distortedPoint);
            }

            @Override
            public boolean isReady() {
                return MSACRadialDistortionRobustEstimator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L541">541</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L685">685</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);
                a.setElementAt(counter, 1, h11 * h22 + h21 * h12);
                a.setElementAt(counter, 2, h21 * h22);
                a.setElementAt(counter, 3, h31 * h32);

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0)
                        + Math.pow(a.getElementAt(counter, 3), 2.0));</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMedSRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMedSRadialDistortionRobustEstimator.html#L266">266</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/MSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/MSACRadialDistortionRobustEstimator.html#L230">230</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROMedSRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSRadialDistortionRobustEstimator.html#L431">431</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.html#L392">392</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@Override
            public int getTotalSamples() {
                return distortedPoints.size();
            }

            @Override
            public int getSubsetSize() {
                return RadialDistortionRobustEstimator.MIN_NUMBER_OF_POINTS;
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;RadialDistortion&gt; solutions) {
                subsetDistorted.clear();
                subsetDistorted.add(distortedPoints.get(samplesIndices[0]));
                subsetDistorted.add(distortedPoints.get(samplesIndices[1]));

                subsetUndistorted.clear();
                subsetUndistorted.add(undistortedPoints.get(samplesIndices[0]));
                subsetUndistorted.add(undistortedPoints.get(samplesIndices[1]));

                try {
                    radialDistortionEstimator.setPoints(distortedPoints, undistortedPoints);
                    radialDistortionEstimator.setPoints(subsetDistorted, subsetUndistorted);

                    final var distortion = radialDistortionEstimator.estimate();
                    solutions.add(distortion);
                } catch (final Exception e) {
                    // if anything fails, no solution is added
                }
            }

            @Override
            public double computeResidual(final RadialDistortion currentEstimation, final int i) {
                final var distortedPoint = distortedPoints.get(i);
                final var undistortedPoint = undistortedPoints.get(i);

                currentEstimation.distort(undistortedPoint, testPoint);

                return testPoint.distanceTo(distortedPoint);
            }

            @Override
            public boolean isReady() {
                return LMedSRadialDistortionRobustEstimator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L91">91</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L95">95</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>private ConstantVelocityModelStatePredictor() {
    }

    /**
     * Updates the system model (position, orientation, linear velocity and
     * angular velocity) assuming a constant velocity model (without
     * acceleration) when no velocity control signal is present.
     *
     * @param x         initial system state containing: position-x, position-y,
     *                  position-z, quaternion-a, quaternion-b, quaternion-c, quaternion-d,
     *                  linear-velocity-x, linear-velocity-y, linear-velocity-z,
     *                  angular-velocity-x, angular-velocity-y, angular-velocity-z. Must have
     *                  length 13.
     * @param u         linear and angular velocity perturbations or controls:
     *                  linear-velocity-change-x, linear-velocity-change-y,
     *                  linear-velocity-change-z, angular-velocity-change-x,
     *                  angular-velocity-change-y, angular-velocity-change-z. Must have length 6.
     * @param dt        time interval to compute prediction expressed in seconds.
     * @param result    instance where updated system model will be stored. Must
     *                  have length 13.
     * @param jacobianX jacobian wrt system state. Must be 13x13.
     * @param jacobianU jacobian wrt control. Must be 13x6.
     * @throws IllegalArgumentException if system state array, control array,
     *                                  result or jacobians do not have proper size.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;constVel.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void predict(
            final double[] x, final double[] u, final double dt, final double[] result, final Matrix jacobianX,
            final Matrix jacobianU) {
        if (x.length != STATE_COMPONENTS) {
            // x must have length 13
            throw new IllegalArgumentException();
        }
        if (u.length != CONTROL_COMPONENTS) {
            // u must have length 6
            throw new IllegalArgumentException();
        }
        if (result.length != STATE_COMPONENTS) {
            // result must have length 13
            throw new IllegalArgumentException();
        }
        if (jacobianX != null &amp;&amp; (jacobianX.getRows() != STATE_COMPONENTS
                || jacobianX.getColumns() != STATE_COMPONENTS)) {
            // jacobian wrt x must be 13x13
            throw new IllegalArgumentException();
        }
        if (jacobianU != null &amp;&amp; (jacobianU.getRows() != STATE_COMPONENTS
                || jacobianU.getColumns() != CONTROL_COMPONENTS)) {
            // jacobian wrt u must be 13x6
            throw new IllegalArgumentException();
        }

        // position
        final var r = new InhomogeneousPoint3D(x[0], x[1], x[2]);

        // orientation
        var q = new Quaternion(x[3], x[4], x[5], x[6]);

        // linear velocity
        var vx = x[7];
        var vy = x[8];
        var vz = x[9];

        // angular velocity
        var wx = x[10];</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L730">730</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L1006">1006</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 2, Math.pow(h21, 2.0) - Math.pow(h22, 2.0));
                    a.setElementAt(counter, 3, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));

                    // normalize row
                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                            + Math.pow(a.getElementAt(counter, 1), 2.0)
                            + Math.pow(a.getElementAt(counter, 2), 2.0)
                            + Math.pow(a.getElementAt(counter, 3), 2.0));
                    factor = weight / rowNorm;

                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);
                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);
                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);
                    a.setElementAt(counter, 3, a.getElementAt(counter, 3) * factor);

                    counter++;
                }

                index++;
            }

            final var decomposer = new SingularValueDecomposer(a);
            decomposer.decompose();

            if (decomposer.getNullity() &gt; 1) {
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
                throw new ImageOfAbsoluteConicEstimatorException();
            }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L744">744</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L883">883</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>double principalPointY;
        if (configuration.getPairedCamerasEstimatorMethod() == InitialCamerasEstimatorMethod.DUAL_ABSOLUTE_QUADRIC
                || configuration.getPairedCamerasEstimatorMethod()
                == InitialCamerasEstimatorMethod.DUAL_ABSOLUTE_QUADRIC_AND_ESSENTIAL_MATRIX) {
            principalPointX = configuration.getPrincipalPointX();
            principalPointY = configuration.getPrincipalPointY();
        } else {
            principalPointX = principalPointY = 0.0;
        }

        var i = 0;
        for (final var match : matches) {
            final var samples = match.getSamples();
            if (samples.length != MIN_NUMBER_OF_VIEWS) {
                return false;
            }

            leftSamples.add(samples[0]);
            rightSamples.add(samples[1]);

            final var leftPoint = Point2D.create();
            leftPoint.setInhomogeneousCoordinates(
                    samples[0].getPoint().getInhomX() - principalPointX,
                    samples[0].getPoint().getInhomY() - principalPointY);
            leftPoints.add(leftPoint);

            final var rightPoint = Point2D.create();
            rightPoint.setInhomogeneousCoordinates(
                    samples[1].getPoint().getInhomX() - principalPointX,
                    samples[1].getPoint().getInhomY() - principalPointY);
            rightPoints.add(rightPoint);

            qualityScores[i] = match.getQualityScore();
            i++;
        }

        try {
            final var estimator = FundamentalMatrixRobustEstimator.create(leftPoints, rightPoints, qualityScores,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructorConfiguration.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructorConfiguration.html#L452">452</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructorConfiguration.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructorConfiguration.html#L879">879</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructorConfiguration.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructorConfiguration.html#L454">454</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>robustFundamentalMatrixEstimatorMethod = method;
        //noinspection all
        return (T) this;
    }

    /**
     * Indicates whether estimated fundamental matrix is refined among all found inliers.
     * This is only used when general scenes are allowed.
     *
     * @return true if fundamental matrix is refined, false otherwise.
     */
    public boolean isFundamentalMatrixRefined() {
        return refineFundamentalMatrix;
    }

    /**
     * Specifies whether estimated fundamental matrix is refined among all found inliers.
     * This is only used when general scenes are allowed.
     *
     * @param refineFundamentalMatrix true if fundamental matrix is refined, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixRefined(final boolean refineFundamentalMatrix) {
        this.refineFundamentalMatrix = refineFundamentalMatrix;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether covariance of estimated fundamental matrix is kept after the
     * estimation.
     * This is only used when general scenes are allowed.
     *
     * @return true if covariance is kept, false otherwise.
     */
    public boolean isFundamentalMatrixCovarianceKept() {
        return keepFundamentalMatrixCovariance;
    }

    /**
     * Specifies whether covariance of estimated fundamental matrix is kept after the
     * estimation.
     * This is only used when general scenes are allowed.
     *
     * @param keepFundamentalMatrixCovariance true if covariance is kept, false
     *                                        otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixCovarianceKept(final boolean keepFundamentalMatrixCovariance) {
        this.keepFundamentalMatrixCovariance = keepFundamentalMatrixCovariance;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets confidence of robustly estimated fundamental matrix.
     * This is only used when general scenes are allowed.
     *
     * @return confidence of robustly estimated fundamental matrix.
     */
    public double getFundamentalMatrixConfidence() {
        return fundamentalMatrixConfidence;
    }

    /**
     * Sets confidence of robustly estimated fundamental matrix.
     * This is only used when general scenes are allowed.
     *
     * @param fundamentalMatrixConfidence confidence of robustly estimated fundamental
     *                                    matrix.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixConfidence(final double fundamentalMatrixConfidence) {
        this.fundamentalMatrixConfidence = fundamentalMatrixConfidence;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets maximum number of iterations to robustly estimate fundamental matrix.
     * This is only used when general scenes are allowed.
     *
     * @return maximum number of iterations to robustly estimate fundamental matrix.
     */
    public int getFundamentalMatrixMaxIterations() {
        return fundamentalMatrixMaxIterations;
    }

    /**
     * Sets maximum number of iterations to robustly estimate fundamental matrix.
     * This is only used when general scenes are allowed.
     *
     * @param fundamentalMatrixMaxIterations maximum number of iterations to robustly
     *                                       estimate fundamental matrix.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixMaxIterations(final int fundamentalMatrixMaxIterations) {
        this.fundamentalMatrixMaxIterations = fundamentalMatrixMaxIterations;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets threshold to determine whether samples for robust fundamental matrix
     * estimation are inliers or not.
     * This is only used when general scenes are allowed.
     *
     * @return threshold to determine whether samples for robust fundamental matrix
     * estimation are inliers or not.
     */
    public double getFundamentalMatrixThreshold() {
        return fundamentalMatrixThreshold;
    }

    /**
     * Sets threshold to determine whether samples for robust fundamental matrix
     * estimation are inliers or not.
     * This is only used when general scenes are allowed.
     *
     * @param fundamentalMatrixThreshold threshold to determine whether samples for
     *                                   robust fundamental matrix estimation are inliers
     *                                   or not.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixThreshold(final double fundamentalMatrixThreshold) {
        this.fundamentalMatrixThreshold = fundamentalMatrixThreshold;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether inliers must be kept during robust fundamental matrix
     * estimation.
     * This is only used when general scenes are allowed.
     *
     * @return true if inliers must be kept during robust fundamental matrix estimation,
     * false otherwise.
     */
    public boolean getFundamentalMatrixComputeAndKeepInliers() {
        return fundamentalMatrixComputeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be kept during robust fundamental matrix
     * estimation.
     * This is only used when general scenes are allowed.
     *
     * @param fundamentalMatrixComputeAndKeepInliers true if inliers must be kept
     *                                               during robust fundamental matrix
     *                                               estimation, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixComputeAndKeepInliers(final boolean fundamentalMatrixComputeAndKeepInliers) {
        this.fundamentalMatrixComputeAndKeepInliers = fundamentalMatrixComputeAndKeepInliers;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Indicates whether residuals must be computed and kept during robust fundamental
     * matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @return true if residuals must be computed and kept, false otherwise.
     */
    public boolean getFundamentalMatrixComputeAndKeepResiduals() {
        return fundamentalMatrixComputeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept during robust fundamental
     * matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @param fundamentalMatrixComputeAndKeepResiduals true if residuals must be computed
     *                                                 and kept, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixComputeAndKeepResiduals(final boolean fundamentalMatrixComputeAndKeepResiduals) {
        this.fundamentalMatrixComputeAndKeepResiduals = fundamentalMatrixComputeAndKeepResiduals;
        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets method to use for paired cameras' estimation.
     *
     * @return method to use for paired cameras' estimation.
     */
    public InitialCamerasEstimatorMethod getPairedCamerasEstimatorMethod() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L415">415</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L636">636</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var transRow = new Matrix(BaseQuadric.N_PARAMS, 4);
            final var tmp = new Matrix(BaseQuadric.N_PARAMS, BaseQuadric.N_PARAMS);

            Matrix cameraMatrix;
            double p11;
            double p12;
            double p13;
            double p14;
            double p21;
            double p22;
            double p23;
            double p24;
            double p31;
            double p32;
            double p33;
            double p34;
            int eqCounter;
            var cameraCounter = 0;
            double weight;
            var previousNorm = 1.0;
            for (final var camera : cameras) {
                if (selected[cameraCounter]) {
                    eqCounter = 0;

                    // normalize cameras to increase accuracy
                    camera.normalize();

                    cameraMatrix = camera.getInternalMatrix();

                    p11 = cameraMatrix.getElementAt(0, 0);
                    p21 = cameraMatrix.getElementAt(1, 0);
                    p31 = cameraMatrix.getElementAt(2, 0);

                    p12 = cameraMatrix.getElementAt(0, 1);
                    p22 = cameraMatrix.getElementAt(1, 1);
                    p32 = cameraMatrix.getElementAt(2, 1);

                    p13 = cameraMatrix.getElementAt(0, 2);
                    p23 = cameraMatrix.getElementAt(1, 2);
                    p33 = cameraMatrix.getElementAt(2, 2);

                    p14 = cameraMatrix.getElementAt(0, 3);
                    p24 = cameraMatrix.getElementAt(1, 3);
                    p34 = cameraMatrix.getElementAt(2, 3);

                    weight = weights[cameraCounter];</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L368">368</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L664">664</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var a = new Matrix(2 * nHomographies, 6);

            var index = 0;
            var counter = 0;
            ProjectiveTransformation2D t = null;
            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            double weight;
            double factor;
            for (final var homography : homographies) {
                if (selected[index]) {
                    weight = weights[index];

                    // convert homography into projective so it can be normalized
                    homography.asMatrix(h);
                    if (t == null) {
                        t = new ProjectiveTransformation2D(h);
                    } else {
                        t.setT(h);
                    }

                    // normalize
                    t.normalize();

                    // obtain elements of projective transformation matrix
                    // there is no need to retrieve internal matrix h, as we already
                    // hold a reference
                    h11 = h.getElementAt(0, 0);
                    h12 = h.getElementAt(0, 1);

                    h21 = h.getElementAt(1, 0);
                    h22 = h.getElementAt(1, 1);

                    h31 = h.getElementAt(2, 0);
                    h32 = h.getElementAt(2, 1);

                    // fill first equation
                    a.setElementAt(counter, 0, h11 * h12);
                    a.setElementAt(counter, 1, h11 * h22 + h21 * h12);
                    a.setElementAt(counter, 2, h21 * h22);
                    a.setElementAt(counter, 3, h11 * h32 + h31 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.html#L544">544</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.html#L492">492</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>stateVelocityX = x[7];
        x[7] = state.getElementAtIndex(7);
        stateVelocityY = x[8];
        x[8] = state.getElementAtIndex(8);
        stateVelocityZ = x[9];
        x[9] = state.getElementAtIndex(9);

        // linear acceleration
        stateAccelerationX = accumulatedAccelerationSampleX;
        stateAccelerationY = accumulatedAccelerationSampleY;
        stateAccelerationZ = accumulatedAccelerationSampleZ;

        // angular velocity
        stateAngularSpeedX = x[10];
        x[10] = state.getElementAtIndex(10);
        stateAngularSpeedY = x[11];
        x[11] = state.getElementAtIndex(11);
        stateAngularSpeedZ = x[12];
        x[12] = state.getElementAtIndex(12);
    }

    /**
     * Updates state data of the device by using state matrix obtained from
     * Kalman filter after correction.
     *
     * @param state state matrix obtained from Kalman filter.
     */
    private void updateCorrectedState(final Matrix state) {
        // position
        statePositionX = x[0] = state.getElementAtIndex(0);
        statePositionY = x[1] = state.getElementAtIndex(1);
        statePositionZ = x[2] = state.getElementAtIndex(2);

        // quaternion
        stateQuaternionA = x[3] = state.getElementAtIndex(3);
        stateQuaternionB = x[4] = state.getElementAtIndex(4);
        stateQuaternionC = x[5] = state.getElementAtIndex(5);
        stateQuaternionD = x[6] = state.getElementAtIndex(6);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/DualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/DualAbsoluteQuadricRobustEstimator.html#L435">435</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/ImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/ImageOfAbsoluteConicRobustEstimator.html#L395">395</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public void setListener(final DualAbsoluteQuadricRobustEstimatorListener listener) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.listener = listener;
    }

    /**
     * Indicates whether listener has been provided and is available for
     * retrieval.
     *
     * @return true if available, false otherwise.
     */
    public boolean isListenerAvailable() {
        return listener != null;
    }

    /**
     * Indicates whether this instance is locked.
     *
     * @return true if this estimator is busy estimating the Dual Absolute
     * Quadric, false otherwise.
     */
    public boolean isLocked() {
        return locked;
    }

    /**
     * Returns amount of progress variation before notifying a progress change
     * during estimation.
     *
     * @return amount of progress variation before notifying a progress change
     * during estimation.
     */
    public float getProgressDelta() {
        return progressDelta;
    }

    /**
     * Sets amount of progress variation before notifying a progress change
     * during estimation.
     *
     * @param progressDelta amount of progress variation before notifying a
     *                      progress change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or
     *                                  greater than 1.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setProgressDelta(final float progressDelta) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (progressDelta &lt; MIN_PROGRESS_DELTA || progressDelta &gt; MAX_PROGRESS_DELTA) {
            throw new IllegalArgumentException();
        }
        this.progressDelta = progressDelta;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%). The amount of confidence indicates the
     * probability that the estimated result is correct. Usually this value will
     * be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence as a value between 0.0 and 1.0.
     */
    public double getConfidence() {
        return confidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which
     * is equivalent to 100%). The amount of confidence indicates the
     * probability that the estimated result is correct. Usually this value will
     * be close to 1.0, but not exactly 1.0.
     *
     * @param confidence confidence to be set as a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and
     *                                  1.0.
     * @throws LockedException          if this estimator is locked because an estimator
     *                                  is being computed.
     */
    public void setConfidence(final double confidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (confidence &lt; MIN_CONFIDENCE || confidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        this.confidence = confidence;
    }

    /**
     * Returns maximum allowed number of iterations. If maximum allowed number
     * of iterations is achieved without converging to a result when calling
     * estimate(), a RobustEstimatorException will be raised.
     *
     * @return maximum allowed number of iterations.
     */
    public int getMaxIterations() {
        return maxIterations;
    }

    /**
     * Sets maximum allowed number of iterations. When the maximum number of
     * iterations is exceeded, result will not be available, however an
     * approximate result will be available for retrieval.
     *
     * @param maxIterations maximum allowed number of iterations to be set.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setMaxIterations(final int maxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (maxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        this.maxIterations = maxIterations;
    }

    /**
     * Obtains the list of cameras used to estimate the Dual Absolute Quadric
     * (DAQ).
     *
     * @return list of cameras to estimate the DAQ.
     */
    public List&lt;PinholeCamera&gt; getCameras() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/DualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/DualAbsoluteQuadricRobustEstimator.html#L435">435</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/RadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/RadialDistortionRobustEstimator.html#L296">296</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/FundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/FundamentalMatrixRobustEstimator.html#L339">339</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>public void setListener(final DualAbsoluteQuadricRobustEstimatorListener listener) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.listener = listener;
    }

    /**
     * Indicates whether listener has been provided and is available for
     * retrieval.
     *
     * @return true if available, false otherwise.
     */
    public boolean isListenerAvailable() {
        return listener != null;
    }

    /**
     * Indicates whether this instance is locked.
     *
     * @return true if this estimator is busy estimating the Dual Absolute
     * Quadric, false otherwise.
     */
    public boolean isLocked() {
        return locked;
    }

    /**
     * Returns amount of progress variation before notifying a progress change
     * during estimation.
     *
     * @return amount of progress variation before notifying a progress change
     * during estimation.
     */
    public float getProgressDelta() {
        return progressDelta;
    }

    /**
     * Sets amount of progress variation before notifying a progress change
     * during estimation.
     *
     * @param progressDelta amount of progress variation before notifying a
     *                      progress change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or
     *                                  greater than 1.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setProgressDelta(final float progressDelta) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (progressDelta &lt; MIN_PROGRESS_DELTA || progressDelta &gt; MAX_PROGRESS_DELTA) {
            throw new IllegalArgumentException();
        }
        this.progressDelta = progressDelta;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%). The amount of confidence indicates the
     * probability that the estimated result is correct. Usually this value will
     * be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence as a value between 0.0 and 1.0.
     */
    public double getConfidence() {
        return confidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which
     * is equivalent to 100%). The amount of confidence indicates the
     * probability that the estimated result is correct. Usually this value will
     * be close to 1.0, but not exactly 1.0.
     *
     * @param confidence confidence to be set as a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and
     *                                  1.0.
     * @throws LockedException          if this estimator is locked because an estimator
     *                                  is being computed.
     */
    public void setConfidence(final double confidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (confidence &lt; MIN_CONFIDENCE || confidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        this.confidence = confidence;
    }

    /**
     * Returns maximum allowed number of iterations. If maximum allowed number
     * of iterations is achieved without converging to a result when calling
     * estimate(), a RobustEstimatorException will be raised.
     *
     * @return maximum allowed number of iterations.
     */
    public int getMaxIterations() {
        return maxIterations;
    }

    /**
     * Sets maximum allowed number of iterations. When the maximum number of
     * iterations is exceeded, result will not be available, however an
     * approximate result will be available for retrieval.
     *
     * @param maxIterations maximum allowed number of iterations to be set.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setMaxIterations(final int maxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (maxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        this.maxIterations = maxIterations;
    }

    /**
     * Obtains the list of cameras used to estimate the Dual Absolute Quadric
     * (DAQ).
     *
     * @return list of cameras to estimate the DAQ.
     */
    public List&lt;PinholeCamera&gt; getCameras() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructorConfiguration.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructorConfiguration.html#L37">37</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructorConfiguration.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructorConfiguration.html#L34">34</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public abstract class BaseSparseReconstructorConfiguration&lt;T extends BaseSparseReconstructorConfiguration&lt;T&gt;&gt;
        implements Serializable {

    /**
     * Default robust fundamental matrix estimator method.
     * This is only used when general scenes are allowed.
     */
    public static final RobustEstimatorMethod DEFAULT_ROBUST_FUNDAMENTAL_MATRIX_ESTIMATOR_METHOD =
            RobustEstimatorMethod.PROSAC;

    /**
     * Default non-robust fundamental matrix estimator method used internally within a robust estimator.
     * This is only used when general scenes are allowed.
     */
    public static final FundamentalMatrixEstimatorMethod DEFAULT_NON_ROBUST_FUNDAMENTAL_MATRIX_ESTIMATOR_METHOD =
            FundamentalMatrixEstimatorMethod.SEVEN_POINTS_ALGORITHM;

    /**
     * Indicates that estimated fundamental matrix is refined by default using all found inliers.
     * This is only used when general scenes are allowed.
     */
    public static final boolean DEFAULT_REFINE_FUNDAMENTAL_MATRIX = true;

    /**
     * Indicates that fundamental matrix covariance is kept by default after the estimation.
     * This is only used when general scenes are allowed.
     */
    public static final boolean DEFAULT_KEEP_FUNDAMENTAL_MATRIX_COVARIANCE = false;

    /**
     * Default confidence of robustly estimated fundamental matrix. By default, this is 99%.
     * This is only used when general scenes are allowed.
     */
    public static final double DEFAULT_FUNDAMENTAL_MATRIX_CONFIDENCE =
            FundamentalMatrixRobustEstimator.DEFAULT_CONFIDENCE;

    /**
     * Default maximum number of iterations to make while robustly estimating fundamental matrix.
     * By default, this is 5000 iterations. This is only used when general scenes are allowed.
     */
    public static final int DEFAULT_FUNDAMENTAL_MATRIX_MAX_ITERATIONS =
            FundamentalMatrixRobustEstimator.DEFAULT_MAX_ITERATIONS;

    /**
     * Default threshold to determine whether samples for robust fundamental matrix estimation are
     * inliers or not.
     * This is only used when general scenes are allowed.
     */
    public static final double DEFAULT_FUNDAMENTAL_MATRIX_THRESHOLD =
            PROSACFundamentalMatrixRobustEstimator.DEFAULT_THRESHOLD;

    /**
     * Default value indicating that inlier data is kept after robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     */
    public static final boolean DEFAULT_FUNDAMENTAL_MATRIX_COMPUTE_AND_KEEP_INLIERS = true;

    /**
     * Default value indicating that residual data is kept after robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     */
    public static final boolean DEFAULT_FUNDAMENTAL_MATRIX_COMPUTE_AND_KEEP_RESIDUALS = true;

    /**
     * Default method to use for initial cameras' estimation.
     */
    public static final InitialCamerasEstimatorMethod DEFAULT_INITIAL_CAMERAS_ESTIMATOR_METHOD =
            InitialCamerasEstimatorMethod.DUAL_ABSOLUTE_QUADRIC_AND_ESSENTIAL_MATRIX;

    /**
     * Indicates whether an homogeneous point triangulator is used for point triangulation when Dual
     * Absolute Quadric (DAQ) camera initialization is used.
     */
    public static final boolean DEFAULT_DAQ_USE_HOMOGENEOUS_POINT_TRIANGULATOR = true;

    /**
     * Default aspect ratio for initial cameras.
     */
    public static final double DEFAULT_INITIAL_CAMERAS_ASPECT_RATIO = 1.0;

    /**
     * Default horizontal principal point value to use for initial cameras estimation using
     * Dual Image of Absolute Conic (DIAC) or Dual Absolute Quadric (DAQ) methods.
     */
    public static final double DEFAULT_INITIAL_CAMERAS_PRINCIPAL_POINT_X = 0.0;

    /**
     * Default vertical principal point value to use for initial cameras estimation using
     * Dual Image of Absolute Conic (DIAC) or Dual Absolute Quadric (DAQ) methods.
     */
    public static final double DEFAULT_INITIAL_CAMERAS_PRINCIPAL_POINT_Y = 0.0;

    /**
     * Default corrector type to use for point triangulation when initial cameras are
     * being estimated using either Dual Image of Absolute Conic (DIAC), Dual Absolute Quadric
     * (DAQ) or essential matrix methods.
     */
    public static final CorrectorType DEFAULT_INITIAL_CAMERAS_CORRECTOR_TYPE = CorrectorType.SAMPSON_CORRECTOR;

    /**
     * Default value indicating whether valid triangulated points are marked during initial
     * cameras estimation using either Dual Image of Absolute Conic (DIAC) or essential matrix
     * methods.
     */
    public static final boolean DEFAULT_INITIAL_CAMERAS_MARK_VALID_TRIANGULATED_POINTS = true;

    /**
     * Indicates whether a general (points are laying in a general 3D position) scene is
     * allowed.
     * When true, an initial geometry estimation is attempted for general points.
     */
    public static final boolean DEFAULT_ALLOW_GENERAL_SCENE = true;

    /**
     * Indicates whether a planar (points laying in a 3D plane) scene is allowed.
     * When true, an initial geometry estimation is attempted for planar points.
     */
    public static final boolean DEFAULT_ALLOW_PLANAR_SCENE = true;

    /**
     * Default robust planar homography estimator method.
     * This is only used when planar scenes are allowed.
     */
    public static final RobustEstimatorMethod DEFAULT_ROBUST_PLANAR_HOMOGRAPHY_ESTIMATOR_METHOD =
            RobustEstimatorMethod.PROMEDS;

    /**
     * Indicates that planar homography is refined by default using all found inliers.
     * This is only used when planar scenes are allowed.
     */
    public static final boolean DEFAULT_REFINE_PLANAR_HOMOGRAPHY = true;

    /**
     * Indicates that planar homography covariance is kept by default after estimation.
     * This is only used when planar scenes are allowed.
     */
    public static final boolean DEFAULT_KEEP_PLANAR_HOMOGRAPHY_COVARIANCE = false;

    /**
     * Default confidence of robustly estimated planar homography. By default, this is 99%.
     * This is only used when planar scenes are allowed.
     */
    public static final double DEFAULT_PLANAR_HOMOGRAPHY_CONFIDENCE =
            ProjectiveTransformation2DRobustEstimator.DEFAULT_CONFIDENCE;

    /**
     * Default maximum number of iterations to make while robustly estimating planar
     * homography. By default, this is 5000 iterations.
     * This is only used when planar scenes are allowed.
     */
    public static final int DEFAULT_PLANAR_HOMOGRAPHY_MAX_ITERATIONS =
            ProjectiveTransformation2DRobustEstimator.DEFAULT_MAX_ITERATIONS;

    /**
     * Default threshold to determine whether samples for robust projective 2D transformation
     * estimation are inliers or not.
     * This is only used when planar scenes are allowed.
     */
    public static final double DEFAULT_PLANAR_HOMOGRAPHY_THRESHOLD = 1e-3;

    /**
     * Default value indicating that inlier data is kept after robust planar homography estimation.
     * This is only used when planar scenes are allowed.
     */
    public static final boolean DEFAULT_PLANAR_HOMOGRAPHY_COMPUTE_AND_KEEP_INLIERS = true;

    /**
     * Default value indicating that residual data is kept after robust planar homography
     * estimation.
     * This is only used when planar scenes are allowed.
     */
    public static final boolean DEFAULT_PLANAR_HOMOGRAPHY_COMPUTE_AND_KEEP_RESIDUALS = true;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/MSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/MSACRobustSinglePoint3DTriangulator.html#L195">195</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.html#L350">350</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.html#L312">312</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/RANSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/RANSACRobustSinglePoint3DTriangulator.html#L195">195</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

            @Override
            public int getTotalSamples() {
                return points2D.size();
            }

            @Override
            public int getSubsetSize() {
                return MIN_REQUIRED_VIEWS;
            }

            @Override
            public void estimatePreliminarSolutions(final int[] samplesIndices, final List&lt;Point3D&gt; solutions) {
                subsetPoints.clear();
                subsetPoints.add(points2D.get(samplesIndices[0]));
                subsetPoints.add(points2D.get(samplesIndices[1]));

                subsetCameras.clear();
                subsetCameras.add(cameras.get(samplesIndices[0]));
                subsetCameras.add(cameras.get(samplesIndices[1]));

                try {
                    triangulator.setPointsAndCameras(subsetPoints, subsetCameras);
                    final var triangulated = triangulator.triangulate();
                    solutions.add(triangulated);
                } catch (final Exception e) {
                    // if anything fails, no solution is added
                }
            }

            @Override
            public double computeResidual(final Point3D currentEstimation, final int i) {
                final var point2D = points2D.get(i);
                final var camera = cameras.get(i);

                // project estimated point with camera
                camera.project(currentEstimation, testPoint);

                // return distance of projected point respect to the original one
                // as a residual
                return testPoint.distanceTo(point2D);
            }

            @Override
            public boolean isReady() {
                return MSACRobustSinglePoint3DTriangulator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L436">436</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L580">580</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 4, a.getElementAt(counter, 4) / rowNorm);

                counter++;

                // fill second equation
                a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0));
                a.setElementAt(counter, 1, Math.pow(h21, 2.0) - Math.pow(h22, 2.0));
                a.setElementAt(counter, 2, 2.0 * (h11 * h31 - h12 * h32));
                a.setElementAt(counter, 3, 2.0 * (h21 * h31 - h22 * h32));
                a.setElementAt(counter, 4, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0)
                        + Math.pow(a.getElementAt(counter, 3), 2.0)
                        + Math.pow(a.getElementAt(counter, 4), 2.0));</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/LMedSRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/LMedSRobustSinglePoint3DTriangulator.html#L231">231</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/MSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/MSACRobustSinglePoint3DTriangulator.html#L197">197</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.html#L352">352</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.html#L314">314</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/RANSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/RANSACRobustSinglePoint3DTriangulator.html#L197">197</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>@Override
            public int getTotalSamples() {
                return points2D.size();
            }

            @Override
            public int getSubsetSize() {
                return MIN_REQUIRED_VIEWS;
            }

            @Override
            public void estimatePreliminarSolutions(final int[] samplesIndices, final List&lt;Point3D&gt; solutions) {
                subsetPoints.clear();
                subsetPoints.add(points2D.get(samplesIndices[0]));
                subsetPoints.add(points2D.get(samplesIndices[1]));

                subsetCameras.clear();
                subsetCameras.add(cameras.get(samplesIndices[0]));
                subsetCameras.add(cameras.get(samplesIndices[1]));

                try {
                    triangulator.setPointsAndCameras(subsetPoints, subsetCameras);
                    final var triangulated = triangulator.triangulate();
                    solutions.add(triangulated);
                } catch (final Exception e) {
                    // if anything fails, no solution is added
                }
            }

            @Override
            public double computeResidual(final Point3D currentEstimation, final int i) {
                final var point2D = points2D.get(i);
                final var camera = cameras.get(i);

                // project estimated point with camera
                camera.project(currentEstimation, testPoint);

                // return distance of projected point respect to the original one
                // as a residual
                return testPoint.distanceTo(point2D);
            }

            @Override
            public boolean isReady() {
                return LMedSRobustSinglePoint3DTriangulator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L938">938</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L1083">1083</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var a = new Matrix(2 * nHomographies, 4);
            final var sqrAspectRatio = Math.pow(focalDistanceAspectRatio, 2.0);

            var index = 0;
            var counter = 0;
            ProjectiveTransformation2D t = null;
            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            double weight;
            double factor;
            for (final var homography : homographies) {
                if (selected[index]) {
                    weight = weights[index];

                    // convert homography into projective so it can be normalized
                    homography.asMatrix(h);
                    if (t == null) {
                        t = new ProjectiveTransformation2D(h);
                    } else {
                        t.setT(h);
                    }

                    // normalize
                    t.normalize();

                    // obtain elements of projective transformation matrix
                    // there is no need to retrieve internal matrix h, as we already
                    // hold a reference
                    h11 = h.getElementAt(0, 0);
                    h12 = h.getElementAt(0, 1);

                    h21 = h.getElementAt(1, 0);
                    h22 = h.getElementAt(1, 1);

                    h31 = h.getElementAt(2, 0);
                    h32 = h.getElementAt(2, 1);

                    // fill first equation
                    a.setElementAt(counter, 0, h11 * h12 + h21 * h22 / sqrAspectRatio);
                    a.setElementAt(counter, 1, h11 * h32 + h31 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSERadialDistortionEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSERadialDistortionEstimator.html#L282">282</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedRadialDistortionEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedRadialDistortionEstimator.html#L416">416</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>uDenormHomX = undistorted.getHomX();
                uDenormHomY = undistorted.getHomY();
                uDenormHomW = undistorted.getHomW();

                uDenormInhomX = uDenormHomX / uDenormHomW;
                uDenormInhomY = uDenormHomY / uDenormHomW;

                // multiply intrinsic parameters by undistorted point
                uNormHomX = kInv.getElementAt(0, 0) * uDenormHomX
                        + kInv.getElementAt(0, 1) * uDenormHomY
                        + kInv.getElementAt(0, 2) * uDenormHomW;
                uNormHomY = kInv.getElementAt(1, 0) * uDenormHomX
                        + kInv.getElementAt(1, 1) * uDenormHomY
                        + kInv.getElementAt(1, 2) * uDenormHomW;
                uNormHomW = kInv.getElementAt(2, 0) * uDenormHomX
                        + kInv.getElementAt(2, 1) * uDenormHomY
                        + kInv.getElementAt(2, 2) * uDenormHomW;

                uNormInhomX = uNormHomX / uNormHomW;
                uNormInhomY = uNormHomY / uNormHomW;

                r2 = uNormInhomX * uNormInhomX + uNormInhomY * uNormInhomY;

                dInhomX = distorted.getInhomX();
                dInhomY = distorted.getInhomY();

                a = 1.0;
                rowNormX = rowNormY = 0.0;
                for (var i = 0; i &lt; numKParams; i++) {
                    a *= r2;

                    // x and y coordinates generate linear dependent equations, for
                    // that reason we need more than one point

                    // x coordinates
                    value = (uDenormInhomX - centerX) * a;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.html#L371">371</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/SlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/SlamEstimator.html#L398">398</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>lastAngularSpeedZ = stateAngularSpeedZ;
        lastTimestampNanos = timestamp;

        if (listener != null) {
            listener.onFullSampleProcessed(this);
        }
    }

    /**
     * Resets position, linear velocity, linear acceleration, orientation and
     * angular speed to provided values.
     * This method implementation also resets Kalman filter state.
     *
     * @param statePositionX     position along x-axis expressed in meters (m).
     * @param statePositionY     position along y-axis expressed in meters (m).
     * @param statePositionZ     position along z-axis expressed in meters (m).
     * @param stateVelocityX     linear velocity along x-axis expressed in meters
     *                           per second (m/s).
     * @param stateVelocityY     linear velocity along y-axis expressed in meters
     *                           per second (m/s).
     * @param stateVelocityZ     linear velocity along z-axis expressed in meters
     *                           per second (m/s).
     * @param stateAccelerationX linear acceleration along x-axis expressed in
     *                           meters per squared second (m/s^2).
     * @param stateAccelerationY linear acceleration along y-axis expressed in
     *                           meters per squared second (m/s^2).
     * @param stateAccelerationZ linear acceleration along z-axis expressed in
     *                           meters per squared second (m/s^2).
     * @param stateQuaternionA   A value of orientation quaternion.
     * @param stateQuaternionB   B value of orientation quaternion.
     * @param stateQuaternionC   C value of orientation quaternion.
     * @param stateQuaternionD   D value of orientation quaternion.
     * @param stateAngularSpeedX angular speed along x-axis expressed in radians
     *                           per second (rad/s).
     * @param stateAngularSpeedY angular speed along y-axis expressed in radians
     *                           per second (rad/s).
     * @param stateAngularSpeedZ angular speed along z-axis expressed in radians
     *                           per second (rad/s).
     */
    @Override
    protected void reset(
            final double statePositionX, final double statePositionY, final double statePositionZ,
            final double stateVelocityX, final double stateVelocityY, final double stateVelocityZ,
            final double stateAccelerationX, final double stateAccelerationY,
            final double stateAccelerationZ, final double stateQuaternionA, final double stateQuaternionB,
            final double stateQuaternionC, final double stateQuaternionD,
            final double stateAngularSpeedX, final double stateAngularSpeedY,
            final double stateAngularSpeedZ) {
        super.reset(statePositionX, statePositionY, statePositionZ,
                stateVelocityX, stateVelocityY, stateVelocityZ,
                stateAccelerationX, stateAccelerationY, stateAccelerationZ,
                stateQuaternionA, stateQuaternionB, stateQuaternionC, stateQuaternionD,
                stateAngularSpeedX, stateAngularSpeedY, stateAngularSpeedZ);
        if (x != null) {
            // position
            x[0] = statePositionX;
            x[1] = statePositionY;
            x[2] = statePositionZ;

            // quaternion
            x[3] = stateQuaternionA;
            x[4] = stateQuaternionB;
            x[5] = stateQuaternionC;
            x[6] = stateQuaternionD;

            // velocity
            x[7] = stateVelocityX;
            x[8] = stateVelocityY;
            x[9] = stateVelocityZ;

            // angular speed
            x[10] = stateAngularSpeedX;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/MSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/MSACFundamentalMatrixRobustEstimator.html#L221">221</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.html#L502">502</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var innerEstimator = new MSACRobustEstimator&lt;FundamentalMatrix&gt;(new MSACRobustEstimatorListener&lt;&gt;() {

            // subset of left points
            private final List&lt;Point2D&gt; subsetLeftPoints = new ArrayList&lt;&gt;();

            // subset of right points
            private final List&lt;Point2D&gt; subsetRightPoints = new ArrayList&lt;&gt;();

            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return leftPoints.size();
            }

            @Override
            public int getSubsetSize() {
                return getMinRequiredPoints();
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;FundamentalMatrix&gt; solutions) {

                subsetLeftPoints.clear();
                subsetRightPoints.clear();
                for (final var samplesIndex : samplesIndices) {
                    subsetLeftPoints.add(leftPoints.get(samplesIndex));
                    subsetRightPoints.add(rightPoints.get(samplesIndex));
                }

                nonRobustEstimate(solutions, subsetLeftPoints, subsetRightPoints);
            }

            @Override
            public double computeResidual(final FundamentalMatrix currentEstimation, final int i) {
                final var leftPoint = leftPoints.get(i);
                final var rightPoint = rightPoints.get(i);
                return residual(currentEstimation, leftPoint, rightPoint);
            }

            @Override
            public boolean isReady() {
                return MSACFundamentalMatrixRobustEstimator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L710">710</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L985">985</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 2, h21 * h22);
                    a.setElementAt(counter, 3, h31 * h32);

                    // normalize row
                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                            + Math.pow(a.getElementAt(counter, 1), 2.0)
                            + Math.pow(a.getElementAt(counter, 2), 2.0)
                            + Math.pow(a.getElementAt(counter, 3), 2.0));
                    factor = weight / rowNorm;

                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);
                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);
                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);
                    a.setElementAt(counter, 3, a.getElementAt(counter, 3) * factor);

                    counter++;

                    // fill second equation
                    a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0));</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L755">755</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L951">951</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>(RANSACEPnPPointCorrespondencePinholeCameraRobustEstimator) cameraEstimator;
                                ransacCameraEstimator.setThreshold(configuration.getAdditionalCamerasThreshold());
                                ransacCameraEstimator.setComputeAndKeepInliersEnabled(
                                        configuration.getAdditionalCamerasComputeAndKeepInliers());
                                ransacCameraEstimator.setComputeAndKeepResidualsEnabled(
                                        configuration.getAdditionalCamerasComputeAndKeepResiduals());
                                break;
                            default:
                                break;
                        }

                        cameraEstimator.setSuggestSkewnessValueEnabled(
                                configuration.isAdditionalCamerasSuggestSkewnessValueEnabled());
                        cameraEstimator.setSuggestedSkewnessValue(
                                configuration.getAdditionalCamerasSuggestedSkewnessValue());

                        cameraEstimator.setSuggestHorizontalFocalLengthEnabled(
                                configuration.isAdditionalCamerasSuggestHorizontalFocalLengthEnabled());
                        cameraEstimator.setSuggestedHorizontalFocalLengthValue(
                                configuration.getAdditionalCamerasSuggestedHorizontalFocalLengthValue());

                        cameraEstimator.setSuggestVerticalFocalLengthEnabled(
                                configuration.isAdditionalCamerasSuggestVerticalFocalLengthEnabled());
                        cameraEstimator.setSuggestedVerticalFocalLengthValue(
                                configuration.getAdditionalCamerasSuggestedVerticalFocalLengthValue());

                        cameraEstimator.setSuggestAspectRatioEnabled(
                                configuration.isAdditionalCamerasSuggestAspectRatioEnabled());
                        cameraEstimator.setSuggestedAspectRatioValue(
                                configuration.getAdditionalCamerasSuggestedAspectRatioValue());

                        cameraEstimator.setSuggestPrincipalPointEnabled(
                                configuration.isAdditionalCamerasSuggestPrincipalPointEnabled());
                        cameraEstimator.setSuggestedPrincipalPointValue(
                                configuration.getAdditionalCamerasSuggestedPrincipalPointValue());

                        currentCamera = cameraEstimator.estimate();
                        currentCameraCovariance = cameraEstimator.getCovariance();

                        //noinspection unchecked
                        listener.onSamplesAccepted((R) this, viewCount, previousViewTrackedSamples,
                                currentViewTrackedSamples);

                        allPreviousViewSamples.clear();
                        allPreviousViewSamples.addAll(currentViewTrackedSamples);
                        allPreviousViewSamples.addAll(currentViewNewlySpawnedSamples);

                        previousViewTrackedSamples = currentViewTrackedSamples;
                        previousViewId = currentViewId;
                        currentViewId = viewCount;
                    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1642">1642</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L653">653</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>p2.getInhomY() - principalPointY);
            rightPoints.add(rightPoint);

            qualityScores[i] = match.getQualityScore();
            i++;
        }

        try {
            final var homographyEstimator = PointCorrespondenceProjectiveTransformation2DRobustEstimator.create(
                    configuration.getRobustPlanarHomographyEstimatorMethod());
            homographyEstimator.setResultRefined(configuration.isPlanarHomographyRefined());
            homographyEstimator.setCovarianceKept(configuration.isPlanarHomographyCovarianceKept());
            homographyEstimator.setConfidence(configuration.getPlanarHomographyConfidence());
            homographyEstimator.setMaxIterations(configuration.getPlanarHomographyMaxIterations());

            switch (configuration.getRobustPlanarHomographyEstimatorMethod()) {
                case LMEDS:
                    ((LMedSPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator)
                            .setStopThreshold(configuration.getPlanarHomographyThreshold());
                    break;
                case MSAC:
                    ((MSACPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator)
                            .setThreshold(configuration.getPlanarHomographyThreshold());
                    break;
                case PROMEDS:
                    ((PROMedSPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator)
                            .setStopThreshold(configuration.getPlanarHomographyThreshold());
                    break;
                case PROSAC:
                    final var prosacHomographyEstimator =
                            (PROSACPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator;

                    prosacHomographyEstimator.setThreshold(configuration.getPlanarHomographyThreshold());
                    prosacHomographyEstimator.setComputeAndKeepInliersEnabled(
                            configuration.getPlanarHomographyComputeAndKeepInliers());
                    prosacHomographyEstimator.setComputeAndKeepResidualsEnabled(
                            configuration.getPlanarHomographyComputeAndKeepResiduals());
                    break;
                case RANSAC:</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L231">231</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L525">525</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a = new Matrix(MIN_REQUIRED_EQUATIONS, 6);
            }

            var counter = 0;
            ProjectiveTransformation2D t = null;
            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            for (final var homography : homographies) {
                // convert homography into projective so it can be normalized
                homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);
                a.setElementAt(counter, 1, h11 * h22 + h21 * h12);
                a.setElementAt(counter, 2, h21 * h22);
                a.setElementAt(counter, 3, h11 * h32 + h31 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMedSRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMedSRadialDistortionRobustEstimator.html#L273">273</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/RANSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/RANSACRadialDistortionRobustEstimator.html#L238">238</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>return RadialDistortionRobustEstimator.MIN_NUMBER_OF_POINTS;
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;RadialDistortion&gt; solutions) {
                subsetDistorted.clear();
                subsetDistorted.add(distortedPoints.get(samplesIndices[0]));
                subsetDistorted.add(distortedPoints.get(samplesIndices[1]));

                subsetUndistorted.clear();
                subsetUndistorted.add(undistortedPoints.get(samplesIndices[0]));
                subsetUndistorted.add(undistortedPoints.get(samplesIndices[1]));

                try {
                    radialDistortionEstimator.setPoints(distortedPoints, undistortedPoints);
                    radialDistortionEstimator.setPoints(subsetDistorted, subsetUndistorted);

                    final var distortion = radialDistortionEstimator.estimate();
                    solutions.add(distortion);
                } catch (final Exception e) {
                    // if anything fails, no solution is added
                }
            }

            @Override
            public double computeResidual(final RadialDistortion currentEstimation, final int i) {
                final var distortedPoint = distortedPoints.get(i);
                final var undistortedPoint = undistortedPoints.get(i);

                currentEstimation.distort(undistortedPoint, testPoint);

                return testPoint.distanceTo(distortedPoint);
            }

            @Override
            public boolean isReady() {
                return LMedSRadialDistortionRobustEstimator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/MSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/MSACRadialDistortionRobustEstimator.html#L237">237</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/RANSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/RANSACRadialDistortionRobustEstimator.html#L238">238</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>return RadialDistortionRobustEstimator.MIN_NUMBER_OF_POINTS;
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;RadialDistortion&gt; solutions) {
                subsetDistorted.clear();
                subsetDistorted.add(distortedPoints.get(samplesIndices[0]));
                subsetDistorted.add(distortedPoints.get(samplesIndices[1]));

                subsetUndistorted.clear();
                subsetUndistorted.add(undistortedPoints.get(samplesIndices[0]));
                subsetUndistorted.add(undistortedPoints.get(samplesIndices[1]));

                try {
                    radialDistortionEstimator.setPoints(distortedPoints, undistortedPoints);
                    radialDistortionEstimator.setPoints(subsetDistorted, subsetUndistorted);

                    final var distortion = radialDistortionEstimator.estimate();
                    solutions.add(distortion);
                } catch (final Exception e) {
                    // if anything fails, no solution is added
                }
            }

            @Override
            public double computeResidual(final RadialDistortion currentEstimation, final int i) {
                final var distortedPoint = distortedPoints.get(i);
                final var undistortedPoint = undistortedPoints.get(i);

                currentEstimation.distort(undistortedPoint, testPoint);

                return testPoint.distanceTo(distortedPoint);
            }

            @Override
            public boolean isReady() {
                return MSACRadialDistortionRobustEstimator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROMedSRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSRadialDistortionRobustEstimator.html#L438">438</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/RANSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/RANSACRadialDistortionRobustEstimator.html#L238">238</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>return RadialDistortionRobustEstimator.MIN_NUMBER_OF_POINTS;
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;RadialDistortion&gt; solutions) {
                subsetDistorted.clear();
                subsetDistorted.add(distortedPoints.get(samplesIndices[0]));
                subsetDistorted.add(distortedPoints.get(samplesIndices[1]));

                subsetUndistorted.clear();
                subsetUndistorted.add(undistortedPoints.get(samplesIndices[0]));
                subsetUndistorted.add(undistortedPoints.get(samplesIndices[1]));

                try {
                    radialDistortionEstimator.setPoints(distortedPoints, undistortedPoints);
                    radialDistortionEstimator.setPoints(subsetDistorted, subsetUndistorted);

                    final var distortion = radialDistortionEstimator.estimate();
                    solutions.add(distortion);
                } catch (final Exception e) {
                    // if anything fails, no solution is added
                }
            }

            @Override
            public double computeResidual(final RadialDistortion currentEstimation, final int i) {
                final var distortedPoint = distortedPoints.get(i);
                final var undistortedPoint = undistortedPoints.get(i);

                currentEstimation.distort(undistortedPoint, testPoint);

                return testPoint.distanceTo(distortedPoint);
            }

            @Override
            public boolean isReady() {
                return PROMedSRadialDistortionRobustEstimator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.html#L399">399</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/RANSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/RANSACRadialDistortionRobustEstimator.html#L238">238</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>return RadialDistortionRobustEstimator.MIN_NUMBER_OF_POINTS;
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;RadialDistortion&gt; solutions) {
                subsetDistorted.clear();
                subsetDistorted.add(distortedPoints.get(samplesIndices[0]));
                subsetDistorted.add(distortedPoints.get(samplesIndices[1]));

                subsetUndistorted.clear();
                subsetUndistorted.add(undistortedPoints.get(samplesIndices[0]));
                subsetUndistorted.add(undistortedPoints.get(samplesIndices[1]));

                try {
                    radialDistortionEstimator.setPoints(distortedPoints, undistortedPoints);
                    radialDistortionEstimator.setPoints(subsetDistorted, subsetUndistorted);

                    final var distortion = radialDistortionEstimator.estimate();
                    solutions.add(distortion);
                } catch (final Exception e) {
                    // if anything fails, no solution is added
                }
            }

            @Override
            public double computeResidual(final RadialDistortion currentEstimation, final int i) {
                final var distortedPoint = distortedPoints.get(i);
                final var undistortedPoint = undistortedPoints.get(i);

                currentEstimation.distort(undistortedPoint, testPoint);

                return testPoint.distanceTo(distortedPoint);
            }

            @Override
            public boolean isReady() {
                return PROSACRadialDistortionRobustEstimator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L187">187</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L937">937</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>q = QuaternionPredictor.predict(q, wx, wy, wz, dt, true, qq, qw);

            // apply control signals
            vx += uvx;
            vy += uvy;
            vz += uvz;

            wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = wx;
            result[11] = wy;
            result[12] = wz;

            // jacobians
            if (jacobianX != null) {
                // [Rr   0   Rv  0  ]
                // [0    Qq  0   Qw ]
                // [0    0   eye 0  ]
                // [0    0   0   eye]
                jacobianX.initialize(0.0);
                jacobianX.setSubmatrix(0, 0, 2, 2, rr);

                jacobianX.setSubmatrix(3, 3, 6, 6, qq);

                jacobianX.setSubmatrix(0, 7, 2, 9, rv);

                for (int i = 7; i &lt; STATE_COMPONENTS; i++) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L430">430</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L937">937</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>q = QuaternionPredictor.predict(q, wx, wy, wz, dt, true, qq, qw);

            // apply control signals
            vx += uvx;
            vy += uvy;
            vz += uvz;

            wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = wx;
            result[11] = wy;
            result[12] = wz;

            // jacobians
            if (jacobianX != null) {
                // [Rr   0   Rv  0  ]
                // [0    Qq  0   Qw ]
                // [0    0   eye 0  ]
                // [0    0   0   eye]
                jacobianX.initialize(0.0);
                jacobianX.setSubmatrix(0, 0, 2, 2, rr);

                jacobianX.setSubmatrix(3, 3, 6, 6, qq);

                jacobianX.setSubmatrix(0, 7, 2, 9, rv);

                for (int i = 7; i &lt; STATE_WITH_POSITION_ADJUSTMENT_COMPONENTS; i++) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L566">566</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L589">589</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 4, h31 * h32);

                    // normalize row
                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                            + Math.pow(a.getElementAt(counter, 1), 2.0)
                            + Math.pow(a.getElementAt(counter, 2), 2.0)
                            + Math.pow(a.getElementAt(counter, 3), 2.0)
                            + Math.pow(a.getElementAt(counter, 4), 2.0));
                    factor = weight / rowNorm;

                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);
                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);
                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);
                    a.setElementAt(counter, 3, a.getElementAt(counter, 3) * factor);
                    a.setElementAt(counter, 4, a.getElementAt(counter, 4) * factor);

                    counter++;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.html#L218">218</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/KnownBaselineTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/KnownBaselineTwoViewsSparseReconstructor.html#L71">71</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var camera1 = estimatedCamera1.getCamera();
            final var camera2 = estimatedCamera2.getCamera();

            camera1.decompose();
            camera2.decompose();

            final var center1 = camera1.getCameraCenter();
            final var center2 = camera2.getCameraCenter();

            final var estimatedBaseline = center1.distanceTo(center2);

            final var scale = baseline / estimatedBaseline;

            final var scaleTransformation = new MetricTransformation3D(scale);

            // update scale of cameras
            scaleTransformation.transform(camera1);
            scaleTransformation.transform(camera2);

            estimatedCamera1.setCamera(camera1);
            estimatedCamera2.setCamera(camera2);

            // update scale of reconstructed points
            final var numPoints = reconstructedPoints.size();
            final var reconstructedPoints3D = new ArrayList&lt;Point3D&gt;();
            for (final var reconstructedPoint : reconstructedPoints) {
                reconstructedPoints3D.add(reconstructedPoint.getPoint());
            }

            scaleTransformation.transformAndOverwritePoints(reconstructedPoints3D);

            // set scaled points into result
            for (var i = 0; i &lt; numPoints; i++) {
                reconstructedPoints.get(i).setPoint(reconstructedPoints3D.get(i));
            }

            return true;
        } catch (final Exception e) {
            failed = true;
            //noinspection unchecked
            listener.onFail((R) this);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1989">1989</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L974">974</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var samples2 = currentEstimatedFundamentalMatrix.getRightSamples();

        final var points1 = new ArrayList&lt;Point2D&gt;();
        final var points2 = new ArrayList&lt;Point2D&gt;();
        final var length = samples1.size();
        for (var i = 0; i &lt; length; i++) {
            final var sample1 = samples1.get(i);
            final var sample2 = samples2.get(i);

            final var point1 = sample1.getPoint();
            final var point2 = sample2.getPoint();

            points1.add(point1);
            points2.add(point2);
        }

        try {
            final var estimator = new DualImageOfAbsoluteConicInitialCamerasEstimator(fundamentalMatrix, points1,
                    points2);
            estimator.setPrincipalPoint(configuration.getPrincipalPointX(), configuration.getPrincipalPointY());
            estimator.setAspectRatio(configuration.getInitialCamerasAspectRatio());
            estimator.setCorrectorType(configuration.getInitialCamerasCorrectorType());
            estimator.setPointsTriangulated(true);
            estimator.setValidTriangulatedPointsMarked(configuration.getInitialCamerasMarkValidTriangulatedPoints());

            estimator.estimate();

            // store cameras
            final var camera1 = estimator.getEstimatedLeftCamera();
            final var camera2 = estimator.getEstimatedRightCamera();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructor.html#L405">405</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.html#L274">274</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var positionZ = lastPosZ + slamEstimator.getStatePositionZ();

        final var velocityX = slamEstimator.getStateVelocityX();
        final var velocityY = slamEstimator.getStateVelocityY();
        final var velocityZ = slamEstimator.getStateVelocityZ();

        final var accelerationX = slamEstimator.getStateAccelerationX();
        final var accelerationY = slamEstimator.getStateAccelerationY();
        final var accelerationZ = slamEstimator.getStateAccelerationZ();

        final var quaternionA = slamEstimator.getStateQuaternionA();
        final var quaternionB = slamEstimator.getStateQuaternionB();
        final var quaternionC = slamEstimator.getStateQuaternionC();
        final var quaternionD = slamEstimator.getStateQuaternionD();

        final var angularSpeedX = slamEstimator.getStateAngularSpeedX();
        final var angularSpeedY = slamEstimator.getStateAngularSpeedY();
        final var angularSpeedZ = slamEstimator.getStateAngularSpeedZ();

        //noinspection unchecked
        listener.onSlamDataAvailable((R) this, positionX, positionY, positionZ, velocityX, velocityY, velocityZ,
                accelerationX, accelerationY, accelerationZ, quaternionA, quaternionB, quaternionC, quaternionD,
                angularSpeedX, angularSpeedY, angularSpeedZ, slamEstimator.getStateCovariance());
    }

    /**
     * Notifies estimated camera by means of SLAM if notification is enabled at
     * configuration time and intrinsics are already available.
     */
    private void notifySlamCameraIfNeeded() {
        if (!configuration.isNotifyEstimatedSlamCameraEnabled()) {
            return;
        }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L681">681</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L826">826</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);
                a.setElementAt(counter, 1, h21 * h22);
                a.setElementAt(counter, 2, h31 * h32);

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0));</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.html#L244">244</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.html#L422">422</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a = new Matrix(singularityEnforced ? 8 : 12, BaseQuadric.N_PARAMS);
            }

            Matrix cameraMatrix;
            double p11;
            double p12;
            double p13;
            double p14;
            double p21;
            double p22;
            double p23;
            double p24;
            double p31;
            double p32;
            double p33;
            double p34;
            var eqCounter = 0;
            final var minReqEqs = getMinRequiredEquations();
            for (final var camera : cameras) {

                // normalize cameras to increase accuracy
                camera.normalize();

                cameraMatrix = camera.getInternalMatrix();

                p11 = cameraMatrix.getElementAt(0, 0);
                p21 = cameraMatrix.getElementAt(1, 0);
                p31 = cameraMatrix.getElementAt(2, 0);

                p12 = cameraMatrix.getElementAt(0, 1);
                p22 = cameraMatrix.getElementAt(1, 1);
                p32 = cameraMatrix.getElementAt(2, 1);

                p13 = cameraMatrix.getElementAt(0, 2);
                p23 = cameraMatrix.getElementAt(1, 2);
                p33 = cameraMatrix.getElementAt(2, 2);

                p14 = cameraMatrix.getElementAt(0, 3);
                p24 = cameraMatrix.getElementAt(1, 3);
                p34 = cameraMatrix.getElementAt(2, 3);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L423">423</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L445">445</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 4, h31 * h32);

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0)
                        + Math.pow(a.getElementAt(counter, 3), 2.0)
                        + Math.pow(a.getElementAt(counter, 4), 2.0));

                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);
                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);
                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);
                a.setElementAt(counter, 3, a.getElementAt(counter, 3) / rowNorm);
                a.setElementAt(counter, 4, a.getElementAt(counter, 4) / rowNorm);

                counter++;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L863">863</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L1003">1003</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0)
                        + (Math.pow(h21, 2.0) - Math.pow(h22, 2.0)) / sqrAspectRatio);
                a.setElementAt(counter, 1, 2.0 * (h11 * h31 - h12 * h32));
                a.setElementAt(counter, 2, 2.0 * (h21 * h31 - h22 * h32));
                a.setElementAt(counter, 3, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0)
                        + Math.pow(a.getElementAt(counter, 3), 2.0));</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L368">368</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L518">518</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L664">664</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L805">805</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var a = new Matrix(2 * nHomographies, 6);

            var index = 0;
            var counter = 0;
            ProjectiveTransformation2D t = null;
            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            double weight;
            double factor;
            for (final var homography : homographies) {
                if (selected[index]) {
                    weight = weights[index];

                    // convert homography into projective so it can be normalized
                    homography.asMatrix(h);
                    if (t == null) {
                        t = new ProjectiveTransformation2D(h);
                    } else {
                        t.setT(h);
                    }

                    // normalize
                    t.normalize();

                    // obtain elements of projective transformation matrix
                    // there is no need to retrieve internal matrix h, as we already
                    // hold a reference
                    h11 = h.getElementAt(0, 0);
                    h12 = h.getElementAt(0, 1);

                    h21 = h.getElementAt(1, 0);
                    h22 = h.getElementAt(1, 1);

                    h31 = h.getElementAt(2, 0);
                    h32 = h.getElementAt(2, 1);

                    // fill first equation
                    a.setElementAt(counter, 0, h11 * h12);
                    a.setElementAt(counter, 1, h11 * h22 + h21 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L187">187</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L679">679</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>q = QuaternionPredictor.predict(q, wx, wy, wz, dt, true, qq, qw);

            // apply control signals
            vx += uvx;
            vy += uvy;
            vz += uvz;

            wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = wx;
            result[11] = wy;
            result[12] = wz;

            // jacobians
            if (jacobianX != null) {
                // [Rr   0   Rv  0  ]
                // [0    Qq  0   Qw ]
                // [0    0   eye 0  ]
                // [0    0   0   eye]
                jacobianX.initialize(0.0);
                jacobianX.setSubmatrix(0, 0, 2, 2, rr);

                jacobianX.setSubmatrix(3, 3, 6, 6, qq);

                jacobianX.setSubmatrix(0, 7, 2, 9, rv);

                for (int i = 7; i &lt; STATE_COMPONENTS; i++) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L430">430</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L679">679</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>q = QuaternionPredictor.predict(q, wx, wy, wz, dt, true, qq, qw);

            // apply control signals
            vx += uvx;
            vy += uvy;
            vz += uvz;

            wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = wx;
            result[11] = wy;
            result[12] = wz;

            // jacobians
            if (jacobianX != null) {
                // [Rr   0   Rv  0  ]
                // [0    Qq  0   Qw ]
                // [0    0   eye 0  ]
                // [0    0   0   eye]
                jacobianX.initialize(0.0);
                jacobianX.setSubmatrix(0, 0, 2, 2, rr);

                jacobianX.setSubmatrix(3, 3, 6, 6, qq);

                jacobianX.setSubmatrix(0, 7, 2, 9, rv);

                for (int i = 7; i &lt; STATE_WITH_POSITION_ADJUSTMENT_COMPONENTS; i++) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.html#L444">444</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/SlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/SlamEstimator.html#L475">475</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>x[12] = stateAngularSpeedZ;

            try {
                // set initial Kalman filter state (state pre and pro must be two
                // different instances!)
                kalmanFilter.getStatePre().fromArray(x);
                kalmanFilter.getStatePost().fromArray(x);
            } catch (final WrongSizeException ignore) {
                // never thrown
            }
        }
        error = false;
        lastTimestampNanos = -1;
        predictionAvailable = false;
    }

    /**
     * Updates state data of the device by using state matrix obtained after
     * prediction from Kalman filter.
     * to ensure that state follows proper values (specially on quaternions),
     * we keep x values, which have been predicted using the state predictor,
     * which uses analytical values.
     * We then updated x using latest Kalman filter state for next iteration
     * on state predictor.
     *
     * @param state state matrix obtained from Kalman filter.
     */
    private void updatePredictedState(final Matrix state) {
        // position
        statePositionX = x[0];
        x[0] = state.getElementAtIndex(0);
        statePositionY = x[1];
        x[1] = state.getElementAtIndex(1);
        statePositionZ = x[2];
        x[2] = state.getElementAtIndex(2);

        // quaternion state predictor is more reliable than Kalman filter, for
        // that reason we ignore predicted quaternion values on Kalman filter and
        // simply keep predicted ones. Besides, typically gyroscope samples are
        // much more reliable than accelerometer ones. For that reason state
        // elements corresponding to quaternion (3 to 6) are not copied into mX
        // array.
        stateQuaternionA = x[3];
        stateQuaternionB = x[4];
        stateQuaternionC = x[5];
        stateQuaternionD = x[6];

        // velocity
        stateVelocityX = x[7];
        x[7] = state.getElementAtIndex(7);
        stateVelocityY = x[8];
        x[8] = state.getElementAtIndex(8);
        stateVelocityZ = x[9];
        x[9] = state.getElementAtIndex(9);

        // linear acceleration
        stateAccelerationX = accumulatedAccelerationSampleX;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/MSACDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/MSACDualAbsoluteQuadricRobustEstimator.html#L161">161</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROSACDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACDualAbsoluteQuadricRobustEstimator.html#L278">278</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/RANSACDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/RANSACDualAbsoluteQuadricRobustEstimator.html#L160">160</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final var innerEstimator = new MSACRobustEstimator&lt;DualAbsoluteQuadric&gt;(new MSACRobustEstimatorListener&lt;&gt;() {

            // subset of cameras picked on each iteration
            private final List&lt;PinholeCamera&gt; subsetCameras = new ArrayList&lt;&gt;();

            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return cameras.size();
            }

            @Override
            public int getSubsetSize() {
                return daqEstimator.getMinNumberOfRequiredCameras();
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;DualAbsoluteQuadric&gt; solutions) {
                subsetCameras.clear();
                for (final var samplesIndex : samplesIndices) {
                    subsetCameras.add(cameras.get(samplesIndex));
                }

                try {
                    daqEstimator.setLMSESolutionAllowed(false);
                    daqEstimator.setCameras(subsetCameras);

                    final var daq = daqEstimator.estimate();
                    solutions.add(daq);
                } catch (final Exception e) {
                    // if anything fails, no solution is added
                }
            }

            @Override
            public double computeResidual(final DualAbsoluteQuadric currentEstimation, final int i) {
                return residual(currentEstimation, cameras.get(i));
            }

            @Override
            public boolean isReady() {
                return MSACDualAbsoluteQuadricRobustEstimator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/MSACImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/MSACImageOfAbsoluteConicRobustEstimator.html#L170">170</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROSACImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACImageOfAbsoluteConicRobustEstimator.html#L292">292</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var innerEstimator = new MSACRobustEstimator&lt;ImageOfAbsoluteConic&gt;(new MSACRobustEstimatorListener&lt;&gt;() {

            // subset of homographies picked on each iteration
            private final List&lt;Transformation2D&gt; subsetHomographies = new ArrayList&lt;&gt;();

            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return homographies.size();
            }

            @Override
            public int getSubsetSize() {
                return iacEstimator.getMinNumberOfRequiredHomographies();
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;ImageOfAbsoluteConic&gt; solutions) {
                subsetHomographies.clear();
                for (final var samplesIndex : samplesIndices) {
                    subsetHomographies.add(homographies.get(samplesIndex));
                }

                try {
                    iacEstimator.setLMSESolutionAllowed(false);
                    iacEstimator.setHomographies(subsetHomographies);

                    final var iac = iacEstimator.estimate();
                    solutions.add(iac);
                } catch (final Exception e) {
                    // if anything fails, no solution is added
                }
            }

            @Override
            public double computeResidual(final ImageOfAbsoluteConic currentEstimation, final int i) {
                return residual(currentEstimation, homographies.get(i));
            }

            @Override
            public boolean isReady() {
                return MSACImageOfAbsoluteConicRobustEstimator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/CameraCalibrator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/CameraCalibrator.html#L566">566</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/ImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/ImageOfAbsoluteConicRobustEstimator.html#L219">219</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Returns boolean indicating whether camera skewness is assumed to be zero
     * or not.
     * Skewness determines whether LCD sensor cells are properly aligned or not,
     * where zero indicates perfect alignment.
     * Typically, skewness is a value equal or very close to zero.
     *
     * @return true if camera skewness is assumed to be zero, otherwise camera
     * skewness is estimated.
     */
    public boolean isZeroSkewness() {
        return iacEstimator.isZeroSkewness();
    }

    /**
     * Sets boolean indicating whether camera skewness is assumed to be zero or
     * not.
     * Skewness determines whether LCD sensor cells are properly aligned or not,
     * where zero indicates perfect alignment.
     * Typically, skewness is a value equal or very close to zero.
     *
     * @param zeroSkewness true if camera skewness is assumed to be zero,
     *                     otherwise camera skewness is estimated.
     * @throws LockedException if this instance is locked.
     */
    public void setZeroSkewness(final boolean zeroSkewness) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        iacEstimator.setZeroSkewness(zeroSkewness);
    }

    /**
     * Returns boolean indicating whether principal point is assumed to be at
     * origin of coordinates or not.
     * Typically principal point is located at image center (origin of
     * coordinates), and usually matches the center of radial distortion if it
     * is taken into account.
     *
     * @return true if principal point is assumed to be at origin of
     * coordinates, false if principal point must be estimated.
     */
    public boolean isPrincipalPointAtOrigin() {
        return iacEstimator.isPrincipalPointAtOrigin();
    }

    /**
     * Sets boolean indicating whether principal point is assumed to be at
     * origin of coordinates or not.
     * Typically principal point is located at image center (origin of
     * coordinates), and usually matches the center of radial distortion if it
     * is taken into account.
     *
     * @param principalPointAtOrigin true if principal point is assumed to bet
     *                               at origin of coordinates, false if principal point must be estimated.
     * @throws LockedException if estimator is locked.
     */
    public void setPrincipalPointAtOrigin(final boolean principalPointAtOrigin) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        iacEstimator.setPrincipalPointAtOrigin(principalPointAtOrigin);
    }

    /**
     * Returns boolean indicating whether aspect ratio of focal distances (i.e.
     * vertical focal distance divided by horizontal focal distance) is known or
     * not.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio. Typically, LCD sensor cells are square and hence aspect
     * ratio of focal distances is known and equal to 1.
     * This value is only taken into account if skewness is assumed to be zero,
     * otherwise it is ignored.
     *
     * @return true if focal distance aspect ratio is known, false otherwise.
     */
    public boolean isFocalDistanceAspectRatioKnown() {
        return iacEstimator.isFocalDistanceAspectRatioKnown();
    }

    /**
     * Sets boolean indicating whether aspect ratio of focal distances (i.e.
     * vertical focal distance divided by horizontal focal distance) is known or
     * not.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio. Typically, LCD sensor cells are square and hence aspect
     * ratio of focal distances is known and equal to 1.
     * This value is only taken into account if skewness is assumed to be zero,
     * otherwise it is ignored.
     *
     * @param focalDistanceAspectRatioKnown true if focal distance aspect ratio
     *                                      is known, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFocalDistanceAspectRatioKnown(final boolean focalDistanceAspectRatioKnown) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        iacEstimator.setFocalDistanceAspectRatioKnown(focalDistanceAspectRatioKnown);
    }

    /**
     * Returns aspect ratio of focal distances (i.e. vertical focal distance
     * divided by horizontal focal distance).
     * This value is only taken into account if skewness is assumed to be zero
     * and focal distance aspect ratio is marked as known, otherwise it is
     * ignored.
     * By default, this is 1.0, since it is taken into account that typically
     * LCD sensor cells are square and hence aspect ratio focal distances is
     * known and equal to 1.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio.
     * Notice that a negative aspect ratio indicates that vertical axis is
     * reversed. This can be useful in some situations where image vertical
     * coordinates are reversed respect to the physical world (i.e. in computer
     * graphics typically image vertical coordinates go downwards, while in
     * physical world they go upwards).
     *
     * @return aspect ratio of focal distances.
     */
    public double getFocalDistanceAspectRatio() {
        return iacEstimator.getFocalDistanceAspectRatio();
    }

    /**
     * Sets aspect ratio of focal distances (i.e. vertical focal distance
     * divided by horizontal focal distance).
     * This value is only taken into account if skewness is assumed to be zero
     * and focal distance aspect ratio is marked as known, otherwise it is
     * ignored.
     * By default, this is 1.0, since it is taken into account that typically
     * LCD sensor cells are square and hence aspect ratio focal distances is
     * known and equal to 1.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio.
     * Notice that a negative aspect ratio indicates that vertical axis is
     * reversed. This can be useful in some situations where image vertical
     * coordinates are reversed respect to the physical world (i.e. in computer
     * graphics typically image vertical coordinates go downwards, while in
     * physical world they go upwards).
     *
     * @param focalDistanceAspectRatio aspect ratio of focal distances to be set.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if focal distance aspect ratio is too
     *                                  close to zero, as it might produce numerical instabilities.
     */
    public void setFocalDistanceAspectRatio(final double focalDistanceAspectRatio) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        iacEstimator.setFocalDistanceAspectRatio(focalDistanceAspectRatio);
    }

    /**
     * Indicates whether this instance is locked because calibration is in
     * progress.
     *
     * @return true if this instance, false otherwise.
     */
    public boolean isLocked() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/DualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/DualAbsoluteQuadricEstimator.html#L250">250</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/ImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/ImageOfAbsoluteConicEstimator.html#L207">207</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Returns boolean indicating whether camera skewness is assumed to be zero
     * or not.
     * Skewness determines whether LCD sensor cells are properly aligned or not,
     * where zero indicates perfect alignment.
     * Typically, skewness is a value equal or very close to zero.
     *
     * @return true if camera skewness is assumed to be zero, otherwise camera
     * skewness is estimated
     */
    public boolean isZeroSkewness() {
        return zeroSkewness;
    }

    /**
     * Sets boolean indicating whether camera skewness is assumed to be zero or
     * not.
     * Skewness determines whether LCD sensor cells are properly aligned or not,
     * where zero indicates perfect alignment.
     * Typically, skewness is a value equal or very close to zero.
     *
     * @param zeroSkewness true if camera skewness is assumed to be zero,
     *                     otherwise camera skewness is estimated
     * @throws LockedException if estimator is locked
     */
    public void setZeroSkewness(final boolean zeroSkewness) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.zeroSkewness = zeroSkewness;
    }

    /**
     * Returns boolean indicating whether principal point is assumed to be at
     * origin of coordinates or not.
     * Typically principal point is located at image center (origin of
     * coordinates), and usually matches the center of radial distortion if
     * it is taken into account.
     *
     * @return true if principal point is assumed to be at origin of
     * coordinates, false if principal point must be estimated
     */
    public boolean isPrincipalPointAtOrigin() {
        return principalPointAtOrigin;
    }

    /**
     * Sets boolean indicating whether principal point is assumed to be at
     * origin of coordinates or not.
     * Typically principal point is located at image center (origin of
     * coordinates), and usually matches the center of radial distortion if it
     * is taken into account.
     *
     * @param principalPointAtOrigin true if principal point is assumed to be at
     *                               origin of coordinates, false if principal point must be estimated
     * @throws LockedException if estimator is locked
     */
    public void setPrincipalPointAtOrigin(final boolean principalPointAtOrigin) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.principalPointAtOrigin = principalPointAtOrigin;
    }

    /**
     * Returns boolean indicating whether aspect ratio of focal distances (i.e.
     * vertical focal distance divided by horizontal focal distance) is known or
     * not.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio. Typically, LCD sensor cells are square and hence aspect
     * ratio of focal distances is known and equal to 1.
     * This value is only taken into account if skewness is assumed to be zero,
     * otherwise it is ignored.
     *
     * @return true if focal distance aspect ratio is known, false otherwise
     */
    public boolean isFocalDistanceAspectRatioKnown() {
        return focalDistanceAspectRatioKnown;
    }

    /**
     * Sets value indicating whether aspect ratio of focal distances (i.e.
     * vertical focal distance divided by horizontal focal distance) is known or
     * not.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio. Typically, LCD sensor cells are square and hence aspect
     * ratio of focal distances is known and equal to 1.
     * This value is only taken into account if skewness is assumed to be zero,
     * otherwise it is ignored.
     *
     * @param focalDistanceAspectRatioKnown true if focal distance aspect ratio
     *                                      is known, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFocalDistanceAspectRatioKnown(final boolean focalDistanceAspectRatioKnown) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.focalDistanceAspectRatioKnown = focalDistanceAspectRatioKnown;
    }

    /**
     * Returns aspect ratio of focal distances (i.e. vertical focal distance
     * divided by horizontal focal distance).
     * This value is only taken into account if skewness is assumed to be zero
     * and focal distance aspect ratio is marked as known, otherwise it is
     * ignored.
     * By default, this is 1.0, since it is taken into account that typically
     * LCD sensor cells are square and hence aspect ratio focal distances is
     * known and equal to 1.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio.
     * Notice that a negative aspect ratio indicates that vertical axis is
     * reversed. This can be useful in some situations where image vertical
     * coordinates are reversed respect to the physical world (i.e. in computer
     * graphics typically image vertical coordinates go downwards, while in
     * physical world they go upwards).
     *
     * @return aspect ratio of focal distances.
     */
    public double getFocalDistanceAspectRatio() {
        return focalDistanceAspectRatio;
    }

    /**
     * Sets aspect ratio of focal distances (i.e. vertical focal distance
     * divided by horizontal focal distance).
     * This value is only taken into account if skewness is assumed to be zero
     * and focal distance aspect ratio is marked as known, otherwise it is
     * ignored.
     * By default, this is 1.0, since it is taken into account that typically
     * LCD sensor cells are square and hence aspect ratio focal distances is
     * known and equal to 1.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio.
     * Notice that a negative aspect ratio indicates that vertical axis is
     * reversed. This can be useful in some situations where image vertical
     * coordinates are reversed respect to the physical world (i.e. in computer
     * graphics typically image vertical coordinates go downwards, while in
     * physical world they go upwards).
     *
     * @param focalDistanceAspectRatio aspect ratio of focal distances to be set.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if focal distance aspect ratio is too
     *                                  close to zero, as it might produce numerical instabilities.
     */
    public void setFocalDistanceAspectRatio(final double focalDistanceAspectRatio) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (Math.abs(focalDistanceAspectRatio) &lt; MIN_ABS_FOCAL_DISTANCE_ASPECT_RATIO) {
            throw new IllegalArgumentException();
        }

        this.focalDistanceAspectRatio = focalDistanceAspectRatio;
    }

    /**
     * Indicates whether a singular DAQ is enforced or not.
     * Dual Absolute Quadric is singular (has rank 3) in any projective space,
     * however, due to noise in samples, estimated DAQ might not be fully
     * singular.
     *
     * @return true when singular DAQ is enforced, false otherwise.
     */
    public boolean isSingularityEnforced() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseAbsoluteOrientationSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseAbsoluteOrientationSlamSparseReconstructor.html#L192">192</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamSparseReconstructor.html#L280">280</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>scaleAndOrientationTransformation.transform(metricCamera2, euclideanCamera2);
            }
            final var sqrScale = scale * scale;

            previousEuclideanEstimatedCamera = new EstimatedCamera();
            previousEuclideanEstimatedCamera.setCamera(euclideanCamera1);
            previousEuclideanEstimatedCamera.setViewId(previousMetricEstimatedCamera.getViewId());
            previousEuclideanEstimatedCamera.setQualityScore(previousMetricEstimatedCamera.getQualityScore());
            if (previousMetricEstimatedCamera.getCovariance() != null) {
                previousEuclideanEstimatedCamera.setCovariance(previousMetricEstimatedCamera.getCovariance()
                        .multiplyByScalarAndReturnNew(sqrScale));
            }

            currentEuclideanEstimatedCamera = new EstimatedCamera();
            currentEuclideanEstimatedCamera.setCamera(euclideanCamera2);
            currentEuclideanEstimatedCamera.setViewId(currentMetricEstimatedCamera.getViewId());
            currentEuclideanEstimatedCamera.setQualityScore(currentMetricEstimatedCamera.getQualityScore());
            if (currentMetricEstimatedCamera.getCovariance() != null) {
                currentEuclideanEstimatedCamera.setCovariance(currentMetricEstimatedCamera.getCovariance()
                        .multiplyByScalarAndReturnNew(sqrScale));
            }

            // update scale of reconstructed points
            final var numPoints = activeMetricReconstructedPoints.size();
            final var metricReconstructedPoints3D = new ArrayList&lt;Point3D&gt;();
            for (final var reconstructedPoint : activeMetricReconstructedPoints) {
                metricReconstructedPoints3D.add(reconstructedPoint.getPoint());
            }

            final var euclideanReconstructedPoints3D = scaleAndOrientationTransformation.transformPointsAndReturnNew(</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/RadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/RadialDistortionRobustEstimator.html#L311">311</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/RobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/RobustSinglePoint3DTriangulator.html#L271">271</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Indicates if this instance is locked because estimation is being computed.
     *
     * @return true if locked, false otherwise.
     */
    public boolean isLocked() {
        return locked;
    }

    /**
     * Returns amount of progress variation before notifying a progress change
     * during estimation.
     *
     * @return amount of progress variation before notifying a progress change
     * during estimation.
     */
    public float getProgressDelta() {
        return progressDelta;
    }

    /**
     * Sets amount of progress variation before notifying a progress change
     * during estimation.
     *
     * @param progressDelta amount of progress variation before notifying a
     *                      progress change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or
     *                                  greater than 1.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setProgressDelta(final float progressDelta) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (progressDelta &lt; MIN_PROGRESS_DELTA || progressDelta &gt; MAX_PROGRESS_DELTA) {
            throw new IllegalArgumentException();
        }
        this.progressDelta = progressDelta;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%). The amount of confidence indicates the
     * probability that the estimated result is correct. Usually this value will
     * be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence as a value between 0.0 and 1.0.
     */
    public double getConfidence() {
        return confidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which
     * is equivalent to 100%). The amount of confidence indicates the
     * probability that the estimated result is correct. Usually this value will
     * be close to 1.0, but not exactly 1.0.
     *
     * @param confidence confidence to be set as a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and
     *                                  1.0.
     * @throws LockedException          if this estimator is locked because an estimator
     *                                  is being computed.
     */
    public void setConfidence(final double confidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (confidence &lt; MIN_CONFIDENCE || confidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        this.confidence = confidence;
    }

    /**
     * Returns maximum allowed number of iterations. If maximum allowed number
     * of iterations is achieved without converging to a result when calling
     * estimate(), a RobustEstimatorException will be raised.
     *
     * @return maximum allowed number of iterations.
     */
    public int getMaxIterations() {
        return maxIterations;
    }

    /**
     * Sets maximum allowed number of iterations. When the maximum number of
     * iterations is exceeded, result will not be available, however an
     * approximate result will be available for retrieval
     *
     * @param maxIterations maximum allowed number of iterations to be set.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setMaxIterations(final int maxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (maxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        this.maxIterations = maxIterations;
    }

    /**
     * Sets list of corresponding distorted and undistorted points.
     *
     * @param distortedPoints   list of distorted points. Distorted points are
     *                          obtained after radial distortion is applied to an undistorted point.
     * @param undistortedPoints list of undistorted points.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided lists of points don't have
     *                                  the same size.
     */
    public void setPoints(final List&lt;Point2D&gt; distortedPoints, final List&lt;Point2D&gt; undistortedPoints)</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/DualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/DualAbsoluteQuadricRobustEstimator.html#L450">450</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/RobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/RobustSinglePoint3DTriangulator.html#L271">271</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Indicates whether this instance is locked.
     *
     * @return true if this estimator is busy estimating the Dual Absolute
     * Quadric, false otherwise.
     */
    public boolean isLocked() {
        return locked;
    }

    /**
     * Returns amount of progress variation before notifying a progress change
     * during estimation.
     *
     * @return amount of progress variation before notifying a progress change
     * during estimation.
     */
    public float getProgressDelta() {
        return progressDelta;
    }

    /**
     * Sets amount of progress variation before notifying a progress change
     * during estimation.
     *
     * @param progressDelta amount of progress variation before notifying a
     *                      progress change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or
     *                                  greater than 1.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setProgressDelta(final float progressDelta) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (progressDelta &lt; MIN_PROGRESS_DELTA || progressDelta &gt; MAX_PROGRESS_DELTA) {
            throw new IllegalArgumentException();
        }
        this.progressDelta = progressDelta;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%). The amount of confidence indicates the
     * probability that the estimated result is correct. Usually this value will
     * be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence as a value between 0.0 and 1.0.
     */
    public double getConfidence() {
        return confidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which
     * is equivalent to 100%). The amount of confidence indicates the
     * probability that the estimated result is correct. Usually this value will
     * be close to 1.0, but not exactly 1.0.
     *
     * @param confidence confidence to be set as a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and
     *                                  1.0.
     * @throws LockedException          if this estimator is locked because an estimator
     *                                  is being computed.
     */
    public void setConfidence(final double confidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (confidence &lt; MIN_CONFIDENCE || confidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        this.confidence = confidence;
    }

    /**
     * Returns maximum allowed number of iterations. If maximum allowed number
     * of iterations is achieved without converging to a result when calling
     * estimate(), a RobustEstimatorException will be raised.
     *
     * @return maximum allowed number of iterations.
     */
    public int getMaxIterations() {
        return maxIterations;
    }

    /**
     * Sets maximum allowed number of iterations. When the maximum number of
     * iterations is exceeded, result will not be available, however an
     * approximate result will be available for retrieval.
     *
     * @param maxIterations maximum allowed number of iterations to be set.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setMaxIterations(final int maxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (maxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        this.maxIterations = maxIterations;
    }

    /**
     * Obtains the list of cameras used to estimate the Dual Absolute Quadric
     * (DAQ).
     *
     * @return list of cameras to estimate the DAQ.
     */
    public List&lt;PinholeCamera&gt; getCameras() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/ImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/ImageOfAbsoluteConicRobustEstimator.html#L410">410</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/RobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/RobustSinglePoint3DTriangulator.html#L271">271</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Indicates if this instance is locked because estimation is being
     * computed.
     *
     * @return true if locked, false otherwise.
     */
    public boolean isLocked() {
        return locked;
    }

    /**
     * Returns amount of progress variation before notifying a progress change
     * during estimation.
     *
     * @return amount of progress variation before notifying a progress change
     * during estimation.
     */
    public float getProgressDelta() {
        return progressDelta;
    }

    /**
     * Sets amount of progress variation before notifying a progress change
     * during estimation.
     *
     * @param progressDelta amount of progress variation before notifying a
     *                      progress change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or
     *                                  greater than 1.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setProgressDelta(final float progressDelta) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (progressDelta &lt; MIN_PROGRESS_DELTA || progressDelta &gt; MAX_PROGRESS_DELTA) {
            throw new IllegalArgumentException();
        }
        this.progressDelta = progressDelta;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%). The amount of confidence indicates the
     * probability that the estimated result is correct. Usually this value will
     * be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence as a value between 0.0 and 1.0.
     */
    public double getConfidence() {
        return confidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which
     * is equivalent to 100%). The amount of confidence indicates the
     * probability that the estimated result is correct. Usually this value will
     * be close to 1.0, but not exactly 1.0.
     *
     * @param confidence confidence to be set as a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and
     *                                  1.0.
     * @throws LockedException          if this estimator is locked because an estimator
     *                                  is being computed.
     */
    public void setConfidence(final double confidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (confidence &lt; MIN_CONFIDENCE || confidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        this.confidence = confidence;
    }

    /**
     * Returns maximum allowed number of iterations. If maximum allowed number
     * of iterations is achieved without converging to a result when calling
     * estimate(), a RobustEstimatorException will be raised.
     *
     * @return maximum allowed number of iterations.
     */
    public int getMaxIterations() {
        return maxIterations;
    }

    /**
     * Sets maximum allowed number of iterations. When the maximum number of
     * iterations is exceeded, result will not be available, however an
     * approximate result will be available for retrieval.
     *
     * @param maxIterations maximum allowed number of iterations to be set.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setMaxIterations(final int maxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (maxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        this.maxIterations = maxIterations;
    }

    /**
     * Gets list of homographies to estimate IAC.
     *
     * @return list of homographies to estimate IAC.
     */
    public List&lt;Transformation2D&gt; getHomographies() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L368">368</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L939">939</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L1085">1085</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final var a = new Matrix(2 * nHomographies, 6);

            var index = 0;
            var counter = 0;
            ProjectiveTransformation2D t = null;
            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            double weight;
            double factor;
            for (final var homography : homographies) {
                if (selected[index]) {
                    weight = weights[index];

                    // convert homography into projective so it can be normalized
                    homography.asMatrix(h);
                    if (t == null) {
                        t = new ProjectiveTransformation2D(h);
                    } else {
                        t.setT(h);
                    }

                    // normalize
                    t.normalize();

                    // obtain elements of projective transformation matrix
                    // there is no need to retrieve internal matrix h, as we already
                    // hold a reference
                    h11 = h.getElementAt(0, 0);
                    h12 = h.getElementAt(0, 1);

                    h21 = h.getElementAt(1, 0);
                    h22 = h.getElementAt(1, 1);

                    h31 = h.getElementAt(2, 0);
                    h32 = h.getElementAt(2, 1);

                    // fill first equation
                    a.setElementAt(counter, 0, h11 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/FundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/FundamentalMatrixRobustEstimator.html#L354">354</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/RobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/RobustSinglePoint3DTriangulator.html#L271">271</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Returns boolean indicating if estimator is locked because estimation is
     * under progress.
     *
     * @return true if estimator is locked, false otherwise.
     */
    public boolean isLocked() {
        return locked;
    }

    /**
     * Returns amount of progress variation before notifying a progress change
     * during estimation.
     *
     * @return amount of progress variation before notifying a progress change
     * during estimation.
     */
    public float getProgressDelta() {
        return progressDelta;
    }

    /**
     * Sets amount of progress variation before notifying a progress change
     * during estimation.
     *
     * @param progressDelta amount of progress variation before notifying a
     *                      progress change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or
     *                                  greater than 1.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setProgressDelta(final float progressDelta) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (progressDelta &lt; MIN_PROGRESS_DELTA || progressDelta &gt; MAX_PROGRESS_DELTA) {
            throw new IllegalArgumentException();
        }
        this.progressDelta = progressDelta;
    }

    /**
     * Returns amount of confidence expressed as a value between 0.0 and 1.0
     * (which is equivalent to 100%). The amount of confidence indicates the
     * probability that the estimated result is correct. Usually this value will
     * be close to 1.0, but not exactly 1.0.
     *
     * @return amount of confidence as a value between 0.0 and 1.0.
     */
    public double getConfidence() {
        return confidence;
    }

    /**
     * Sets amount of confidence expressed as a value between 0.0 and 1.0 (which
     * is equivalent to 100%). The amount of confidence indicates the
     * probability that the estimated result is correct. Usually this value will
     * be close to 1.0, but not exactly 1.0.
     *
     * @param confidence confidence to be set as a value between 0.0 and 1.0.
     * @throws IllegalArgumentException if provided value is not between 0.0 and
     *                                  1.0.
     * @throws LockedException          if this estimator is locked because an estimator
     *                                  is being computed.
     */
    public void setConfidence(final double confidence) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (confidence &lt; MIN_CONFIDENCE || confidence &gt; MAX_CONFIDENCE) {
            throw new IllegalArgumentException();
        }
        this.confidence = confidence;
    }

    /**
     * Returns maximum allowed number of iterations. If maximum allowed number
     * of iterations is achieved without converting to a result when calling
     * estimate(), a RobustEstimatorException will be raised.
     *
     * @return maximum allowed number of iterations.
     */
    public int getMaxIterations() {
        return maxIterations;
    }

    /**
     * Sets maximum allowed number of iterations. When the maximum number of
     * iterations is exceeded, result will not be available, however an
     * approximate result will be available for retrieval.
     *
     * @param maxIterations maximum allowed number of iterations to be set.
     * @throws IllegalArgumentException if provided value is less than 1.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setMaxIterations(final int maxIterations) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (maxIterations &lt; MIN_ITERATIONS) {
            throw new IllegalArgumentException();
        }
        this.maxIterations = maxIterations;
    }

    /**
     * Gets data related to inliers found after estimation.
     *
     * @return data related to inliers found after estimation.
     */
    public InliersData getInliersData() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1847">1847</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L840">840</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var fundamentalMatrix = currentEstimatedFundamentalMatrix.getFundamentalMatrix();
            fundamentalMatrix.normalize();

            final var estimator = new DualAbsoluteQuadricInitialCamerasEstimator(fundamentalMatrix);
            estimator.setAspectRatio(configuration.getInitialCamerasAspectRatio());
            estimator.estimate();

            final var camera1 = estimator.getEstimatedLeftCamera();
            final var camera2 = estimator.getEstimatedRightCamera();

            camera1.decompose();
            camera2.decompose();

            final var intrinsicZeroPrincipalPoint1 = camera1.getIntrinsicParameters();
            final var intrinsicZeroPrincipalPoint2 = camera2.getIntrinsicParameters();

            final var principalPointX = configuration.getPrincipalPointX();
            final var principalPointY = configuration.getPrincipalPointY();

            final var intrinsic1 = new PinholeCameraIntrinsicParameters(intrinsicZeroPrincipalPoint1);
            intrinsic1.setHorizontalPrincipalPoint(intrinsic1.getHorizontalPrincipalPoint() + principalPointX);
            intrinsic1.setVerticalPrincipalPoint(intrinsic1.getVerticalPrincipalPoint() + principalPointY);
            camera1.setIntrinsicParameters(intrinsic1);

            final var intrinsic2 = new PinholeCameraIntrinsicParameters(intrinsicZeroPrincipalPoint2);
            intrinsic2.setHorizontalPrincipalPoint(intrinsic2.getHorizontalPrincipalPoint() + principalPointX);
            intrinsic2.setVerticalPrincipalPoint(intrinsic2.getVerticalPrincipalPoint() + principalPointY);
            camera2.setIntrinsicParameters(intrinsic2);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L994">994</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L1079">1079</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>estimator.setAspectRatio(configuration.getInitialCamerasAspectRatio());
            estimator.setCorrectorType(configuration.getInitialCamerasCorrectorType());
            estimator.setPointsTriangulated(true);
            estimator.setValidTriangulatedPointsMarked(configuration.getInitialCamerasMarkValidTriangulatedPoints());

            estimator.estimate();

            // store cameras
            final var camera1 = estimator.getEstimatedLeftCamera();
            final var camera2 = estimator.getEstimatedRightCamera();

            estimatedCamera1 = new EstimatedCamera();
            estimatedCamera1.setCamera(camera1);

            estimatedCamera2 = new EstimatedCamera();
            estimatedCamera2.setCamera(camera2);

            // store points
            final var triangulatedPoints = estimator.getTriangulatedPoints();
            final var validTriangulatedPoints = estimator.getValidTriangulatedPoints();

            reconstructedPoints = new ArrayList&lt;&gt;();
            final var size = triangulatedPoints.size();
            for (var i = 0; i &lt; size; i++) {
                final var reconstructedPoint = new ReconstructedPoint3D();
                reconstructedPoint.setPoint(triangulatedPoints.get(i));
                reconstructedPoint.setInlier(validTriangulatedPoints.get(i));
                reconstructedPoints.add(reconstructedPoint);
            }

            return true;
        } catch (final Exception e) {
            return false;
        }
    }

    /**
     * Estimates initial cameras and reconstructed points using the essential
     * matrix and provided intrinsic parameters that must have been set during
     * offline calibration.
     *
     * @return true if cameras and points could be estimated, false if something
     * failed.
     */
    private boolean estimateInitialCamerasAndPointsEssential() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L566">566</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L840">840</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 2, h21 * h22);
                a.setElementAt(counter, 3, h31 * h32);

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0)
                        + Math.pow(a.getElementAt(counter, 3), 2.0));

                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);
                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);
                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);
                a.setElementAt(counter, 3, a.getElementAt(counter, 3) / rowNorm);

                counter++;

                // in case we want an exact solution (up to scale) when LMSE is
                // disabled, we stop after 2 equations
                if (!isLMSESolutionAllowed() &amp;&amp; (counter &gt;= MIN_REQUIRED_EQUATIONS - 2)) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L134">134</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L256">256</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Estimates Image of Absolute Conic (IAC).
     *
     * @return estimated IAC.
     * @throws LockedException                        if estimator is locked.
     * @throws NotReadyException                      if input has not yet been provided.
     * @throws ImageOfAbsoluteConicEstimatorException if an error occurs during
     *                                                estimation, usually because repeated homographies are
     *                                                provided, or homographies corresponding to degenerate
     *                                                camera movements such as pure parallel translations
     *                                                where no additional data is really provided. Indeed,
     *                                                if provided homographies belong to the group of affine
     *                                                transformations (or other groups contained within
     *                                                such as metric or Euclidean ones), this exception will
     *                                                raise because camera movements will be degenerate. To
     *                                                avoid this exception, homographies must be purely
     *                                                projective.
     */
    @Override
    public ImageOfAbsoluteConic estimate() throws LockedException, NotReadyException,
            ImageOfAbsoluteConicEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        try {
            locked = true;
            if (listener != null) {
                listener.onEstimateStart(this);
            }

            final ImageOfAbsoluteConic iac;
            if (zeroSkewness &amp;&amp; principalPointAtOrigin) {
                if (focalDistanceAspectRatioKnown) {
                    iac = estimateZeroSkewnessPrincipalPointAtOriginAndKnownFocalDistanceAspectRatio();
                } else {
                    iac = estimateZeroSkewnessAndPrincipalPointAtOrigin();
                }
            } else if (zeroSkewness) { // &amp;&amp; !mPrincipalPointAtOrigin
                if (focalDistanceAspectRatioKnown) {
                    iac = estimateZeroSkewnessAndKnownFocalDistanceAspectRatio();
                } else {
                    iac = estimateZeroSkewness();
                }
            } else if (principalPointAtOrigin) { // &amp;&amp; !mZeroSkewness
                iac = estimatePrincipalPointAtOrigin();
            } else {
                iac = estimateNoConstraints();
            }

            if (listener != null) {
                listener.onEstimateEnd(this);
            }

            return iac;
        } finally {
            locked = false;
        }
    }

    /**
     * Returns type of IAC estimator.
     *
     * @return type of IAC estimator.
     */
    @Override
    public ImageOfAbsoluteConicEstimatorType getType() {
        return ImageOfAbsoluteConicEstimatorType.LMSE_IAC_ESTIMATOR;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamSparseReconstructor.html#L79">79</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.html#L78">78</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>protected BaseSlamSparseReconstructor(final C configuration, final L listener) {
        super(configuration, listener);
    }

    /**
     * Provides a new accelerometer sample to update SLAM estimation.
     * This method must be called whenever the accelerometer sensor receives new
     * data.
     * If re-constructor is not running, calling this method has no effect.
     *
     * @param timestamp     timestamp of accelerometer sample since epoch time and
     *                      expressed in nanoseconds.
     * @param accelerationX linear acceleration along x-axis expressed in meters
     *                      per squared second (m/s^2).
     * @param accelerationY linear acceleration along y-axis expressed in meters
     *                      per squared second (m/s^2).
     * @param accelerationZ linear acceleration along z-axis expressed in meters
     *                      per squared second (m/s^2).
     */
    public void updateAccelerometerSample(final long timestamp, final float accelerationX, final float accelerationY,
                                          final float accelerationZ) {
        if (slamEstimator != null) {
            slamEstimator.updateAccelerometerSample(timestamp, accelerationX, accelerationY, accelerationZ);
        }
    }

    /**
     * Provides a new accelerometer sample to update SLAM estimation.
     * This method must be called whenever the accelerometer sensor receives new
     * data.
     * If re-constructor is not running, calling this method has no effect.
     *
     * @param timestamp timestamp of accelerometer sample since epoch time and
     *                  expressed in nanoseconds.
     * @param data      array containing x,y,z components of linear acceleration
     *                  expressed in meters per squared second (m/s^2).
     * @throws IllegalArgumentException if provided array does not have length
     *                                  3.
     */
    public void updateAccelerometerSample(final long timestamp, final float[] data) {
        if (slamEstimator != null) {
            slamEstimator.updateAccelerometerSample(timestamp, data);
        }
    }

    /**
     * Provides a new gyroscope sample to update SLAM estimation.
     * If re-constructor is not running, calling this method has no effect.
     *
     * @param timestamp     timestamp of gyroscope sample since epoch time and
     *                      expressed in nanoseconds.
     * @param angularSpeedX angular speed of rotation along x-axis expressed in
     *                      radians per second (rad/s).
     * @param angularSpeedY angular speed of rotation along y-axis expressed in
     *                      radians per second (rad/s).
     * @param angularSpeedZ angular speed of rotation along z-axis expressed in
     *                      radians per second (rad/s).
     */
    public void updateGyroscopeSample(final long timestamp, final float angularSpeedX,
                                      final float angularSpeedY, final float angularSpeedZ) {
        if (slamEstimator != null) {
            slamEstimator.updateGyroscopeSample(timestamp, angularSpeedX, angularSpeedY, angularSpeedZ);
        }
    }

    /**
     * Provides a new gyroscope sample to update SLAM estimation.
     * If re-constructor is not running, calling this method has no effect.
     *
     * @param timestamp timestamp of gyroscope sample since epoch time and
     *                  expressed in nanoseconds.
     * @param data      angular speed of rotation along x,y,z axes expressed in
     *                  radians per second (rad/s).
     * @throws IllegalArgumentException if provided array does not have length
     *                                  3.
     */
    public void updateGyroscopeSample(final long timestamp, final float[] data) {
        if (slamEstimator != null) {
            slamEstimator.updateGyroscopeSample(timestamp, data);
        }
    }

    /**
     * Configures calibration data on SLAM estimator if available.
     */
    protected void setUpCalibrationData() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.html#L562">562</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.html#L596">596</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>x[12] = state.getElementAtIndex(12);
    }

    /**
     * Updates state data of the device by using state matrix obtained from
     * Kalman filter after correction.
     *
     * @param state state matrix obtained from Kalman filter.
     */
    private void updateCorrectedState(final Matrix state) {
        // position
        statePositionX = x[0] = state.getElementAtIndex(0);
        statePositionY = x[1] = state.getElementAtIndex(1);
        statePositionZ = x[2] = state.getElementAtIndex(2);

        // quaternion
        stateQuaternionA = x[3] = state.getElementAtIndex(3);
        stateQuaternionB = x[4] = state.getElementAtIndex(4);
        stateQuaternionC = x[5] = state.getElementAtIndex(5);
        stateQuaternionD = x[6] = state.getElementAtIndex(6);

        stateOrientation.setA(stateQuaternionA);
        stateOrientation.setB(stateQuaternionB);
        stateOrientation.setC(stateQuaternionC);
        stateOrientation.setD(stateQuaternionD);
        stateOrientation.normalize();

        // velocity
        stateVelocityX = x[7] = state.getElementAtIndex(7);
        stateVelocityY = x[8] = state.getElementAtIndex(8);
        stateVelocityZ = x[9] = state.getElementAtIndex(9);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L589">589</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L728">728</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0));
                a.setElementAt(counter, 1, 2.0 * (h11 * h21 - h12 * h22));
                a.setElementAt(counter, 2, Math.pow(h21, 2.0) - Math.pow(h22, 2.0));
                a.setElementAt(counter, 3, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0)
                        + Math.pow(a.getElementAt(counter, 3), 2.0));</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L870">870</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L962">962</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>cameraEstimator.setSuggestSkewnessValueEnabled(
                            configuration.isAdditionalCamerasSuggestSkewnessValueEnabled());
                    cameraEstimator.setSuggestedSkewnessValue(
                            configuration.getAdditionalCamerasSuggestedSkewnessValue());

                    cameraEstimator.setSuggestHorizontalFocalLengthEnabled(
                            configuration.isAdditionalCamerasSuggestHorizontalFocalLengthEnabled());
                    cameraEstimator.setSuggestedHorizontalFocalLengthValue(
                            configuration.getAdditionalCamerasSuggestedHorizontalFocalLengthValue());

                    cameraEstimator.setSuggestVerticalFocalLengthEnabled(
                            configuration.isAdditionalCamerasSuggestVerticalFocalLengthEnabled());
                    cameraEstimator.setSuggestedVerticalFocalLengthValue(
                            configuration.getAdditionalCamerasSuggestedVerticalFocalLengthValue());

                    cameraEstimator.setSuggestAspectRatioEnabled(
                            configuration.isAdditionalCamerasSuggestAspectRatioEnabled());
                    cameraEstimator.setSuggestedAspectRatioValue(
                            configuration.getAdditionalCamerasSuggestedAspectRatioValue());

                    cameraEstimator.setSuggestPrincipalPointEnabled(
                            configuration.isAdditionalCamerasSuggestPrincipalPointEnabled());
                    cameraEstimator.setSuggestedPrincipalPointValue(
                            configuration.getAdditionalCamerasSuggestedPrincipalPointValue());

                    currentCamera = cameraEstimator.estimate();
                    currentCameraCovariance = cameraEstimator.getCovariance();

                    //noinspection unchecked
                    listener.onSamplesAccepted((R) this, viewCount, previousViewTrackedSamples,
                            currentViewTrackedSamples);

                    allPreviousViewSamples.clear();
                    allPreviousViewSamples.addAll(currentViewTrackedSamples);
                    allPreviousViewSamples.addAll(currentViewNewlySpawnedSamples);

                    previousViewTrackedSamples = currentViewTrackedSamples;
                    previousViewId = currentViewId;
                    currentViewId = viewCount;

                } catch (final Exception e) {
                    // camera estimation failed
                    samplesRejected = true;
                }

            } else {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.html#L355">355</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.html#L377">377</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>ConstantVelocityModelStatePredictor.predictWithRotationAdjustment(x, u, deltaTimestamp, x, jacobianPredictionX,
                jacobianPredictionU);

        // update Kalman filter transition matrix taking into account current
        // state
        kalmanFilter.setTransitionMatrix(jacobianPredictionX);

        // update control matrix from control vector jacobian
        kalmanFilter.setControlMatrix(jacobianPredictionU);

        if (calibrationData != null &amp;&amp; calibrationData.getControlMean() != null
                &amp;&amp; calibrationData.getControlCovariance() != null) {
            // if calibrator is available, propagate covariance to set process
            // covariance matrix
            if (normalDist == null) {
                normalDist = new MultivariateNormalDist(STATE_LENGTH);
            }

            try {
                calibrationData.propagateWithControlJacobian(jacobianPredictionU, normalDist);
                // update kalman filter process noise
                final var processNoise = kalmanFilter.getProcessNoiseCov();

                // copy normal dist covariance into processNoise
                normalDist.getCovariance(processNoise);
            } catch (final InvalidCovarianceMatrixException e) {
                // ignore
            }
        }

        try {
            // also predict the state using Kalman filter with current control
            // data
            control.fromArray(u, true);
            updatePredictedState(kalmanFilter.predict(control));

            // copy predicted state to corrected state
            kalmanFilter.getStatePre().copyTo(kalmanFilter.getStatePost());
            kalmanFilter.getErrorCovPre().copyTo(kalmanFilter.getErrorCovPost());

            predictionAvailable = true;
        } catch (final Exception e) {
            error = true;
        }

        lastOrientation.fromRotation(stateOrientation);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L773">773</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1480">1480</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>samples[1].getPoint().getInhomY() - principalPointY);
            rightPoints.add(rightPoint);

            qualityScores[i] = match.getQualityScore();
            i++;
        }

        try {
            final var estimator = FundamentalMatrixRobustEstimator.create(leftPoints, rightPoints, qualityScores,
                    configuration.getRobustFundamentalMatrixEstimatorMethod());
            estimator.setNonRobustFundamentalMatrixEstimatorMethod(
                    configuration.getNonRobustFundamentalMatrixEstimatorMethod());
            estimator.setResultRefined(configuration.isFundamentalMatrixRefined());
            estimator.setCovarianceKept(configuration.isFundamentalMatrixCovarianceKept());
            estimator.setConfidence(configuration.getFundamentalMatrixConfidence());
            estimator.setMaxIterations(configuration.getFundamentalMatrixMaxIterations());

            switch (configuration.getRobustFundamentalMatrixEstimatorMethod()) {
                case LMEDS:
                    ((LMedSFundamentalMatrixRobustEstimator) estimator).setStopThreshold(
                            configuration.getFundamentalMatrixThreshold());
                    break;
                case MSAC:
                    ((MSACFundamentalMatrixRobustEstimator) estimator).setThreshold(
                            configuration.getFundamentalMatrixThreshold());
                    break;
                case PROMEDS:
                    ((PROMedSFundamentalMatrixRobustEstimator) estimator).setStopThreshold(
                            configuration.getFundamentalMatrixThreshold());
                    break;
                case PROSAC:</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L2079">2079</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L1061">1061</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var samples2 = currentEstimatedFundamentalMatrix.getRightSamples();

        final var points1 = new ArrayList&lt;Point2D&gt;();
        final var points2 = new ArrayList&lt;Point2D&gt;();
        final var length = samples1.size();
        for (var i = 0; i &lt; length; i++) {
            final var sample1 = samples1.get(i);
            final var sample2 = samples2.get(i);

            final var point1 = sample1.getPoint();
            final var point2 = sample2.getPoint();

            points1.add(point1);
            points2.add(point2);
        }

        try {
            final var estimator = new EssentialMatrixInitialCamerasEstimator(fundamentalMatrix, intrinsic1, intrinsic2,
                    points1, points2);

            estimator.setCorrectorType(configuration.getInitialCamerasCorrectorType());
            estimator.setPointsTriangulated(true);
            estimator.setValidTriangulatedPointsMarked(configuration.getInitialCamerasMarkValidTriangulatedPoints());

            estimator.estimate();

            // store cameras
            final var camera1 = estimator.getEstimatedLeftCamera();
            final var camera2 = estimator.getEstimatedRightCamera();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L231">231</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L380">380</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L525">525</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L665">665</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a = new Matrix(MIN_REQUIRED_EQUATIONS, 6);
            }

            var counter = 0;
            ProjectiveTransformation2D t = null;
            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            for (final var homography : homographies) {
                // convert homography into projective so it can be normalized
                homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);
                a.setElementAt(counter, 1, h11 * h22 + h21 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L991">991</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L1106">1106</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>homography.asMatrix(h);
                    if (t == null) {
                        t = new ProjectiveTransformation2D(h);
                    } else {
                        t.setT(h);
                    }

                    // normalize
                    t.normalize();

                    // obtain elements of projective transformation matrix
                    // there is no need to retrieve internal matrix h, as we already
                    // hold a reference
                    h11 = h.getElementAt(0, 0);
                    h12 = h.getElementAt(0, 1);

                    h21 = h.getElementAt(1, 0);
                    h22 = h.getElementAt(1, 1);

                    h31 = h.getElementAt(2, 0);
                    h32 = h.getElementAt(2, 1);

                    // fill first equation
                    a.setElementAt(counter, 0, h11 * h12 + h21 * h22 / sqrAspectRatio);
                    a.setElementAt(counter, 1, h31 * h32);

                    // normalize row
                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                            + Math.pow(a.getElementAt(counter, 1), 2.0));</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1129">1129</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1851">1851</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>estimator.setAspectRatio(configuration.getPairedCamerasAspectRatio());
            estimator.estimate();

            final var camera1 = estimator.getEstimatedLeftCamera();
            final var camera2 = estimator.getEstimatedRightCamera();

            camera1.decompose();
            camera2.decompose();

            final var intrinsicZeroPrincipalPoint1 = camera1.getIntrinsicParameters();
            final var intrinsicZeroPrincipalPoint2 = camera2.getIntrinsicParameters();

            final var principalPointX = configuration.getPrincipalPointX();
            final var principalPointY = configuration.getPrincipalPointY();

            final var intrinsic1 = new PinholeCameraIntrinsicParameters(intrinsicZeroPrincipalPoint1);
            intrinsic1.setHorizontalPrincipalPoint(intrinsic1.getHorizontalPrincipalPoint() + principalPointX);
            intrinsic1.setVerticalPrincipalPoint(intrinsic1.getVerticalPrincipalPoint() + principalPointY);
            camera1.setIntrinsicParameters(intrinsic1);

            final var intrinsic2 = new PinholeCameraIntrinsicParameters(intrinsicZeroPrincipalPoint2);
            intrinsic2.setHorizontalPrincipalPoint(intrinsic2.getHorizontalPrincipalPoint() + principalPointX);
            intrinsic2.setVerticalPrincipalPoint(intrinsic2.getVerticalPrincipalPoint() + principalPointY);
            camera2.setIntrinsicParameters(intrinsic2);

            previousMetricEstimatedCamera = new EstimatedCamera();
            previousMetricEstimatedCamera.setCamera(camera1);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.html#L325">325</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/SlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/SlamEstimator.html#L349">349</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>ConstantVelocityModelStatePredictor.predict(x, u, deltaTimestamp, x, jacobianPredictionX, jacobianPredictionU);

        // update Kalman filter transition matrix taking into account current
        // state
        kalmanFilter.setTransitionMatrix(jacobianPredictionX);

        // update control matrix from control vector jacobian
        kalmanFilter.setControlMatrix(jacobianPredictionU);

        if (calibrationData != null &amp;&amp; calibrationData.getControlMean() != null
                &amp;&amp; calibrationData.getControlCovariance() != null) {
            // if calibrator is available, propagate covariance to set process
            // covariance matrix
            if (normalDist == null) {
                normalDist = new MultivariateNormalDist(STATE_LENGTH);
            }

            try {
                calibrationData.propagateWithControlJacobian(jacobianPredictionU, normalDist);
                // update Kalman filter process noise
                final var processNoise = kalmanFilter.getProcessNoiseCov();

                // copy normal dist covariance into processNoise
                normalDist.getCovariance(processNoise);
            } catch (final InvalidCovarianceMatrixException e) {
                // ignore
            }
        }

        try {
            // also predict the state using Kalman filter with current control
            // data
            control.fromArray(u, true);
            updatePredictedState(kalmanFilter.predict(control));

            // copy predicted state to corrected state
            kalmanFilter.getStatePre().copyTo(kalmanFilter.getStatePost());
            kalmanFilter.getErrorCovPre().copyTo(kalmanFilter.getErrorCovPost());

            predictionAvailable = true;
        } catch (final Exception e) {
            error = true;
        }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/HomographyDecomposer.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/HomographyDecomposer.html#L661">661</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/HomographyDecomposer.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/HomographyDecomposer.html#L733">733</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>private double decomposeFromThreeDifferentSingularValuesNegative(
            final double d1, final double d2, final double d3, final double[] n, final Matrix r, final double[] t,
            final boolean positive1, final boolean positive3) {
        final var d1Sqr = d1 * d1;
        final var d2Sqr = d2 * d2;
        final var d3Sqr = d3 * d3;

        // compute plane normal
        final var denom = d1Sqr - d3Sqr;

        var x1 = Math.sqrt((d1Sqr - d2Sqr) / denom);
        if (!positive1) {
            x1 = -x1;
        }

        final var x2 = 0.0;

        var x3 = Math.sqrt((d2Sqr - d3Sqr) / denom);
        if (!positive3) {
            x3 = -x3;
        }

        // fill plane normal solution
        n[0] = x1;
        n[1] = x2;
        n[2] = x3;

        // compute rotation
        final var x1Sqr = x1 * x1;
        final var x3Sqr = x3 * x3;

        final var sinTheta = (d1 + d3) * x1 * x3 / d2;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1358">1358</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L2061">2061</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Estimates initial cameras and reconstructed points using the essential
     * matrix and provided intrinsic parameters that must have been set during
     * offline calibration.
     *
     * @param intrinsic1 intrinsic parameters of 1st camera.
     * @param intrinsic2 intrinsic parameters of 2nd camera.
     * @return true if cameras and points could be estimated, false if something
     * failed.
     */
    private boolean estimateInitialCamerasAndPointsEssential(
            final PinholeCameraIntrinsicParameters intrinsic1, final PinholeCameraIntrinsicParameters intrinsic2) {
        final var fundamentalMatrix = currentEstimatedFundamentalMatrix.getFundamentalMatrix();

        // use all points used for fundamental matrix estimation
        final var samples1 = currentEstimatedFundamentalMatrix.getLeftSamples();
        final var samples2 = currentEstimatedFundamentalMatrix.getRightSamples();

        final var points1 = new ArrayList&lt;Point2D&gt;();
        final var points2 = new ArrayList&lt;Point2D&gt;();
        final var length = samples1.size();
        for (var i = 0; i &lt; length; i++) {
            final var sample1 = samples1.get(i);
            final var sample2 = samples2.get(i);

            final var point1 = sample1.getPoint();
            final var point2 = sample2.getPoint();

            points1.add(point1);
            points2.add(point2);
        }

        try {
            final var estimator = new EssentialMatrixInitialCamerasEstimator(fundamentalMatrix, intrinsic1, intrinsic2,
                    points1, points2);

            estimator.setCorrectorType(configuration.getPairedCamerasCorrectorType());</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1691">1691</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L701">701</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>break;
            }

            final var fundamentalMatrixEstimator = new PlanarBestFundamentalMatrixEstimatorAndReconstructor();
            fundamentalMatrixEstimator.setHomographyEstimator(homographyEstimator);
            fundamentalMatrixEstimator.setLeftAndRightPoints(leftPoints, rightPoints);
            fundamentalMatrixEstimator.setQualityScores(qualityScores);

            var intrinsic1 = configuration.getInitialIntrinsic1();
            var intrinsic2 = configuration.getInitialIntrinsic1();
            if (intrinsic1 == null &amp;&amp; intrinsic2 == null) {
                // estimate homography
                final var homography = homographyEstimator.estimate();

                // estimate intrinsic parameters using the Image of Absolute
                // Conic (IAC)
                final var homographies = new ArrayList&lt;Transformation2D&gt;();
                homographies.add(homography);

                final var iacEstimator = new LMSEImageOfAbsoluteConicEstimator(homographies);
                final var iac = iacEstimator.estimate();

                intrinsic1 = intrinsic2 = iac.getIntrinsicParameters();

            } else if (intrinsic1 == null) { //&amp;&amp; intrinsic2 != null
                intrinsic1 = intrinsic2;
            } else if (intrinsic2 == null) { //&amp;&amp; intrinsic1 != null
                intrinsic2 = intrinsic1;
            }
            fundamentalMatrixEstimator.setLeftIntrinsics(intrinsic1);
            fundamentalMatrixEstimator.setRightIntrinsics(intrinsic2);

            fundamentalMatrixEstimator.estimateAndReconstruct();

            final var fundamentalMatrix = fundamentalMatrixEstimator.getFundamentalMatrix();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1286">1286</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1394">1394</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>estimator.setAspectRatio(configuration.getPairedCamerasAspectRatio());
            estimator.setCorrectorType(configuration.getPairedCamerasCorrectorType());
            estimator.setPointsTriangulated(true);
            estimator.setValidTriangulatedPointsMarked(configuration.getPairedCamerasMarkValidTriangulatedPoints());

            estimator.estimate();

            // store cameras
            final var camera1 = estimator.getEstimatedLeftCamera();
            final var camera2 = estimator.getEstimatedRightCamera();

            previousMetricEstimatedCamera = new EstimatedCamera();
            previousMetricEstimatedCamera.setCamera(camera1);

            currentMetricEstimatedCamera = new EstimatedCamera();
            currentMetricEstimatedCamera.setCamera(camera2);

            // store points
            final var triangulatedPoints = estimator.getTriangulatedPoints();
            final var validTriangulatedPoints = estimator.getValidTriangulatedPoints();

            metricReconstructedPoints = new ArrayList&lt;&gt;();
            final var size = triangulatedPoints.size();
            for (var i = 0; i &lt; size; i++) {
                final var reconstructedPoint = new ReconstructedPoint3D();
                reconstructedPoint.setPoint(triangulatedPoints.get(i));
                reconstructedPoint.setInlier(validTriangulatedPoints.get(i));
                metricReconstructedPoints.add(reconstructedPoint);
            }

            return transformPairOfCamerasAndPoints(isInitialPairOfViews, hasAbsoluteOrientation());</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.html#L355">355</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.html#L325">325</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/slam/SlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/SlamEstimator.html#L349">349</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>ConstantVelocityModelStatePredictor.predictWithRotationAdjustment(x, u, deltaTimestamp, x, jacobianPredictionX,
                jacobianPredictionU);

        // update Kalman filter transition matrix taking into account current
        // state
        kalmanFilter.setTransitionMatrix(jacobianPredictionX);

        // update control matrix from control vector jacobian
        kalmanFilter.setControlMatrix(jacobianPredictionU);

        if (calibrationData != null &amp;&amp; calibrationData.getControlMean() != null
                &amp;&amp; calibrationData.getControlCovariance() != null) {
            // if calibrator is available, propagate covariance to set process
            // covariance matrix
            if (normalDist == null) {
                normalDist = new MultivariateNormalDist(STATE_LENGTH);
            }

            try {
                calibrationData.propagateWithControlJacobian(jacobianPredictionU, normalDist);
                // update kalman filter process noise
                final var processNoise = kalmanFilter.getProcessNoiseCov();

                // copy normal dist covariance into processNoise
                normalDist.getCovariance(processNoise);
            } catch (final InvalidCovarianceMatrixException e) {
                // ignore
            }
        }

        try {
            // also predict the state using Kalman filter with current control
            // data
            control.fromArray(u, true);
            updatePredictedState(kalmanFilter.predict(control));

            // copy predicted state to corrected state
            kalmanFilter.getStatePre().copyTo(kalmanFilter.getStatePost());
            kalmanFilter.getErrorCovPre().copyTo(kalmanFilter.getErrorCovPost());

            predictionAvailable = true;
        } catch (final Exception e) {
            error = true;
        }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.html#L377">377</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.html#L325">325</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/slam/SlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/SlamEstimator.html#L349">349</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>StatePredictor.predictWithRotationAdjustment(x, u, deltaTimestamp, x, jacobianPredictionX, jacobianPredictionU);

        // update Kalman filter transition matrix taking into account current
        // state
        kalmanFilter.setTransitionMatrix(jacobianPredictionX);

        // update control matrix from control vector jacobian
        kalmanFilter.setControlMatrix(jacobianPredictionU);

        if (calibrationData != null &amp;&amp; calibrationData.getControlMean() != null
                &amp;&amp; calibrationData.getControlCovariance() != null) {
            // if calibrator is available, propagate covariance to set process
            // covariance matrix
            if (normalDist == null) {
                normalDist = new MultivariateNormalDist(STATE_LENGTH);
            }

            try {
                calibrationData.propagateWithControlJacobian(jacobianPredictionU, normalDist);
                // update kalman filter process noise
                final var processNoise = kalmanFilter.getProcessNoiseCov();

                // copy normal dist covariance into processNoise
                normalDist.getCovariance(processNoise);
            } catch (final InvalidCovarianceMatrixException e) {
                // ignore
            }
        }

        try {
            // also predict the state using Kalman filter with current control
            // data
            control.fromArray(u, true);
            updatePredictedState(kalmanFilter.predict(control));

            // copy predicted state to corrected state
            kalmanFilter.getStatePre().copyTo(kalmanFilter.getStatePost());
            kalmanFilter.getErrorCovPre().copyTo(kalmanFilter.getErrorCovPost());

            predictionAvailable = true;
        } catch (final Exception e) {
            error = true;
        }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1262">1262</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1985">1985</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var fundamentalMatrix = currentEstimatedFundamentalMatrix.getFundamentalMatrix();

        // use inlier points used for fundamental matrix estimation
        final var samples1 = currentEstimatedFundamentalMatrix.getLeftSamples();
        final var samples2 = currentEstimatedFundamentalMatrix.getRightSamples();

        final var points1 = new ArrayList&lt;Point2D&gt;();
        final var points2 = new ArrayList&lt;Point2D&gt;();
        final var length = samples1.size();
        for (var i = 0; i &lt; length; i++) {
            final var sample1 = samples1.get(i);
            final var sample2 = samples2.get(i);

            final var point1 = sample1.getPoint();
            final var point2 = sample2.getPoint();

            points1.add(point1);
            points2.add(point2);
        }

        try {
            final var estimator = new DualImageOfAbsoluteConicInitialCamerasEstimator(fundamentalMatrix, points1,
                    points2);
            estimator.setPrincipalPoint(configuration.getPrincipalPointX(), configuration.getPrincipalPointY());
            estimator.setAspectRatio(configuration.getPairedCamerasAspectRatio());</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1074">1074</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L797">797</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>estimator.setAspectRatio(configuration.getPairedCamerasAspectRatio());
            estimator.estimate();

            final var camera1 = estimator.getEstimatedLeftCamera();
            final var camera2 = estimator.getEstimatedRightCamera();

            camera1.decompose();
            camera2.decompose();

            final var intrinsicZeroPrincipalPoint1 = camera1.getIntrinsicParameters();
            final var intrinsicZeroPrincipalPoint2 = camera2.getIntrinsicParameters();

            final var principalPointX = configuration.getPrincipalPointX();
            final var principalPointY = configuration.getPrincipalPointY();

            final var intrinsic1 = new PinholeCameraIntrinsicParameters(intrinsicZeroPrincipalPoint1);
            intrinsic1.setHorizontalPrincipalPoint(intrinsic1.getHorizontalPrincipalPoint() + principalPointX);
            intrinsic1.setVerticalPrincipalPoint(intrinsic1.getVerticalPrincipalPoint() + principalPointY);

            final var intrinsic2 = new PinholeCameraIntrinsicParameters(intrinsicZeroPrincipalPoint2);
            intrinsic2.setHorizontalPrincipalPoint(intrinsic2.getHorizontalPrincipalPoint() + principalPointX);
            intrinsic2.setVerticalPrincipalPoint(intrinsic2.getVerticalPrincipalPoint() + principalPointY);

            // fix fundamental matrix to account for principal point different
            // from zero
            fixFundamentalMatrix(fundamentalMatrix, intrinsicZeroPrincipalPoint1, intrinsicZeroPrincipalPoint2,
                    intrinsic1, intrinsic2);

            return estimateInitialCamerasAndPointsEssential(intrinsic1, intrinsic2)</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamSparseReconstructor.html#L306">306</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/KnownBaselineSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/KnownBaselineSparseReconstructor.html#L121">121</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>metricReconstructedPoints3D.add(reconstructedPoint.getPoint());
            }

            final var euclideanReconstructedPoints3D = scaleTransformation.transformPointsAndReturnNew(
                    metricReconstructedPoints3D);

            // set scaled points into result
            activeEuclideanReconstructedPoints = new ArrayList&lt;&gt;();
            ReconstructedPoint3D euclideanPoint;
            ReconstructedPoint3D metricPoint;
            for (var i = 0; i &lt; numPoints; i++) {
                metricPoint = activeMetricReconstructedPoints.get(i);

                euclideanPoint = new ReconstructedPoint3D();
                euclideanPoint.setId(metricPoint.getId());
                euclideanPoint.setPoint(euclideanReconstructedPoints3D.get(i));
                euclideanPoint.setInlier(metricPoint.isInlier());
                euclideanPoint.setQualityScore(metricPoint.getQualityScore());
                if (metricPoint.getCovariance() != null) {
                    euclideanPoint.setCovariance(metricPoint.getCovariance().multiplyByScalarAndReturnNew(sqrScale));
                }
                euclideanPoint.setColorData(metricPoint.getColorData());

                activeEuclideanReconstructedPoints.add(euclideanPoint);
            }

            return true;
        } catch (final Exception e) {
            failed = true;
            //noinspection unchecked
            listener.onFail((R) this);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructor.html#L287">287</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/PairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PairedViewsSparseReconstructor.html#L103">103</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>referenceEuclideanTransformation.setRotation(invEuclideanCameraRotation);
            referenceEuclideanTransformation.setTranslation(lastEuclideanCameraCenter);
        }

        try {
            // transform cameras
            final var previousEuclideanCamera = referenceEuclideanTransformation.transformAndReturnNew(
                    previousMetricCamera);
            final var currentEuclideanCamera = referenceEuclideanTransformation.transformAndReturnNew(
                    currentMetricCamera);

            previousEuclideanEstimatedCamera = new EstimatedCamera();
            previousEuclideanEstimatedCamera.setCamera(previousEuclideanCamera);
            previousEuclideanEstimatedCamera.setViewId(previousMetricEstimatedCamera.getViewId());
            previousEuclideanEstimatedCamera.setQualityScore(previousMetricEstimatedCamera.getQualityScore());
            if (previousMetricEstimatedCamera.getCovariance() != null) {
                previousEuclideanEstimatedCamera.setCovariance(previousMetricEstimatedCamera.getCovariance()
                        .multiplyByScalarAndReturnNew(sqrScale));
            }

            currentEuclideanEstimatedCamera = new EstimatedCamera();
            currentEuclideanEstimatedCamera.setCamera(currentEuclideanCamera);
            currentEuclideanEstimatedCamera.setViewId(currentMetricEstimatedCamera.getViewId());
            currentEuclideanEstimatedCamera.setQualityScore(currentMetricEstimatedCamera.getQualityScore());
            if (currentMetricEstimatedCamera.getCovariance() != null) {
                currentEuclideanEstimatedCamera.setCovariance(currentMetricEstimatedCamera.getCovariance()
                        .multiplyByScalarAndReturnNew(sqrScale));
            }

            // transform points
            euclideanReconstructedPoints = new ArrayList&lt;&gt;();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructorConfiguration.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructorConfiguration.html#L92">92</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSlamSparseReconstructorConfiguration.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamSparseReconstructorConfiguration.html#L92">92</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public BaseSlamPairedViewsSparseReconstructorConfiguration() {
        // initialize default covariance
        try {
            cameraPositionCovariance = Matrix.identity(Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH,
                    Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH);
            cameraPositionCovariance.multiplyByScalar(DEFAULT_CAMERA_POSITION_VARIANCE);
        } catch (final AlgebraException ignore) {
            // never happens
        }
    }

    /**
     * Gets calibration data for accelerometer and gyroscope.
     * This data is usually captured and estimated in an offline step previous to the
     * actual scene reconstruction.
     * Calibration data is usually obtained by keeping the system in a constant state
     * of motion (e.g. acceleration and rotation).
     * If this is null, no calibration data will be used.
     *
     * @return calibration data or null.
     */
    public C getCalibrationData() {
        return calibrationData;
    }

    /**
     * Specifies calibration data for accelerometer and gyroscope.
     * This data is usually captured and estimated in an offline step previous to the
     * actual scene reconstruction.
     * Calibration data is usually obtained by keeping the system in a constant state
     * of motion (e.g. acceleration and rotation).
     * If set to null, no calibration data will be used.
     *
     * @param calibrationData calibration data or null.
     * @return this instance so that method can be easily chained.
     */
    public T setCalibrationData(final C calibrationData) {
        this.calibrationData = calibrationData;

        //noinspection unchecked
        return (T) this;
    }

    /**
     * Gets matrix containing covariance of measured camera positions.
     * This should usually be an &quot;almost&quot; diagonal matrix, where diagonal elements are
     * close to the position estimation error variance.
     * Values of this matrix are device specific and depends on factors such as
     * resolution of images, pictures quality, gyroscope and accelerometer accuracy.
     * This matrix must be a 3x3 symmetric positive definite matrix.
     *
     * @return covariance of measured camera positions.
     */
    public Matrix getCameraPositionCovariance() {
        return cameraPositionCovariance;
    }

    /**
     * Sets matrix containing covariance of measured camera positions.
     * This should usually be an &quot;almost&quot; diagonal matrix, where diagonal elements are
     * close to the position estimation error variance.
     * Values of this matrix are device specific and depends on factors such as
     * resolution of images, pictures quality, gyroscope and accelerometer accuracy.
     * This matrix must be 3x3 symmetric positive definite matrix.
     *
     * @param cameraPositionCovariance covariance of measured camera positions.
     * @return this instance so that method can be easily chained.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public T setCameraPositionCovariance(final Matrix cameraPositionCovariance) {
        if (cameraPositionCovariance.getRows() != Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH ||
                cameraPositionCovariance.getColumns() != Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH) {
            throw new IllegalArgumentException();
        }

        this.cameraPositionCovariance = cameraPositionCovariance;

        //noinspection unchecked
        return (T) this;
    }

    /**
     * Sets independent variance of coordinates of measured camera positions.
     * When using this method, camera position covariance matrix is set as a diagonal
     * matrix whose diagonal elements are equal to provided value.
     *
     * @param variance variance of coordinates of measured camera positions.
     * @return this instance so that method can be easily chained.
     */
    public T setCameraPositionVariance(final double variance) {
        try {
            cameraPositionCovariance = Matrix.identity(Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH,
                    Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH);
            cameraPositionCovariance.multiplyByScalar(variance);
        } catch (final AlgebraException ignore) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L766">766</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L870">870</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>cameraEstimator.setSuggestSkewnessValueEnabled(
                                configuration.isAdditionalCamerasSuggestSkewnessValueEnabled());
                        cameraEstimator.setSuggestedSkewnessValue(
                                configuration.getAdditionalCamerasSuggestedSkewnessValue());

                        cameraEstimator.setSuggestHorizontalFocalLengthEnabled(
                                configuration.isAdditionalCamerasSuggestHorizontalFocalLengthEnabled());
                        cameraEstimator.setSuggestedHorizontalFocalLengthValue(
                                configuration.getAdditionalCamerasSuggestedHorizontalFocalLengthValue());

                        cameraEstimator.setSuggestVerticalFocalLengthEnabled(
                                configuration.isAdditionalCamerasSuggestVerticalFocalLengthEnabled());
                        cameraEstimator.setSuggestedVerticalFocalLengthValue(
                                configuration.getAdditionalCamerasSuggestedVerticalFocalLengthValue());

                        cameraEstimator.setSuggestAspectRatioEnabled(
                                configuration.isAdditionalCamerasSuggestAspectRatioEnabled());
                        cameraEstimator.setSuggestedAspectRatioValue(
                                configuration.getAdditionalCamerasSuggestedAspectRatioValue());

                        cameraEstimator.setSuggestPrincipalPointEnabled(
                                configuration.isAdditionalCamerasSuggestPrincipalPointEnabled());
                        cameraEstimator.setSuggestedPrincipalPointValue(
                                configuration.getAdditionalCamerasSuggestedPrincipalPointValue());

                        currentCamera = cameraEstimator.estimate();
                        currentCameraCovariance = cameraEstimator.getCovariance();

                        //noinspection unchecked
                        listener.onSamplesAccepted((R) this, viewCount, previousViewTrackedSamples,
                                currentViewTrackedSamples);

                        allPreviousViewSamples.clear();
                        allPreviousViewSamples.addAll(currentViewTrackedSamples);
                        allPreviousViewSamples.addAll(currentViewNewlySpawnedSamples);

                        previousViewTrackedSamples = currentViewTrackedSamples;
                        previousViewId = currentViewId;
                        currentViewId = viewCount;
                    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.html#L518">518</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.html#L549">549</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>private void updatePredictedState(Matrix state) {
        // position
        statePositionX = x[0];
        x[0] = state.getElementAtIndex(0);
        statePositionY = x[1];
        x[1] = state.getElementAtIndex(1);
        statePositionZ = x[2];
        x[2] = state.getElementAtIndex(2);

        // quaternion state predictor is more reliable than Kalman filter, for
        // that reason we ignore predicted quaternion values on Kalman filter and
        // simply keep predicted ones. Besides, typically gyroscope samples are
        // much more reliable than accelerometer ones. For that reason state
        // elements corresponding to quaternion (3 to 6) are not copied into mX
        // array.
        stateQuaternionA = x[3];
        stateQuaternionB = x[4];
        stateQuaternionC = x[5];
        stateQuaternionD = x[6];

        stateOrientation.setA(stateQuaternionA);
        stateOrientation.setB(stateQuaternionB);
        stateOrientation.setC(stateQuaternionC);
        stateOrientation.setD(stateQuaternionD);

        // velocity
        stateVelocityX = x[7];
        x[7] = state.getElementAtIndex(7);
        stateVelocityY = x[8];
        x[8] = state.getElementAtIndex(8);
        stateVelocityZ = x[9];
        x[9] = state.getElementAtIndex(9);

        // linear acceleration
        stateAccelerationX = accumulatedAccelerationSampleX;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseAbsoluteOrientationSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseAbsoluteOrientationSlamSparseReconstructor.html#L221">221</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamSparseReconstructor.html#L309">309</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var euclideanReconstructedPoints3D = scaleAndOrientationTransformation.transformPointsAndReturnNew(
                    metricReconstructedPoints3D);

            // set scaled points into result
            activeEuclideanReconstructedPoints = new ArrayList&lt;&gt;();
            ReconstructedPoint3D euclideanPoint;
            ReconstructedPoint3D metricPoint;
            for (var i = 0; i &lt; numPoints; i++) {
                metricPoint = activeMetricReconstructedPoints.get(i);

                euclideanPoint = new ReconstructedPoint3D();
                euclideanPoint.setId(metricPoint.getId());
                euclideanPoint.setPoint(euclideanReconstructedPoints3D.get(i));
                euclideanPoint.setInlier(metricPoint.isInlier());
                euclideanPoint.setQualityScore(metricPoint.getQualityScore());
                if (metricPoint.getCovariance() != null) {
                    euclideanPoint.setCovariance(metricPoint.getCovariance().multiplyByScalarAndReturnNew(sqrScale));
                }
                euclideanPoint.setColorData(metricPoint.getColorData());

                activeEuclideanReconstructedPoints.add(euclideanPoint);
            }

            return true;

        } catch (final Exception e) {
            failed = true;
            //noinspection unchecked
            listener.onFail((R) this);

            return false;
        }
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L711">711</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L731">731</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L986">986</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L1007">1007</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 3, h31 * h32);

                    // normalize row
                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                            + Math.pow(a.getElementAt(counter, 1), 2.0)
                            + Math.pow(a.getElementAt(counter, 2), 2.0)
                            + Math.pow(a.getElementAt(counter, 3), 2.0));
                    factor = weight / rowNorm;

                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);
                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);
                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);
                    a.setElementAt(counter, 3, a.getElementAt(counter, 3) * factor);

                    counter++;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/AffineFundamentalMatrixEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/AffineFundamentalMatrixEstimator.html#L189">189</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/SevenPointsFundamentalMatrixEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/SevenPointsFundamentalMatrixEstimator.html#L238">238</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>if (listener != null) {
            listener.onEstimateStart(this);
        }

        final var nPoints = leftPoints.size();

        try {
            ProjectiveTransformation2D leftNormalization = null;
            ProjectiveTransformation2D rightNormalization = null;
            final List&lt;Point2D&gt; leftPoints;
            final List&lt;Point2D&gt; rightPoints;
            if (normalizePoints) {
                // normalize points on left view
                final var normalizer = new Point2DNormalizer(this.leftPoints);
                normalizer.compute();

                leftNormalization = normalizer.getTransformation();

                // normalize points on right view
                normalizer.setPoints(this.rightPoints);
                normalizer.compute();

                rightNormalization = normalizer.getTransformation();

                // normalize to increase accuracy
                leftNormalization.normalize();
                rightNormalization.normalize();

                leftPoints = leftNormalization.transformPointsAndReturnNew(this.leftPoints);
                rightPoints = rightNormalization.transformPointsAndReturnNew(this.rightPoints);
            } else {
                leftPoints = this.leftPoints;
                rightPoints = this.rightPoints;
            }

            final Matrix a;
            if (isLMSESolutionAllowed()) {
                a = new Matrix(nPoints, 5);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/MSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/MSACFundamentalMatrixRobustEstimator.html#L232">232</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/PROMedSFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PROMedSFundamentalMatrixRobustEstimator.html#L501">501</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.html#L513">513</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

            @Override
            public int getTotalSamples() {
                return leftPoints.size();
            }

            @Override
            public int getSubsetSize() {
                return getMinRequiredPoints();
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;FundamentalMatrix&gt; solutions) {

                subsetLeftPoints.clear();
                subsetRightPoints.clear();
                for (final var samplesIndex : samplesIndices) {
                    subsetLeftPoints.add(leftPoints.get(samplesIndex));
                    subsetRightPoints.add(rightPoints.get(samplesIndex));
                }

                nonRobustEstimate(solutions, subsetLeftPoints, subsetRightPoints);
            }

            @Override
            public double computeResidual(final FundamentalMatrix currentEstimation, final int i) {
                final var leftPoint = leftPoints.get(i);
                final var rightPoint = rightPoints.get(i);
                return residual(currentEstimation, leftPoint, rightPoint);
            }

            @Override
            public boolean isReady() {
                return MSACFundamentalMatrixRobustEstimator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/MSACDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/MSACDualAbsoluteQuadricRobustEstimator.html#L169">169</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROMedSDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSDualAbsoluteQuadricRobustEstimator.html#L320">320</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROSACDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACDualAbsoluteQuadricRobustEstimator.html#L286">286</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/RANSACDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/RANSACDualAbsoluteQuadricRobustEstimator.html#L168">168</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

            @Override
            public int getTotalSamples() {
                return cameras.size();
            }

            @Override
            public int getSubsetSize() {
                return daqEstimator.getMinNumberOfRequiredCameras();
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;DualAbsoluteQuadric&gt; solutions) {
                subsetCameras.clear();
                for (final var samplesIndex : samplesIndices) {
                    subsetCameras.add(cameras.get(samplesIndex));
                }

                try {
                    daqEstimator.setLMSESolutionAllowed(false);
                    daqEstimator.setCameras(subsetCameras);

                    final var daq = daqEstimator.estimate();
                    solutions.add(daq);
                } catch (final Exception e) {
                    // if anything fails, no solution is added
                }
            }

            @Override
            public double computeResidual(final DualAbsoluteQuadric currentEstimation, final int i) {
                return residual(currentEstimation, cameras.get(i));
            }

            @Override
            public boolean isReady() {
                return MSACDualAbsoluteQuadricRobustEstimator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/MSACImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/MSACImageOfAbsoluteConicRobustEstimator.html#L178">178</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROMedSImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSImageOfAbsoluteConicRobustEstimator.html#L331">331</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROSACImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACImageOfAbsoluteConicRobustEstimator.html#L300">300</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>}

            @Override
            public int getTotalSamples() {
                return homographies.size();
            }

            @Override
            public int getSubsetSize() {
                return iacEstimator.getMinNumberOfRequiredHomographies();
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;ImageOfAbsoluteConic&gt; solutions) {
                subsetHomographies.clear();
                for (final var samplesIndex : samplesIndices) {
                    subsetHomographies.add(homographies.get(samplesIndex));
                }

                try {
                    iacEstimator.setLMSESolutionAllowed(false);
                    iacEstimator.setHomographies(subsetHomographies);

                    final var iac = iacEstimator.estimate();
                    solutions.add(iac);
                } catch (final Exception e) {
                    // if anything fails, no solution is added
                }
            }

            @Override
            public double computeResidual(final ImageOfAbsoluteConic currentEstimation, final int i) {
                return residual(currentEstimation, homographies.get(i));
            }

            @Override
            public boolean isReady() {
                return MSACImageOfAbsoluteConicRobustEstimator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/LMedSFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/LMedSFundamentalMatrixRobustEstimator.html#L270">270</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/MSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/MSACFundamentalMatrixRobustEstimator.html#L234">234</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/PROMedSFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PROMedSFundamentalMatrixRobustEstimator.html#L503">503</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.html#L515">515</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@Override
            public int getTotalSamples() {
                return leftPoints.size();
            }

            @Override
            public int getSubsetSize() {
                return getMinRequiredPoints();
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;FundamentalMatrix&gt; solutions) {

                subsetLeftPoints.clear();
                subsetRightPoints.clear();
                for (final var samplesIndex : samplesIndices) {
                    subsetLeftPoints.add(leftPoints.get(samplesIndex));
                    subsetRightPoints.add(rightPoints.get(samplesIndex));
                }

                nonRobustEstimate(solutions, subsetLeftPoints, subsetRightPoints);
            }

            @Override
            public double computeResidual(final FundamentalMatrix currentEstimation, final int i) {
                final var leftPoint = leftPoints.get(i);
                final var rightPoint = rightPoints.get(i);
                return residual(currentEstimation, leftPoint, rightPoint);
            }

            @Override
            public boolean isReady() {
                return LMedSFundamentalMatrixRobustEstimator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/MSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/MSACFundamentalMatrixRobustEstimator.html#L221">221</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/RANSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/RANSACFundamentalMatrixRobustEstimator.html#L298">298</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var innerEstimator = new MSACRobustEstimator&lt;FundamentalMatrix&gt;(new MSACRobustEstimatorListener&lt;&gt;() {

            // subset of left points
            private final List&lt;Point2D&gt; subsetLeftPoints = new ArrayList&lt;&gt;();

            // subset of right points
            private final List&lt;Point2D&gt; subsetRightPoints = new ArrayList&lt;&gt;();

            @Override
            public double getThreshold() {
                return threshold;
            }

            @Override
            public int getTotalSamples() {
                return leftPoints.size();
            }

            @Override
            public int getSubsetSize() {
                return getMinRequiredPoints();
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;FundamentalMatrix&gt; solutions) {

                subsetLeftPoints.clear();
                subsetRightPoints.clear();
                for (final var samplesIndex : samplesIndices) {
                    subsetLeftPoints.add(leftPoints.get(samplesIndex));
                    subsetRightPoints.add(rightPoints.get(samplesIndex));
                }

                nonRobustEstimate(solutions, subsetLeftPoints, subsetRightPoints);
            }

            @Override
            public double computeResidual(final FundamentalMatrix currentEstimation, final int i) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L234">234</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L802">802</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>var counter = 0;
            ProjectiveTransformation2D t = null;
            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            for (final var homography : homographies) {
                // convert homography into projective so it can be normalized
                homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L383">383</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L802">802</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>var counter = 0;
            ProjectiveTransformation2D t = null;
            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            for (final var homography : homographies) {
                // convert homography into projective so it can be normalized
                homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L528">528</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L802">802</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>var counter = 0;
            ProjectiveTransformation2D t = null;
            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            for (final var homography : homographies) {
                // convert homography into projective so it can be normalized
                homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L668">668</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L802">802</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>var counter = 0;
            ProjectiveTransformation2D t = null;
            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            for (final var homography : homographies) {
                // convert homography into projective so it can be normalized
                homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMedSImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMedSImageOfAbsoluteConicRobustEstimator.html#L205">205</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/MSACImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/MSACImageOfAbsoluteConicRobustEstimator.html#L180">180</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROMedSImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSImageOfAbsoluteConicRobustEstimator.html#L333">333</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROSACImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACImageOfAbsoluteConicRobustEstimator.html#L302">302</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@Override
            public int getTotalSamples() {
                return homographies.size();
            }

            @Override
            public int getSubsetSize() {
                return iacEstimator.getMinNumberOfRequiredHomographies();
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;ImageOfAbsoluteConic&gt; solutions) {
                subsetHomographies.clear();
                for (final var samplesIndex : samplesIndices) {
                    subsetHomographies.add(homographies.get(samplesIndex));
                }

                try {
                    iacEstimator.setLMSESolutionAllowed(false);
                    iacEstimator.setHomographies(subsetHomographies);

                    final var iac = iacEstimator.estimate();
                    solutions.add(iac);
                } catch (final Exception e) {
                    // if anything fails, no solution is added
                }
            }

            @Override
            public double computeResidual(final ImageOfAbsoluteConic currentEstimation, final int i) {
                return residual(currentEstimation, homographies.get(i));
            }

            @Override
            public boolean isReady() {
                return LMedSImageOfAbsoluteConicRobustEstimator.this.isReady();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/refiners/FundamentalMatrixRefiner.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/refiners/FundamentalMatrixRefiner.html#L216">216</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/refiners/HomogeneousRightEpipoleRefiner.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/refiners/HomogeneousRightEpipoleRefiner.html#L167">167</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>rightPoint = samples2.get(i);
                    leftPoint.normalize();
                    rightPoint.normalize();
                    x.setElementAt(pos, 0, leftPoint.getHomX());
                    x.setElementAt(pos, 1, leftPoint.getHomY());
                    x.setElementAt(pos, 2, leftPoint.getHomW());
                    x.setElementAt(pos, 3, rightPoint.getHomX());
                    x.setElementAt(pos, 4, rightPoint.getHomY());
                    x.setElementAt(pos, 5, rightPoint.getHomW());

                    y[pos] = residuals[i];
                    pos++;
                }
            }

            final var evaluator = new LevenbergMarquardtMultiDimensionFunctionEvaluator() {

                private final Point2D leftPoint = Point2D.create(CoordinatesType.HOMOGENEOUS_COORDINATES);

                private final Point2D rightPoint = Point2D.create(CoordinatesType.HOMOGENEOUS_COORDINATES);

                private final FundamentalMatrix fundMatrix = new FundamentalMatrix();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L912">912</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1642">1642</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>samples[1].getPoint().getInhomY() - principalPointY);
            rightPoints.add(rightPoint);

            qualityScores[i] = match.getQualityScore();
            i++;
        }

        try {
            final var homographyEstimator = PointCorrespondenceProjectiveTransformation2DRobustEstimator.create(
                    configuration.getRobustPlanarHomographyEstimatorMethod());
            homographyEstimator.setResultRefined(configuration.isPlanarHomographyRefined());
            homographyEstimator.setCovarianceKept(configuration.isPlanarHomographyCovarianceKept());
            homographyEstimator.setConfidence(configuration.getPlanarHomographyConfidence());
            homographyEstimator.setMaxIterations(configuration.getPlanarHomographyMaxIterations());

            switch (configuration.getRobustPlanarHomographyEstimatorMethod()) {
                case LMEDS:
                    ((LMedSPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator)
                            .setStopThreshold(configuration.getPlanarHomographyThreshold());
                    break;
                case MSAC:
                    ((MSACPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator)
                            .setThreshold(configuration.getPlanarHomographyThreshold());
                    break;
                case PROMEDS:
                    ((PROMedSPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator)
                            .setStopThreshold(configuration.getPlanarHomographyThreshold());
                    break;
                case PROSAC:</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/LMSEHomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/LMSEHomogeneousSinglePoint3DTriangulator.html#L217">217</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/LMSEHomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/LMSEHomogeneousSinglePoint3DTriangulator.html#L236">236</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/WeightedHomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/WeightedHomogeneousSinglePoint3DTriangulator.html#L372">372</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/WeightedHomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/WeightedHomogeneousSinglePoint3DTriangulator.html#L395">395</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(row, 3, homX * principalPlane.getD() - homW * verticalAxisPlane.getD());

                // normalize row (equation) to increase accuracy
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(row, 0), 2.0)
                        + Math.pow(a.getElementAt(row, 1), 2.0)
                        + Math.pow(a.getElementAt(row, 2), 2.0)
                        + Math.pow(a.getElementAt(row, 3), 2.0));

                a.setElementAt(row, 0, a.getElementAt(row, 0) / rowNorm);
                a.setElementAt(row, 1, a.getElementAt(row, 1) / rowNorm);
                a.setElementAt(row, 2, a.getElementAt(row, 2) / rowNorm);
                a.setElementAt(row, 3, a.getElementAt(row, 3) / rowNorm);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1129">1129</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L844">844</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>estimator.setAspectRatio(configuration.getPairedCamerasAspectRatio());
            estimator.estimate();

            final var camera1 = estimator.getEstimatedLeftCamera();
            final var camera2 = estimator.getEstimatedRightCamera();

            camera1.decompose();
            camera2.decompose();

            final var intrinsicZeroPrincipalPoint1 = camera1.getIntrinsicParameters();
            final var intrinsicZeroPrincipalPoint2 = camera2.getIntrinsicParameters();

            final var principalPointX = configuration.getPrincipalPointX();
            final var principalPointY = configuration.getPrincipalPointY();

            final var intrinsic1 = new PinholeCameraIntrinsicParameters(intrinsicZeroPrincipalPoint1);
            intrinsic1.setHorizontalPrincipalPoint(intrinsic1.getHorizontalPrincipalPoint() + principalPointX);
            intrinsic1.setVerticalPrincipalPoint(intrinsic1.getVerticalPrincipalPoint() + principalPointY);
            camera1.setIntrinsicParameters(intrinsic1);

            final var intrinsic2 = new PinholeCameraIntrinsicParameters(intrinsicZeroPrincipalPoint2);
            intrinsic2.setHorizontalPrincipalPoint(intrinsic2.getHorizontalPrincipalPoint() + principalPointX);
            intrinsic2.setVerticalPrincipalPoint(intrinsic2.getVerticalPrincipalPoint() + principalPointY);
            camera2.setIntrinsicParameters(intrinsic2);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L567">567</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L592">592</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L841">841</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L867">867</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 3, h31 * h32);

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0)
                        + Math.pow(a.getElementAt(counter, 3), 2.0));

                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);
                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);
                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);
                a.setElementAt(counter, 3, a.getElementAt(counter, 3) / rowNorm);

                counter++;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L581">581</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L684">684</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>fill3rdRowAnd1stRowEquation(p11, p31, p12, p32, p13, p33, p14, p34, a, eqCounter);
                    applyWeight(row, eqCounter, weight);
                    eqCounter++;

                    // 3rd row
                    fill3rdRowAnd2ndRowEquation(p21, p31, p22, p32, p23, p33, p24, p34, a, eqCounter);
                    applyWeight(row, eqCounter, weight);

                    // transRow = row'
                    row.transpose(transRow);
                    transRow.multiply(row, tmp);

                    tmp.multiplyByScalar(1.0 / previousNorm);

                    // a += 1.0 / previousNorm * tmp
                    a.add(tmp);
                    // normalize
                    previousNorm = Utils.normF(a);
                    a.multiplyByScalar(1.0 / previousNorm);
                }

                cameraCounter++;
            }

            final var decomposer = new SingularValueDecomposer(a);
            enforceRank3IfNeeded(decomposer, result);

        } catch (final AlgebraException | SortingException | NumericalException e) {
            throw new DualAbsoluteQuadricEstimatorException(e);
        }
    }

    /**
     * Estimates Dual Absolute Quadric (DAQ) assuming that principal point is
     * zero.
     *
     * @param result instance where resulting estimated Dual Absolute Quadrics
     *               will be stored.
     * @throws DualAbsoluteQuadricEstimatorException if an error occurs during
     *                                               estimation, usually because repeated cameras are
     *                                               provided, or cameras corresponding to critical motion
     *                                               sequences such as pure parallel translations are
     *                                               provided, where no additional data is really provided.
     */
    private void estimatePrincipalPointAtOrigin(DualAbsoluteQuadric result)</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseAbsoluteOrientationSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseAbsoluteOrientationSlamSparseReconstructor.html#L221">221</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/KnownBaselineSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/KnownBaselineSparseReconstructor.html#L124">124</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var euclideanReconstructedPoints3D = scaleAndOrientationTransformation.transformPointsAndReturnNew(
                    metricReconstructedPoints3D);

            // set scaled points into result
            activeEuclideanReconstructedPoints = new ArrayList&lt;&gt;();
            ReconstructedPoint3D euclideanPoint;
            ReconstructedPoint3D metricPoint;
            for (var i = 0; i &lt; numPoints; i++) {
                metricPoint = activeMetricReconstructedPoints.get(i);

                euclideanPoint = new ReconstructedPoint3D();
                euclideanPoint.setId(metricPoint.getId());
                euclideanPoint.setPoint(euclideanReconstructedPoints3D.get(i));
                euclideanPoint.setInlier(metricPoint.isInlier());
                euclideanPoint.setQualityScore(metricPoint.getQualityScore());
                if (metricPoint.getCovariance() != null) {
                    euclideanPoint.setCovariance(metricPoint.getCovariance().multiplyByScalarAndReturnNew(sqrScale));
                }
                euclideanPoint.setColorData(metricPoint.getColorData());

                activeEuclideanReconstructedPoints.add(euclideanPoint);
            }

            return true;

        } catch (final Exception e) {
            failed = true;
            //noinspection unchecked
            listener.onFail((R) this);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L247">247</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L685">685</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);
                a.setElementAt(counter, 1, h11 * h22 + h21 * h12);
                a.setElementAt(counter, 2, h21 * h22);
                a.setElementAt(counter, 3, h11 * h32 + h31 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L541">541</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L389">389</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);
                a.setElementAt(counter, 1, h11 * h22 + h21 * h12);
                a.setElementAt(counter, 2, h21 * h22);
                a.setElementAt(counter, 3, h31 * h32);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/AffineFundamentalMatrixEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/AffineFundamentalMatrixEstimator.html#L84">84</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/SevenPointsFundamentalMatrixEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/SevenPointsFundamentalMatrixEstimator.html#L104">104</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public AffineFundamentalMatrixEstimator(final List&lt;Point2D&gt; leftPoints, final List&lt;Point2D&gt; rightPoints) {
        super(leftPoints, rightPoints);
        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;
        normalizePoints = DEFAULT_NORMALIZE_POINT_CORRESPONDENCES;
    }

    /**
     * Returns boolean indicating whether an LMSE (the Least Mean Square Error)
     * solution is allowed or not. When an LMSE solution is allowed, more than 8
     * matched points can be used for fundamental matrix estimation. If LMSE
     * solution is not allowed then only the 4 former matched points will be
     * taken into account.
     *
     * @return true if an LMSE solution is allowed, false otherwise.
     */
    public boolean isLMSESolutionAllowed() {
        return allowLMSESolution;
    }

    /**
     * Sets boolean indicating whether an LMSE (the Least Mean Square Error)
     * solution is allowed or not. When an LMSE solution is allowed, more than 8
     * matched points can be used for fundamental matrix estimation. If LMSE
     * solution is not allowed then only the 4 former matched points will be
     * taken into account.
     *
     * @param allowed true if an LMSE solution is allowed, false otherwise.
     * @throws LockedException if this instance is locked because an estimation
     *                         is in progress.
     */
    public void setLMSESolutionAllowed(final boolean allowed) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        allowLMSESolution = allowed;
    }

    /**
     * Indicates whether provided matched 2D points must be normalized to
     * increase the accuracy of the estimation.
     *
     * @return true if points must be normalized, false otherwise.
     */
    public boolean arePointsNormalized() {
        return normalizePoints;
    }

    /**
     * Sets boolean indicating whether provided matched 2D points must be
     * normalized to increase the accuracy of the estimation.
     *
     * @param normalizePoints true if points must be normalized, false
     *                        otherwise.
     * @throws LockedException if this instance is locked because an estimation
     *                         is in progress.
     */
    public void setPointsNormalized(final boolean normalizePoints) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.normalizePoints = normalizePoints;
    }

    /**
     * Returns boolean indicating whether estimator is ready to start the
     * fundamental matrix estimation.
     * This is true when the required minimum number of matched points is
     * provided to obtain a solution and both left and right views have the
     * same number of matched points.
     *
     * @return true if estimator is ready to start the fundamental matrix
     * estimation, false otherwise.
     */
    @Override
    public boolean isReady() {
        return leftPoints != null &amp;&amp; rightPoints != null &amp;&amp; leftPoints.size() == rightPoints.size()
                &amp;&amp; leftPoints.size() &gt;= MIN_REQUIRED_POINTS;
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseAbsoluteOrientationSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseAbsoluteOrientationSlamSparseReconstructor.html#L196">196</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/KnownBaselineSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/KnownBaselineSparseReconstructor.html#L99">99</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>previousEuclideanEstimatedCamera = new EstimatedCamera();
            previousEuclideanEstimatedCamera.setCamera(euclideanCamera1);
            previousEuclideanEstimatedCamera.setViewId(previousMetricEstimatedCamera.getViewId());
            previousEuclideanEstimatedCamera.setQualityScore(previousMetricEstimatedCamera.getQualityScore());
            if (previousMetricEstimatedCamera.getCovariance() != null) {
                previousEuclideanEstimatedCamera.setCovariance(previousMetricEstimatedCamera.getCovariance()
                        .multiplyByScalarAndReturnNew(sqrScale));
            }

            currentEuclideanEstimatedCamera = new EstimatedCamera();
            currentEuclideanEstimatedCamera.setCamera(euclideanCamera2);
            currentEuclideanEstimatedCamera.setViewId(currentMetricEstimatedCamera.getViewId());
            currentEuclideanEstimatedCamera.setQualityScore(currentMetricEstimatedCamera.getQualityScore());
            if (currentMetricEstimatedCamera.getCovariance() != null) {
                currentEuclideanEstimatedCamera.setCovariance(currentMetricEstimatedCamera.getCovariance()
                        .multiplyByScalarAndReturnNew(sqrScale));
            }

            // update scale of reconstructed points
            final var numPoints = activeMetricReconstructedPoints.size();
            final var metricReconstructedPoints3D = new ArrayList&lt;Point3D&gt;();
            for (final var reconstructedPoint : activeMetricReconstructedPoints) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamSparseReconstructor.html#L284">284</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/KnownBaselineSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/KnownBaselineSparseReconstructor.html#L99">99</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>previousEuclideanEstimatedCamera = new EstimatedCamera();
            previousEuclideanEstimatedCamera.setCamera(euclideanCamera1);
            previousEuclideanEstimatedCamera.setViewId(previousMetricEstimatedCamera.getViewId());
            previousEuclideanEstimatedCamera.setQualityScore(previousMetricEstimatedCamera.getQualityScore());
            if (previousMetricEstimatedCamera.getCovariance() != null) {
                previousEuclideanEstimatedCamera.setCovariance(
                        previousMetricEstimatedCamera.getCovariance().multiplyByScalarAndReturnNew(sqrScale));
            }

            currentEuclideanEstimatedCamera = new EstimatedCamera();
            currentEuclideanEstimatedCamera.setCamera(euclideanCamera2);
            currentEuclideanEstimatedCamera.setViewId(currentMetricEstimatedCamera.getViewId());
            currentEuclideanEstimatedCamera.setQualityScore(currentMetricEstimatedCamera.getQualityScore());
            if (currentMetricEstimatedCamera.getCovariance() != null) {
                currentEuclideanEstimatedCamera.setCovariance(
                        currentMetricEstimatedCamera.getCovariance().multiplyByScalarAndReturnNew(sqrScale));
            }

            // update scale of reconstructed points
            final var numPoints = activeMetricReconstructedPoints.size();
            final var metricReconstructedPoints3D = new ArrayList&lt;Point3D&gt;();
            for (final var reconstructedPoint : activeMetricReconstructedPoints) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/AlternatingCameraCalibrator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/AlternatingCameraCalibrator.html#L692">692</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/ErrorOptimizationCameraCalibrator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/ErrorOptimizationCameraCalibrator.html#L732">732</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}
    }

    /**
     * Refreshes listener of distortion estimator
     */
    protected void refreshDistortionEstimatorListener() {
        if (distortionEstimatorListener == null) {
            distortionEstimatorListener = new RadialDistortionRobustEstimatorListener() {

                @Override
                public void onEstimateStart(final RadialDistortionRobustEstimator estimator) {
                    radialDistortionProgress = 0.0f;
                    notifyProgress();
                }

                @Override
                public void onEstimateEnd(final RadialDistortionRobustEstimator estimator) {
                    radialDistortionProgress = 1.0f;
                    notifyProgress();
                }

                @Override
                public void onEstimateNextIteration(
                        final RadialDistortionRobustEstimator estimator, final int iteration) {
                    // not needed
                }

                @Override
                public void onEstimateProgressChange(
                        final RadialDistortionRobustEstimator estimator, final float progress) {
                    radialDistortionProgress = progress;
                    notifyProgress();
                }
            };
        }

        try {
            distortionEstimator.setListener(distortionEstimatorListener);
        } catch (final LockedException e) {
            Logger.getLogger(AlternatingCameraCalibrator.class.getName()).log(Level.WARNING,
                    &quot;Could not set radial distortion estimator listener&quot;, e);
        }
    }

    /**
     * Sets robust estimator method to be used for radial distortion estimation.
     * If method changes, then a new radial distortion estimator is created and
     * configured.
     *
     * @param distortionMethod robust estimator method to be used for
     *                         radial distortion estimation.
     */
    private void internalSetDistortionMethod(final RobustEstimatorMethod distortionMethod) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/MSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/MSACRadialDistortionRobustEstimator.html#L147">147</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/RANSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/RANSACRadialDistortionRobustEstimator.html#L147">147</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public MSACRadialDistortionRobustEstimator(
            final List&lt;Point2D&gt; distortedPoints, final List&lt;Point2D&gt; undistortedPoints, final Point2D distortionCenter,
            final RadialDistortionRobustEstimatorListener listener) {
        super(distortedPoints, undistortedPoints, distortionCenter, listener);
        threshold = DEFAULT_THRESHOLD;
    }

    /**
     * Returns threshold to determine whether points are inliers or not when
     * testing possible estimation solutions.
     * The threshold refers to the amount of error (i.e. Euclidean distance) a
     * possible solution has on projected 2D points.
     *
     * @return threshold to determine whether points are inliers or not when
     * testing possible estimation solutions.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether points are inliers or not when
     * testing possible estimation solutions.
     * The threshold refers to the amount of error (i.e. Euclidean distance) a
     * possible solution has on projected 2D points.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Estimates a radial distortion using a robust estimator and
     * the best set of matched 2D points found using the robust estimator.
     *
     * @return a radial distortion.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws NotReadyException        if provided input data is not enough to start
     *                                  the estimation.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public RadialDistortion estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new MSACRobustEstimator&lt;RadialDistortion&gt;(new MSACRobustEstimatorListener&lt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/KruppaDualImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/KruppaDualImageOfAbsoluteConicEstimator.html#L610">610</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/KruppaDualImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/KruppaDualImageOfAbsoluteConicEstimator.html#L941">941</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>if (x &gt;= 0.0 &amp;&amp; y &gt;= 0.0) {
                        final var horizontalFocalLength = Math.sqrt(x);
                        final var verticalFocalLength = Math.sqrt(y);
                        valid = buildDiac(horizontalFocalLength, verticalFocalLength, diac);
                    }

                    if (valid) {
                        break;
                    }
                }
            } else {
                throw new KruppaDualImageOfAbsoluteConicEstimatorException();
            }

            if (valid) {
                // copy to result
                result.setParameters(diac.getA(), diac.getB(), diac.getC(), diac.getD(), diac.getE(), diac.getF());
            } else {
                // no valid DIAC could be found
                throw new KruppaDualImageOfAbsoluteConicEstimatorException();
            }

        } catch (final KruppaDualImageOfAbsoluteConicEstimatorException ex) {
            throw ex;
        } catch (final Exception ex) {
            throw new KruppaDualImageOfAbsoluteConicEstimatorException(ex);
        }
    }

    /**
     * Gets x value from current y value.
     * X and y values are the squared values of estimated focal length
     * components.
     * This method is used internally when aspect ratio is not known.
     *
     * @param y y value to obtain x value from.
     * @param s internal value from Kruppa's equations.
     * @param t internal value from Kruppa's equations.
     * @param u internal value from Kruppa's equations.
     * @param v internal value from Kruppa's equations.
     * @param w internal value from Kruppa's equations.
     * @return x value.
     */
    private double getXFromY(final double y, final double s, final double t, final double u, final double v,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/AlternatingCameraCalibrator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/AlternatingCameraCalibrator.html#L530">530</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/ErrorOptimizationCameraCalibrator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/ErrorOptimizationCameraCalibrator.html#L550">550</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>double[] qualityScores = null;
        if (distortionMethod == RobustEstimatorMethod.PROSAC || distortionMethod == RobustEstimatorMethod.PROMEDS) {
            qualityScores = new double[totalPoints];
        }

        // estimate camera pose for each sample
        var pointCounter = 0;
        var sampleCounter = 0;
        for (final var sample : samples) {
            if (sample.getHomography() == null) {
                // homography computation failed, so we cannot compute camera
                // pose for this sample, or use this sample for radial distortion
                // estimation
                continue;
            }
            sample.computeCameraPose(intrinsic);

            // transform ideal pattern markers using estimated homography
            final List&lt;Point2D&gt; idealPatternMarkers;
            if (sample.getPattern() != null) {
                // use points generated by pattern in sample
                idealPatternMarkers = sample.getPattern().getIdealPoints();
            } else {
                // use fallback pattern points
                idealPatternMarkers = idealFallbackPatternMarkers;
            }

            final var transformedIdealPatternMarkers = sample.getHomography()
                    .transformPointsAndReturnNew(idealPatternMarkers);

            // transformedIdealPatternMarkers are considered the undistorted
            // points, because camera follows a pure pinhole model without
            // distortion, and we have transformed the ideal points using a
            // pure projective homography without distortion.
            // sample.getSampledMarkers() contains the sampled coordinates using
            // the actual camera, which will be distorted

            // the sampled markers are the ones considered to be distorted for
            // radial distortion estimation purposes, because they are obtained
            // directly from the camera

            // stack together all distorted and undistorted points from all
            // samples

            distortedPoints.addAll(sample.getSampledMarkers());
            undistortedPoints.addAll(transformedIdealPatternMarkers);

            final var markersSize = transformedIdealPatternMarkers.size();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L183">183</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L762">762</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var uwz = u[8];

        try {
            // update velocity
            final var vv = new Matrix(SPEED_COMPONENTS, SPEED_COMPONENTS);
            final var va = new Matrix(SPEED_COMPONENTS, ACCELERATION_COMPONENTS);
            final var v = VelocityPredictor.predict(vx, vy, vz, ax, ay, az, dt, vv, va);

            // update position
            Matrix rr = null;
            Matrix rv = null;
            Matrix ra = null;
            if (jacobianX != null) {
                rr = new Matrix(Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH,
                        Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH);
                rv = new Matrix(Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH, SPEED_COMPONENTS);
                ra = new Matrix(Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH, ACCELERATION_COMPONENTS);
            }
            PositionPredictor.predict(r, vx, vy, vz, ax, ay, az, dt, r, rr, rv, ra);

            // update orientation
            Matrix qq = null;
            Matrix qw = null;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L427">427</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L1018">1018</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>throw new IllegalArgumentException();
        }

        // position
        final var r = new InhomogeneousPoint3D(x[0], x[1], x[2]);

        // orientation
        var q = new Quaternion(x[3], x[4], x[5], x[6]);

        // linear velocity
        var vx = x[7];
        var vy = x[8];
        var vz = x[9];

        // linear acceleration
        var ax = x[10];
        var ay = x[11];
        var az = x[12];

        // angular velocity
        var wx = x[13];
        var wy = x[14];
        var wz = x[15];

        // position change (control)
        final var drx = u[0];
        final var dry = u[1];
        final var drz = u[2];

        // linear velocity change (control)
        final var uvx = u[3];</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L757">757</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L637">637</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>if (samples.length != MIN_NUMBER_OF_VIEWS) {
                return false;
            }

            leftSamples.add(samples[0]);
            rightSamples.add(samples[1]);

            final var leftPoint = Point2D.create();
            leftPoint.setInhomogeneousCoordinates(
                    samples[0].getPoint().getInhomX() - principalPointX,
                    samples[0].getPoint().getInhomY() - principalPointY);
            leftPoints.add(leftPoint);

            final var rightPoint = Point2D.create();
            rightPoint.setInhomogeneousCoordinates(
                    samples[1].getPoint().getInhomX() - principalPointX,
                    samples[1].getPoint().getInhomY() - principalPointY);
            rightPoints.add(rightPoint);

            qualityScores[i] = match.getQualityScore();
            i++;
        }

        try {
            final var estimator = FundamentalMatrixRobustEstimator.create(leftPoints, rightPoints, qualityScores,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L896">896</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L500">500</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>if (samples.length != MIN_NUMBER_OF_VIEWS) {
                return false;
            }

            leftSamples.add(samples[0]);
            rightSamples.add(samples[1]);

            final var leftPoint = Point2D.create();
            leftPoint.setInhomogeneousCoordinates(
                    samples[0].getPoint().getInhomX() - principalPointX,
                    samples[0].getPoint().getInhomY() - principalPointY);
            leftPoints.add(leftPoint);

            final var rightPoint = Point2D.create();
            rightPoint.setInhomogeneousCoordinates(
                    samples[1].getPoint().getInhomX() - principalPointX,
                    samples[1].getPoint().getInhomY() - principalPointY);
            rightPoints.add(rightPoint);

            qualityScores[i] = match.getQualityScore();
            i++;
        }

        try {
            final var homographyEstimator = PointCorrespondenceProjectiveTransformation2DRobustEstimator.create(</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1266">1266</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L974">974</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var samples2 = currentEstimatedFundamentalMatrix.getRightSamples();

        final var points1 = new ArrayList&lt;Point2D&gt;();
        final var points2 = new ArrayList&lt;Point2D&gt;();
        final var length = samples1.size();
        for (var i = 0; i &lt; length; i++) {
            final var sample1 = samples1.get(i);
            final var sample2 = samples2.get(i);

            final var point1 = sample1.getPoint();
            final var point2 = sample2.getPoint();

            points1.add(point1);
            points2.add(point2);
        }

        try {
            final var estimator = new DualImageOfAbsoluteConicInitialCamerasEstimator(fundamentalMatrix, points1,
                    points2);
            estimator.setPrincipalPoint(configuration.getPrincipalPointX(), configuration.getPrincipalPointY());
            estimator.setAspectRatio(configuration.getPairedCamerasAspectRatio());</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructorConfiguration.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructorConfiguration.html#L435">435</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructorConfiguration.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructorConfiguration.html#L225">225</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>private FundamentalMatrixEstimatorMethod mNonRobustFundamentalMatrixEstimatorMethod =
            DEFAULT_NON_ROBUST_FUNDAMENTAL_MATRIX_ESTIMATOR_METHOD;

    /**
     * Method to use for robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     */
    private RobustEstimatorMethod mRobustFundamentalMatrixEstimatorMethod =
            DEFAULT_ROBUST_FUNDAMENTAL_MATRIX_ESTIMATOR_METHOD;

    /**
     * Indicates whether estimated fundamental matrix is refined among all found inliers.
     * This is only used when general scenes are allowed.
     */
    private boolean refineFundamentalMatrix = DEFAULT_REFINE_FUNDAMENTAL_MATRIX;

    /**
     * Indicates whether covariance of estimated fundamental matrix is kept after the
     * estimation.
     * This is only used when general scenes are allowed.
     */
    private boolean keepFundamentalMatrixCovariance = DEFAULT_KEEP_FUNDAMENTAL_MATRIX_COVARIANCE;

    /**
     * Confidence of robustly estimated fundamental matrix.
     * This is only used when general scenes are allowed.
     */
    private double fundamentalMatrixConfidence = DEFAULT_FUNDAMENTAL_MATRIX_CONFIDENCE;

    /**
     * Maximum number of iterations to robustly estimate fundamental matrix.
     * This is only used when general scenes are allowed.
     */
    private int fundamentalMatrixMaxIterations = DEFAULT_FUNDAMENTAL_MATRIX_MAX_ITERATIONS;

    /**
     * Threshold to determine whether samples for robust fundamental matrix estimation are
     * inliers or not.
     * This is only used when general scenes are allowed.
     */
    private double fundamentalMatrixThreshold = DEFAULT_FUNDAMENTAL_MATRIX_THRESHOLD;

    /**
     * Indicates whether inliers must be kept during robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     */
    private boolean fundamentalMatrixComputeAndKeepInliers = DEFAULT_FUNDAMENTAL_MATRIX_COMPUTE_AND_KEEP_INLIERS;

    /**
     * Indicates whether residuals must be computed and kept during robust fundamental matrix
     * estimation.
     * This is only used when general scenes are allowed.
     */
    private boolean fundamentalMatrixComputeAndKeepResiduals = DEFAULT_FUNDAMENTAL_MATRIX_COMPUTE_AND_KEEP_RESIDUALS;

    /**
     * Method to use for initial cameras' estimation.
     */
    private InitialCamerasEstimatorMethod initialCamerasEstimatorMethod = DEFAULT_INITIAL_CAMERAS_ESTIMATOR_METHOD;

    /**
     * Indicates whether an homogeneous point triangulator is used for point triangulation
     * when Dual Absolute Quadric (DAQ) camera initialization is used.
     */
    private boolean daqUseHomogeneousPointTriangulator = DEFAULT_DAQ_USE_HOMOGENEOUS_POINT_TRIANGULATOR;

    /**
     * Aspect ratio for initial cameras.
     */
    private double initialCamerasAspectRatio = DEFAULT_INITIAL_CAMERAS_ASPECT_RATIO;

    /**
     * Horizontal principal point value to use for initial cameras estimation using
     * Dual Image of Absolute Conic (DIAC) or Dual Absolute Quadric (DAQ) methods.
     */
    private double principalPointX = DEFAULT_INITIAL_CAMERAS_PRINCIPAL_POINT_X;

    /**
     * Vertical principal point value to use for initial cameras estimation using
     * Dual Image of Absolute Conic (DIAC) or Dual Absolute Quadric (DAC) methods.
     */
    private double principalPointY = DEFAULT_INITIAL_CAMERAS_PRINCIPAL_POINT_Y;

    /**
     * Corrector type to use for point triangulation when initial cameras are being estimated
     * using either Dual Image of Absolute Conic (DIAC) or essential matrix methods or null
     * if no corrector is used.
     */
    private CorrectorType initialCamerasCorrectorType = DEFAULT_INITIAL_CAMERAS_CORRECTOR_TYPE;

    /**
     * Value indicating whether valid triangulated points are marked during initial
     * cameras estimation using either Dual Image of Absolute Conic (DIAC) or essential
     * matrix methods.
     */
    private boolean initialCamerasMarkValidTriangulatedPoints = DEFAULT_INITIAL_CAMERAS_MARK_VALID_TRIANGULATED_POINTS;

    /**
     * Intrinsic parameters of first camera estimated using the essential matrix
     * method.
     */
    private PinholeCameraIntrinsicParameters initialIntrinsic1;

    /**
     * Intrinsic parameters of second camera estimated using the essential matrix
     * method.
     */
    private PinholeCameraIntrinsicParameters initialIntrinsic2;

    /**
     * Indicates whether a general scene (points laying in a general 3D position) is
     * allowed.
     * When true, an initial geometry estimation is attempted for general points.
     */
    private boolean allowGeneralScene = DEFAULT_ALLOW_GENERAL_SCENE;

    /**
     * Indicates whether a planar scene (points laying in a 3D plane) is allowed.
     * When true, an initial geometry estimation is attempted for planar points.
     */
    private boolean allowPlanarScene = DEFAULT_ALLOW_PLANAR_SCENE;

    /**
     * Robust method to use for planar homography estimation.
     * This is only used when planar scenes are allowed.
     */
    private RobustEstimatorMethod robustPlanarHomographyEstimatorMethod =
            DEFAULT_ROBUST_PLANAR_HOMOGRAPHY_ESTIMATOR_METHOD;

    /**
     * Indicates whether planar homography is refined using all found inliers or not.
     * This is only used when planar scenes are allowed.
     */
    private boolean refinePlanarHomography = DEFAULT_REFINE_PLANAR_HOMOGRAPHY;

    /**
     * Indicates whether planar homography covariance is kept after estimation.
     * This is only used when planar scenes are allowed.
     */
    private boolean keepPlanarHomographyCovariance = DEFAULT_KEEP_PLANAR_HOMOGRAPHY_COVARIANCE;

    /**
     * Confidence of robustly estimated planar homography. By default, this is 99%.
     * This is only used when planar scenes are allowed.
     */
    private double planarHomographyConfidence = DEFAULT_PLANAR_HOMOGRAPHY_CONFIDENCE;

    /**
     * Maximum number of iterations to make while robustly estimating planar homography.
     * By default, this is 5000.
     * This is only used when planar scenes are allowed.
     */
    private int planarHomographyMaxIterations = DEFAULT_PLANAR_HOMOGRAPHY_MAX_ITERATIONS;

    /**
     * Threshold to determine whether samples for robust projective 2D transformation estimation
     * are inliers or not.
     */
    private double planarHomographyThreshold = DEFAULT_PLANAR_HOMOGRAPHY_THRESHOLD;

    /**
     * Value indicating that inlier data is kept after robust planar homography estimation.
     * This is only used when planar scenes are allowed.
     */
    private boolean planarHomographyComputeAndKeepInliers = DEFAULT_PLANAR_HOMOGRAPHY_COMPUTE_AND_KEEP_INLIERS;

    /**
     * Value indicating that residual data is kept after robust planar homography estimation.
     * This is only used when planar scenes are allowed.
     */
    private boolean planarHomographyComputeAndKeepResiduals = DEFAULT_PLANAR_HOMOGRAPHY_COMPUTE_AND_KEEP_RESIDUALS;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/DualImageOfAbsoluteConicInitialCamerasEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/DualImageOfAbsoluteConicInitialCamerasEstimator.html#L246">246</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/EssentialMatrixInitialCamerasEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/EssentialMatrixInitialCamerasEstimator.html#L401">401</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@Override
    public void estimate() throws LockedException, NotReadyException, InitialCamerasEstimationFailedException {
        if (isLocked()) {
            throw new LockedException();
        }

        if (!isReady()) {
            throw new NotReadyException();
        }

        try {
            locked = true;

            if (listener != null) {
                listener.onStart(this);
            }

            if (triangulatePoints) {
                triangulatedPoints = new ArrayList&lt;&gt;();
            } else {
                triangulatedPoints = null;
            }

            final var nPoints = leftPoints.size();
            if (markValidTriangulatedPoints) {
                validTriangulatedPoints = new BitSet(nPoints);
            } else {
                validTriangulatedPoints = null;
            }

            if (estimatedLeftCamera == null) {
                estimatedLeftCamera = new PinholeCamera();
            }
            if (estimatedRightCamera == null) {
                estimatedRightCamera = new PinholeCamera();
            }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.html#L401">401</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.html#L369">369</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>lastAngularSpeedX = stateAngularSpeedX;
        lastAngularSpeedY = stateAngularSpeedY;
        lastAngularSpeedZ = stateAngularSpeedZ;
        lastTimestampNanos = timestamp;

        if (listener != null) {
            listener.onFullSampleProcessed(this);
        }
    }

    /**
     * Resets position, linear velocity, linear acceleration, orientation and
     * angular speed to provided values.
     * This method implementation also resets Kalman filter state.
     *
     * @param statePositionX     position along x-axis expressed in meters (m).
     * @param statePositionY     position along y-axis expressed in meters (m).
     * @param statePositionZ     position along z-axis expressed in meters (m).
     * @param stateVelocityX     linear velocity along x-axis expressed in meters
     *                           per second (m/s).
     * @param stateVelocityY     linear velocity along y-axis expressed in meters
     *                           per second (m/s).
     * @param stateVelocityZ     linear velocity along z-axis expressed in meters
     *                           per second (m/s).
     * @param stateAccelerationX linear acceleration along x-axis expressed in
     *                           meters per squared second (m/s^2).
     * @param stateAccelerationY linear acceleration along y-axis expressed in
     *                           meters per squared second (m/s^2).
     * @param stateAccelerationZ linear acceleration along z-axis expressed in
     *                           meters per squared second (m/s^2).
     * @param stateQuaternionA   A value of orientation quaternion.
     * @param stateQuaternionB   B value of orientation quaternion.
     * @param stateQuaternionC   C value of orientation quaternion.
     * @param stateQuaternionD   D value of orientation quaternion.
     * @param stateAngularSpeedX angular speed along x-axis expressed in radians
     *                           per second (rad/s).
     * @param stateAngularSpeedY angular speed along y-axis expressed in radians
     *                           per second (rad/s).
     * @param stateAngularSpeedZ angular speed along z-axis expressed in radians
     *                           per second (rad/s).
     */
    @Override
    protected void reset(
            final double statePositionX, final double statePositionY, final double statePositionZ,
            final double stateVelocityX, final double stateVelocityY, final double stateVelocityZ,
            final double stateAccelerationX, final double stateAccelerationY, final double stateAccelerationZ,
            final double stateQuaternionA, final double stateQuaternionB,
            final double stateQuaternionC, final double stateQuaternionD,
            final double stateAngularSpeedX, final double stateAngularSpeedY, final double stateAngularSpeedZ) {
        super.reset(statePositionX, statePositionY, statePositionZ, stateVelocityX, stateVelocityY, stateVelocityZ,
                stateAccelerationX, stateAccelerationY, stateAccelerationZ,
                stateQuaternionA, stateQuaternionB, stateQuaternionC, stateQuaternionD,
                stateAngularSpeedX, stateAngularSpeedY, stateAngularSpeedZ);
        //noinspection ConstantValue
        if (stateOrientation != null) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L323">323</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L464">464</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>counter++;
            }

            final var decomposer = new SingularValueDecomposer(a);
            decomposer.decompose();

            if (decomposer.getNullity() &gt; 1) {
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
                throw new ImageOfAbsoluteConicEstimatorException();
            }

            final var v = decomposer.getV();

            // use last column of V as IAC vector

            // the last column of V contains IAC matrix (B), which is symmetric
            // and positive definite, ordered as follows: B11, B12, B22, B13,
            // B23, B33
            final var b11 = v.getElementAt(0, 5);
            final var b12 = v.getElementAt(1, 5);
            final var b22 = v.getElementAt(2, 5);
            final var b13 = v.getElementAt(3, 5);
            final var b23 = v.getElementAt(4, 5);
            final var b33 = v.getElementAt(5, 5);

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
            return new ImageOfAbsoluteConic(b11, b12, b22, b13, b23, b33);
        } catch (final AlgebraException e) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L715">715</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L861">861</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);

                counter++;

                // fill second equation
                a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0));
                a.setElementAt(counter, 1, Math.pow(h21, 2.0) - Math.pow(h22, 2.0));
                a.setElementAt(counter, 2, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0));</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/HomographyDecomposer.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/HomographyDecomposer.html#L116">116</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/PlanarFundamentalMatrixEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PlanarFundamentalMatrixEstimator.html#L104">104</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final HomographyDecomposerListener listener) {
        this(homography, leftIntrinsics, rightIntrinsics);
        this.listener = listener;
    }

    /**
     * Gets 2D transformation relating two views (left view to right view).
     *
     * @return 2D transformation relating two views.
     */
    public Transformation2D getHomography() {
        return homography;
    }

    /**
     * Sets 2D transformation relating two views (left view to right view).
     *
     * @param homography 2D transformation relating two views.
     * @throws LockedException if estimator is locked.
     */
    public void setHomography(final Transformation2D homography) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.homography = homography;
    }

    /**
     * Gets intrinsic parameters to be used on left view.
     *
     * @return intrinsic parameters to be used on left view.
     */
    public PinholeCameraIntrinsicParameters getLeftIntrinsics() {
        return leftIntrinsics;
    }

    /**
     * Sets intrinsic parameters to be used on left view.
     *
     * @param leftIntrinsics intrinsic parameters to be used on left view.
     * @throws LockedException if estimator is locked.
     */
    public void setLeftIntrinsics(final PinholeCameraIntrinsicParameters leftIntrinsics) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.leftIntrinsics = leftIntrinsics;
    }

    /**
     * Gets intrinsic parameters to be used on right view.
     *
     * @return intrinsic parameters to be used on right view.
     */
    public PinholeCameraIntrinsicParameters getRightIntrinsics() {
        return rightIntrinsics;
    }

    /**
     * Sets intrinsic parameters to be used on right view.
     *
     * @param rightIntrinsics intrinsic parameters to be used on right view.
     * @throws LockedException if estimator is locked.
     */
    public void setRightIntrinsics(final PinholeCameraIntrinsicParameters rightIntrinsics) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.rightIntrinsics = rightIntrinsics;
    }

    /**
     * Gets listener to handle events raised by this instance.
     *
     * @return listener to handle events raised by this instance.
     */
    public HomographyDecomposerListener getListener() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/LMSEInhomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/LMSEInhomogeneousSinglePoint3DTriangulator.html#L194">194</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/WeightedHomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/WeightedHomogeneousSinglePoint3DTriangulator.html#L343">343</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/WeightedInhomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/WeightedInhomogeneousSinglePoint3DTriangulator.html#L347">347</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>camera = cameras.get(i);

                // to increase accuracy
                point.normalize();
                camera.normalize();

                final var homX = point.getHomX();
                final var homY = point.getHomY();
                final var homW = point.getHomW();

                // pick rows of camera corresponding to different planes
                // (we do not normalize planes, as it would introduce errors)

                // 1st camera row (p1T)
                camera.verticalAxisPlane(verticalAxisPlane);
                // 2nd camera row (p2T)
                camera.horizontalAxisPlane(horizontalAxisPlane);
                // 3rd camera row (p3T)
                camera.principalPlane(principalPlane);

                // 1st equation
                a.setElementAt(row, 0, homX * principalPlane.getA() - homW * verticalAxisPlane.getA());
                a.setElementAt(row, 1, homX * principalPlane.getB() - homW * verticalAxisPlane.getB());
                a.setElementAt(row, 2, homX * principalPlane.getC() - homW * verticalAxisPlane.getC());</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/MSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/MSACRobustSinglePoint3DTriangulator.html#L110">110</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/RANSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/RANSACRobustSinglePoint3DTriangulator.html#L111">111</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public MSACRobustSinglePoint3DTriangulator(
            final List&lt;Point2D&gt; points, final List&lt;PinholeCamera&gt; cameras,
            final RobustSinglePoint3DTriangulatorListener listener) {
        super(points, cameras, listener);
        threshold = DEFAULT_THRESHOLD;
    }

    /**
     * Returns threshold to determine whether points are inliers or not when
     * testing possible estimation solutions.
     * The threshold refers to the amount of error (i.e. Euclidean distance) a
     * possible solution has on projected 2D points.
     *
     * @return threshold to determine whether points are inliers or not when
     * testing possible estimation solutions.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether points are inliers or not when
     * testing possible estimation solutions.
     * The threshold refers to the amount of error (i.e. Euclidean distance) a
     * possible solution has on projected 2D points.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Triangulates provided matched 2D points being projected by each
     * corresponding camera into a single 3D point.
     * At least 2 matched 2D points and their corresponding 2 cameras are
     * required to compute triangulation. If more views are provided, an
     * averaged solution can be found.
     *
     * @return computed triangulated 3D point.
     * @throws LockedException          if this instance is locked.
     * @throws NotReadyException        if lists of points and cameras don't have the
     *                                  same length or less than 2 views are provided.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public Point3D triangulate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new MSACRobustEstimator&lt;Point3D&gt;(new MSACRobustEstimatorListener&lt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.html#L151">151</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L318">318</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}


    /**
     * Estimates the Dual Absolute Quadric using provided cameras.
     *
     * @param result instance where estimated Dual Absolute Quadric (DAQ) will
     *               be stored.
     * @throws LockedException                       if estimator is locked.
     * @throws NotReadyException                     if no valid input data has already been
     *                                               provided.
     * @throws DualAbsoluteQuadricEstimatorException if an error occurs during
     *                                               estimation, usually because input data is not valid or
     *                                               numerically unstable.
     */
    @Override
    public void estimate(final DualAbsoluteQuadric result) throws LockedException, NotReadyException,
            DualAbsoluteQuadricEstimatorException {

        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        try {
            locked = true;
            if (listener != null) {
                listener.onEstimateStart(this);
            }

            if (principalPointAtOrigin) {
                if (zeroSkewness) {
                    if (focalDistanceAspectRatioKnown) {
                        estimateZeroSkewnessPrincipalPointAtOriginAndKnownFocalDistanceAspectRatio(result);
                    } else {
                        estimateZeroSkewnessAndPrincipalPointAtOrigin(result);
                    }
                } else {
                    estimatePrincipalPointAtOrigin(result);
                }
            }

            if (listener != null) {
                listener.onEstimateEnd(this);
            }
        } finally {
            locked = false;
        }
    }

    /**
     * Returns type of Dual Absolute Quadric estimator.
     *
     * @return type of DAQ estimator.
     */
    @Override
    public DualAbsoluteQuadricEstimatorType getType() {
        return DualAbsoluteQuadricEstimatorType.LMSE_DUAL_ABSOLUTE_QUADRIC_ESTIMATOR;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.html#L265">265</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L440">440</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L553">553</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L661">661</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>camera.normalize();

                cameraMatrix = camera.getInternalMatrix();

                p11 = cameraMatrix.getElementAt(0, 0);
                p21 = cameraMatrix.getElementAt(1, 0);
                p31 = cameraMatrix.getElementAt(2, 0);

                p12 = cameraMatrix.getElementAt(0, 1);
                p22 = cameraMatrix.getElementAt(1, 1);
                p32 = cameraMatrix.getElementAt(2, 1);

                p13 = cameraMatrix.getElementAt(0, 2);
                p23 = cameraMatrix.getElementAt(1, 2);
                p33 = cameraMatrix.getElementAt(2, 2);

                p14 = cameraMatrix.getElementAt(0, 3);
                p24 = cameraMatrix.getElementAt(1, 3);
                p34 = cameraMatrix.getElementAt(2, 3);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.html#L356">356</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L440">440</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L553">553</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L661">661</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>camera.normalize();

                cameraMatrix = camera.getInternalMatrix();

                p11 = cameraMatrix.getElementAt(0, 0);
                p21 = cameraMatrix.getElementAt(1, 0);
                p31 = cameraMatrix.getElementAt(2, 0);

                p12 = cameraMatrix.getElementAt(0, 1);
                p22 = cameraMatrix.getElementAt(1, 1);
                p32 = cameraMatrix.getElementAt(2, 1);

                p13 = cameraMatrix.getElementAt(0, 2);
                p23 = cameraMatrix.getElementAt(1, 2);
                p33 = cameraMatrix.getElementAt(2, 2);

                p14 = cameraMatrix.getElementAt(0, 3);
                p24 = cameraMatrix.getElementAt(1, 3);
                p34 = cameraMatrix.getElementAt(2, 3);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEDualAbsoluteQuadricEstimator.html#L443">443</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L440">440</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L553">553</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedDualAbsoluteQuadricEstimator.html#L661">661</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>camera.normalize();

                cameraMatrix = camera.getInternalMatrix();

                p11 = cameraMatrix.getElementAt(0, 0);
                p21 = cameraMatrix.getElementAt(1, 0);
                p31 = cameraMatrix.getElementAt(2, 0);

                p12 = cameraMatrix.getElementAt(0, 1);
                p22 = cameraMatrix.getElementAt(1, 1);
                p32 = cameraMatrix.getElementAt(2, 1);

                p13 = cameraMatrix.getElementAt(0, 2);
                p23 = cameraMatrix.getElementAt(1, 2);
                p33 = cameraMatrix.getElementAt(2, 2);

                p14 = cameraMatrix.getElementAt(0, 3);
                p24 = cameraMatrix.getElementAt(1, 3);
                p34 = cameraMatrix.getElementAt(2, 3);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L812">812</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L988">988</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>double rowNorm;
            for (final var homography : homographies) {
                // convert homography into projective so it can be normalized
                homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12 + h21 * h22 / sqrAspectRatio);
                a.setElementAt(counter, 1, h11 * h32 + h31 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructor.html#L206">206</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamSparseReconstructor.html#L159">159</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}


    /**
     * Configures calibration data on SLAM estimator if available.
     */
    protected void setUpCalibrationData() {
        final var calibrationData = configuration.getCalibrationData();
        if (calibrationData != null) {
            slamEstimator.setCalibrationData(calibrationData);
        }
    }

    /**
     * Configures listener of SLAM estimator
     */
    protected void setUpSlamEstimatorListener() {
        slamEstimator.setListener(new BaseSlamEstimator.BaseSlamEstimatorListener&lt;&gt;() {
            @Override
            public void onFullSampleReceived(final BaseSlamEstimator&lt;D&gt; estimator) {
                // not used
            }

            @Override
            public void onFullSampleProcessed(final BaseSlamEstimator&lt;D&gt; estimator) {
                notifySlamStateAndCamera();
            }

            @Override
            public void onCorrectWithPositionMeasure(final BaseSlamEstimator&lt;D&gt; estimator) {
                // not used
            }

            @Override
            public void onCorrectedWithPositionMeasure(final BaseSlamEstimator&lt;D&gt; estimator) {
                notifySlamStateAndCamera();
            }

            private void notifySlamStateAndCamera() {
                notifySlamStateIfNeeded();
                notifySlamCameraIfNeeded();
            }
        });
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.html#L470">470</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.html#L424">424</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>if (x != null) {
            // position
            x[0] = statePositionX;
            x[1] = statePositionY;
            x[2] = statePositionZ;

            // quaternion
            x[3] = stateQuaternionA;
            x[4] = stateQuaternionB;
            x[5] = stateQuaternionC;
            x[6] = stateQuaternionD;

            // velocity
            x[7] = stateVelocityX;
            x[8] = stateVelocityY;
            x[9] = stateVelocityZ;

            // angular speed
            x[10] = stateAngularSpeedX;
            x[11] = stateAngularSpeedY;
            x[12] = stateAngularSpeedZ;

            try {
                // set initial Kalman filter state (state pre and pro must be two
                // different instances!)
                kalmanFilter.getStatePre().fromArray(x);
                kalmanFilter.getStatePost().fromArray(x);
            } catch (final WrongSizeException ignore) {
                // never thrown
            }
        }

        error = false;
        lastTimestampNanos = -1;
        predictionAvailable = false;
    }

    /**
     * Updates state data of the device by using state matrix obtained after
     * prediction from Kalman filter.
     * to ensure that state follows proper values (specially on quaternions),
     * we keep x values, which have been predicted using the state predictor,
     * which uses analytical values.
     * We then updated x using latest Kalman filter state for next iteration
     * on state predictor.
     *
     * @param state state matrix obtained from Kalman filter.
     */
    private void updatePredictedState(Matrix state) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1371">1371</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1984">1984</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L2074">2074</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final PinholeCameraIntrinsicParameters intrinsic1, final PinholeCameraIntrinsicParameters intrinsic2) {
        final var fundamentalMatrix = currentEstimatedFundamentalMatrix.getFundamentalMatrix();

        // use all points used for fundamental matrix estimation
        final var samples1 = currentEstimatedFundamentalMatrix.getLeftSamples();
        final var samples2 = currentEstimatedFundamentalMatrix.getRightSamples();

        final var points1 = new ArrayList&lt;Point2D&gt;();
        final var points2 = new ArrayList&lt;Point2D&gt;();
        final var length = samples1.size();
        for (var i = 0; i &lt; length; i++) {
            final var sample1 = samples1.get(i);
            final var sample2 = samples2.get(i);

            final var point1 = sample1.getPoint();
            final var point2 = sample2.getPoint();

            points1.add(point1);
            points2.add(point2);
        }

        try {
            final var estimator = new EssentialMatrixInitialCamerasEstimator(fundamentalMatrix, intrinsic1, intrinsic2,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamSparseReconstructor.html#L409">409</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.html#L313">313</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>intrinsicParameters = configuration.getAdditionalCamerasIntrinsics();
            }

            if (intrinsicParameters == null) {
                return;
            }

            final var positionX = slamEstimator.getStatePositionX();
            final var positionY = slamEstimator.getStatePositionY();
            final var positionZ = slamEstimator.getStatePositionZ();
            slamPosition.setInhomogeneousCoordinates(positionX, positionY, positionZ);

            final var quaternionA = slamEstimator.getStateQuaternionA();
            final var quaternionB = slamEstimator.getStateQuaternionB();
            final var quaternionC = slamEstimator.getStateQuaternionC();
            final var quaternionD = slamEstimator.getStateQuaternionD();
            slamRotation.setA(quaternionA);
            slamRotation.setB(quaternionB);
            slamRotation.setC(quaternionC);
            slamRotation.setD(quaternionD);

            slamCamera.setIntrinsicAndExtrinsicParameters(intrinsicParameters, slamRotation, slamPosition);

            //noinspection unchecked
            listener.onSlamCameraEstimated((R) this, slamCamera);

        } catch (final GeometryException ignore) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L969">969</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L1056">1056</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>private boolean estimateInitialCamerasAndPointsDIAC() {
        final var fundamentalMatrix = estimatedFundamentalMatrix.getFundamentalMatrix();

        // use inlier points used for fundamental matrix estimation
        final var samples1 = estimatedFundamentalMatrix.getLeftSamples();
        final var samples2 = estimatedFundamentalMatrix.getRightSamples();

        final var points1 = new ArrayList&lt;Point2D&gt;();
        final var points2 = new ArrayList&lt;Point2D&gt;();
        final var length = samples1.size();
        for (var i = 0; i &lt; length; i++) {
            final var sample1 = samples1.get(i);
            final var sample2 = samples2.get(i);

            final var point1 = sample1.getPoint();
            final var point2 = sample2.getPoint();

            points1.add(point1);
            points2.add(point2);
        }

        try {
            final var estimator = new DualImageOfAbsoluteConicInitialCamerasEstimator(fundamentalMatrix, points1,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROMedSDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSDualAbsoluteQuadricRobustEstimator.html#L189">189</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.html#L204">204</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>this(cameras, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the PROMedS algorithm iterating
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the PROMedS algorithm iterating
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.stopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each provided camera.
     * The larger the score value the better the quality of the sampled
     * camera.
     *
     * @return quality scores corresponding to each camera.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided camera.
     * The larger the score value the better the quality of the sampled
     * camera.
     *
     * @param qualityScores quality scores corresponding to each camera.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than minimum required number of cameras (i.e. 2 cameras).
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates if estimator is ready to start the DAQ estimation.
     * This is true when input data (i.e. cameras) is provided and list contains
     * at least the minimum number of required cameras, and also quality scores
     * are provided.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == cameras.size();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROSACDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACDualAbsoluteQuadricRobustEstimator.html#L177">177</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.html#L187">187</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>this(cameras, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to determine whether cameras are inliers or not when
     * testing possible estimation solutions.
     * The threshold refers to the amount of error a possible solution has.
     *
     * @return threshold to determine whether cameras are inliers or not when
     * testing possible estimation solutions.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether cameras are inliers or not when
     * testing possible estimation solutions.
     * The threshold refers to the amount of error a possible solution has.
     *
     * @param threshold threshold to determine whether cameras are inliers or
     *                  not when testing possible estimation solutions.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each provided camera.
     * The larger the score value the better the quality of the sampled camera.
     *
     * @return quality scores corresponding to each camera.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided camera.
     * The larger the score value the better the quality of the sampled camera.
     *
     * @param qualityScores quality scores corresponding to each camera.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than minimum required number of cameras (i.e. 2 cameras).
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates if estimator is ready to start the DAQ estimation.
     * This is true when input data (i.e. cameras) is provided and contains
     * at least the minimum number of required cameras, and also quality scores
     * are provided.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == cameras.size();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.html#L430">430</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/RANSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/RANSACFundamentalMatrixRobustEstimator.html#L226">226</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Indicates whether inliers must be computed and kept.
     *
     * @return true if inliers must be computed and kept, false if inliers
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepInliersEnabled() {
        return computeAndKeepInliers;
    }

    /**
     * Specifies whether inliers must be computed and kept.
     *
     * @param computeAndKeepInliers true if inliers must be computed and kept,
     *                              false if inliers only need to be computed but not kept.
     * @throws LockedException if estimator is locked.
     */
    public void setComputeAndKeepInliersEnabled(final boolean computeAndKeepInliers) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepInliers = computeAndKeepInliers;
    }

    /**
     * Indicates whether residuals must be computed and kept.
     *
     * @return true if residuals must be computed and kept, false if residuals
     * only need to be computed but not kept.
     */
    public boolean isComputeAndKeepResidualsEnabled() {
        return computeAndKeepResiduals;
    }

    /**
     * Specifies whether residuals must be computed and kept.
     *
     * @param computeAndKeepResiduals true if residuals must be computed and
     *                                kept, false if residuals only need to be computed but not kept.
     * @throws LockedException if estimator is locked.
     */
    public void setComputeAndKeepResidualsEnabled(final boolean computeAndKeepResiduals) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        this.computeAndKeepResiduals = computeAndKeepResiduals;
    }

    /**
     * Estimates a radial distortion using a robust estimator and
     * the best set of matched 2D points found using the robust estimator.
     *
     * @return a radial distortion.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws NotReadyException        if provided input data is not enough to start
     *                                  the estimation.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public FundamentalMatrix estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROSACRobustEstimator&lt;FundamentalMatrix&gt;(new PROSACRobustEstimatorListener&lt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.html#L521">521</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.html#L444">444</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>x[15] = stateAngularSpeedZ;

            try {
                // set initial Kalman filter state (state pre and pro must be two
                // different instances!)
                kalmanFilter.getStatePre().fromArray(x);
                kalmanFilter.getStatePost().fromArray(x);
            } catch (final WrongSizeException ignore) {
                // never thrown
            }
        }

        error = false;
        lastTimestampNanos = -1;
        predictionAvailable = false;
    }

    /**
     * Updates state data of the device by using state matrix obtained after
     * prediction from Kalman filter.
     * to ensure that state follows proper values (specially on quaternions),
     * we keep x values, which have been predicted using the state predictor,
     * which uses analytical values.
     * We then updated x using latest Kalman filter state for next iteration
     * on state predictor.
     *
     * @param state state matrix obtained from Kalman filter.
     */
    private void updatePredictedState(final Matrix state) {
        // position
        statePositionX = x[0];
        x[0] = state.getElementAtIndex(0);
        statePositionY = x[1];
        x[1] = state.getElementAtIndex(1);
        statePositionZ = x[2];
        x[2] = state.getElementAtIndex(2);

        // quaternion state predictor is more reliable than Kalman filter, for
        // that reason we ignore predicted quaternion values on Kalman filter and
        // simply keep predicted ones. Besides, typically gyroscope samples are
        // much more reliable than accelerometer ones. For that reason state
        // elements corresponding to quaternion (3 to 6) are not copied into mX
        // array.
        stateQuaternionA = x[3];
        stateQuaternionB = x[4];
        stateQuaternionC = x[5];
        stateQuaternionD = x[6];</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROMedSDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSDualAbsoluteQuadricRobustEstimator.html#L189">189</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROMedSImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSImageOfAbsoluteConicRobustEstimator.html#L197">197</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROMedSRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSRadialDistortionRobustEstimator.html#L288">288</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.html#L204">204</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>this(cameras, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the PROMedS algorithm iterating
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the PROMedS algorithm iterating
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.stopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each provided camera.
     * The larger the score value the better the quality of the sampled
     * camera.
     *
     * @return quality scores corresponding to each camera.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided camera.
     * The larger the score value the better the quality of the sampled
     * camera.
     *
     * @param qualityScores quality scores corresponding to each camera.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than minimum required number of cameras (i.e. 2 cameras).
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates if estimator is ready to start the DAQ estimation.
     * This is true when input data (i.e. cameras) is provided and list contains
     * at least the minimum number of required cameras, and also quality scores
     * are provided.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == cameras.size();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROMedSDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSDualAbsoluteQuadricRobustEstimator.html#L388">388</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROMedSImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSImageOfAbsoluteConicRobustEstimator.html#L400">400</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROMedSRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSRadialDistortionRobustEstimator.html#L512">512</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.html#L428">428</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>listener.onEstimateProgressChange(PROMedSDualAbsoluteQuadricRobustEstimator.this,
                            progress);
                }
            }

            @Override
            public double[] getQualityScores() {
                return qualityScores;
            }
        });

        try {
            locked = true;
            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            return innerEstimator.estimate();
        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMEDS;
    }

    /**
     * Sets quality scores corresponding to each camera.
     * This method is used internally and does not check whether instance is
     * locked or not.
     *
     * @param qualityScores quality scores to be set.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than the minimum number of required homographies for
     *                                  current settings.
     */
    private void internalSetQualityScores(final double[] qualityScores) {
        if (qualityScores.length &lt; daqEstimator.getMinNumberOfRequiredCameras()) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROSACDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACDualAbsoluteQuadricRobustEstimator.html#L177">177</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROSACImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACImageOfAbsoluteConicRobustEstimator.html#L185">185</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.html#L270">270</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.html#L187">187</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>this(cameras, listener);
        internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to determine whether cameras are inliers or not when
     * testing possible estimation solutions.
     * The threshold refers to the amount of error a possible solution has.
     *
     * @return threshold to determine whether cameras are inliers or not when
     * testing possible estimation solutions.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether cameras are inliers or not when
     * testing possible estimation solutions.
     * The threshold refers to the amount of error a possible solution has.
     *
     * @param threshold threshold to determine whether cameras are inliers or
     *                  not when testing possible estimation solutions.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each provided camera.
     * The larger the score value the better the quality of the sampled camera.
     *
     * @return quality scores corresponding to each camera.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided camera.
     * The larger the score value the better the quality of the sampled camera.
     *
     * @param qualityScores quality scores corresponding to each camera.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than minimum required number of cameras (i.e. 2 cameras).
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates if estimator is ready to start the DAQ estimation.
     * This is true when input data (i.e. cameras) is provided and contains
     * at least the minimum number of required cameras, and also quality scores
     * are provided.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == cameras.size();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseAbsoluteOrientationSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseAbsoluteOrientationSlamSparseReconstructor.html#L166">166</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamSparseReconstructor.html#L253">253</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>slamEstimator.correctWithPositionMeasure(euclideanCamera2.getCameraCenter(),
                    configuration.getCameraPositionCovariance());

            if (!isInitialPairOfViews) {
                slamPosX = slamEstimator.getStatePositionX();
                slamPosY = slamEstimator.getStatePositionY();
                slamPosZ = slamEstimator.getStatePositionZ();
                slamPosition.setInhomogeneousCoordinates(slamPosX, slamPosY, slamPosZ);

                // adjust scale of current camera
                final var euclideanCenter2 = euclideanCamera2.getCameraCenter();

                final var euclideanPosX = euclideanCenter2.getInhomX();
                final var euclideanPosY = euclideanCenter2.getInhomY();
                final var euclideanPosZ = euclideanCenter2.getInhomZ();

                final var scaleVariationX = euclideanPosX / slamPosX;
                final var scaleVariationY = euclideanPosY / slamPosY;
                final var scaleVariationZ = euclideanPosZ / slamPosZ;

                final var scaleVariation = (scaleVariationX + scaleVariationY + scaleVariationZ) / 3.0;
                scale *= scaleVariation;
                currentScale = scale;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1262">1262</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1372">1372</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L2075">2075</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final var fundamentalMatrix = currentEstimatedFundamentalMatrix.getFundamentalMatrix();

        // use inlier points used for fundamental matrix estimation
        final var samples1 = currentEstimatedFundamentalMatrix.getLeftSamples();
        final var samples2 = currentEstimatedFundamentalMatrix.getRightSamples();

        final var points1 = new ArrayList&lt;Point2D&gt;();
        final var points2 = new ArrayList&lt;Point2D&gt;();
        final var length = samples1.size();
        for (var i = 0; i &lt; length; i++) {
            final var sample1 = samples1.get(i);
            final var sample2 = samples2.get(i);

            final var point1 = sample1.getPoint();
            final var point2 = sample2.getPoint();

            points1.add(point1);
            points2.add(point2);
        }

        try {
            final var estimator = new DualImageOfAbsoluteConicInitialCamerasEstimator(fundamentalMatrix, points1,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.html#L403">403</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/SlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/SlamEstimator.html#L398">398</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>lastAngularSpeedZ = stateAngularSpeedZ;
        lastTimestampNanos = timestamp;

        if (listener != null) {
            listener.onFullSampleProcessed(this);
        }
    }

    /**
     * Resets position, linear velocity, linear acceleration, orientation and
     * angular speed to provided values.
     * This method implementation also resets Kalman filter state.
     *
     * @param statePositionX     position along x-axis expressed in meters (m).
     * @param statePositionY     position along y-axis expressed in meters (m).
     * @param statePositionZ     position along z-axis expressed in meters (m).
     * @param stateVelocityX     linear velocity along x-axis expressed in meters
     *                           per second (m/s).
     * @param stateVelocityY     linear velocity along y-axis expressed in meters
     *                           per second (m/s).
     * @param stateVelocityZ     linear velocity along z-axis expressed in meters
     *                           per second (m/s).
     * @param stateAccelerationX linear acceleration along x-axis expressed in
     *                           meters per squared second (m/s^2).
     * @param stateAccelerationY linear acceleration along y-axis expressed in
     *                           meters per squared second (m/s^2).
     * @param stateAccelerationZ linear acceleration along z-axis expressed in
     *                           meters per squared second (m/s^2).
     * @param stateQuaternionA   A value of orientation quaternion.
     * @param stateQuaternionB   B value of orientation quaternion.
     * @param stateQuaternionC   C value of orientation quaternion.
     * @param stateQuaternionD   D value of orientation quaternion.
     * @param stateAngularSpeedX angular speed along x-axis expressed in radians
     *                           per second (rad/s).
     * @param stateAngularSpeedY angular speed along y-axis expressed in radians
     *                           per second (rad/s).
     * @param stateAngularSpeedZ angular speed along z-axis expressed in radians
     *                           per second (rad/s).
     */
    @Override
    protected void reset(
            final double statePositionX, final double statePositionY, final double statePositionZ,
            final double stateVelocityX, final double stateVelocityY, final double stateVelocityZ,
            final double stateAccelerationX, final double stateAccelerationY, final double stateAccelerationZ,
            final double stateQuaternionA, final double stateQuaternionB,
            final double stateQuaternionC, final double stateQuaternionD,
            final double stateAngularSpeedX, final double stateAngularSpeedY, final double stateAngularSpeedZ) {
        super.reset(statePositionX, statePositionY, statePositionZ, stateVelocityX, stateVelocityY, stateVelocityZ,
                stateAccelerationX, stateAccelerationY, stateAccelerationZ,
                stateQuaternionA, stateQuaternionB, stateQuaternionC, stateQuaternionD,
                stateAngularSpeedX, stateAngularSpeedY, stateAngularSpeedZ);
        //noinspection ConstantValue
        if (stateOrientation != null) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.html#L427">427</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/SlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/SlamEstimator.html#L398">398</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>lastAngularSpeedZ = stateAngularSpeedZ;
        lastTimestampNanos = timestamp;

        if (listener != null) {
            listener.onFullSampleProcessed(this);
        }
    }

    /**
     * Resets position, linear velocity, linear acceleration, orientation and
     * angular speed to provided values.
     * This method implementation also resets Kalman filter state.
     *
     * @param statePositionX     position along x-axis expressed in meters (m).
     * @param statePositionY     position along y-axis expressed in meters (m).
     * @param statePositionZ     position along z-axis expressed in meters (m).
     * @param stateVelocityX     linear velocity along x-axis expressed in meters
     *                           per second (m/s).
     * @param stateVelocityY     linear velocity along y-axis expressed in meters
     *                           per second (m/s).
     * @param stateVelocityZ     linear velocity along z-axis expressed in meters
     *                           per second (m/s).
     * @param stateAccelerationX linear acceleration along x-axis expressed in
     *                           meters per squared second (m/s^2).
     * @param stateAccelerationY linear acceleration along y-axis expressed in
     *                           meters per squared second (m/s^2).
     * @param stateAccelerationZ linear acceleration along z-axis expressed in
     *                           meters per squared second (m/s^2).
     * @param stateQuaternionA   A value of orientation quaternion.
     * @param stateQuaternionB   B value of orientation quaternion.
     * @param stateQuaternionC   C value of orientation quaternion.
     * @param stateQuaternionD   D value of orientation quaternion.
     * @param stateAngularSpeedX angular speed along x-axis expressed in radians
     *                           per second (rad/s).
     * @param stateAngularSpeedY angular speed along y-axis expressed in radians
     *                           per second (rad/s).
     * @param stateAngularSpeedZ angular speed along z-axis expressed in radians
     *                           per second (rad/s).
     */
    @Override
    protected void reset(
            final double statePositionX, final double statePositionY, final double statePositionZ,
            final double stateVelocityX, final double stateVelocityY, final double stateVelocityZ,
            final double stateAccelerationX, final double stateAccelerationY,
            final double stateAccelerationZ, final double stateQuaternionA, final double stateQuaternionB,
            final double stateQuaternionC, final double stateQuaternionD,
            final double stateAngularSpeedX, final double stateAngularSpeedY,
            final double stateAngularSpeedZ) {
        super.reset(statePositionX, statePositionY, statePositionZ,
                stateVelocityX, stateVelocityY, stateVelocityZ,
                stateAccelerationX, stateAccelerationY, stateAccelerationZ,
                stateQuaternionA, stateQuaternionB, stateQuaternionC, stateQuaternionD,
                stateAngularSpeedX, stateAngularSpeedY, stateAngularSpeedZ);
        //noinspection ConstantValue
        if (stateOrientation != null) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L396">396</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L826">826</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);
                a.setElementAt(counter, 1, h21 * h22);
                a.setElementAt(counter, 2, h11 * h32 + h31 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L681">681</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L539">539</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);
                a.setElementAt(counter, 1, h21 * h22);
                a.setElementAt(counter, 2, h31 * h32);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROMedSDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSDualAbsoluteQuadricRobustEstimator.html#L246">246</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROSACDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACDualAbsoluteQuadricRobustEstimator.html#L213">213</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Returns quality scores corresponding to each provided camera.
     * The larger the score value the better the quality of the sampled
     * camera.
     *
     * @return quality scores corresponding to each camera.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided camera.
     * The larger the score value the better the quality of the sampled
     * camera.
     *
     * @param qualityScores quality scores corresponding to each camera.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than minimum required number of cameras (i.e. 2 cameras).
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates if estimator is ready to start the DAQ estimation.
     * This is true when input data (i.e. cameras) is provided and list contains
     * at least the minimum number of required cameras, and also quality scores
     * are provided.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == cameras.size();
    }

    /**
     * Estimates the Dual Absolute Quadric using provided cameras.
     *
     * @return estimated Dual Absolute Quadric (DAQ).
     * @throws LockedException          if robust estimator is locked.
     * @throws NotReadyException        if no valid input data has already been
     *                                  provided.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public DualAbsoluteQuadric estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROMedSRobustEstimator&lt;DualAbsoluteQuadric&gt;(new PROMedSRobustEstimatorListener&lt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROMedSImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSImageOfAbsoluteConicRobustEstimator.html#L254">254</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROSACImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACImageOfAbsoluteConicRobustEstimator.html#L223">223</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Returns quality scores corresponding to each provided homography.
     * The larger the score value the better the quality of the sampled
     * homography
     *
     * @return quality scores corresponding to each homography.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided homography.
     * The larger the score value the better the quality of the sampled
     * homography.
     *
     * @param qualityScores quality scores corresponding to each homography.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than minimum required number of homographies (i.e. 1
     *                                  homography).
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates if estimator is ready to start the IAC estimation.
     * This is true when input data (i.e. homographies) is provided and list
     * contains at least the minimum number of required homographies, and
     * also quality scores are provided.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == homographies.size();
    }

    /**
     * Estimates Image of Absolute Conic (IAC)
     *
     * @return estimated IAC
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress
     * @throws NotReadyException        if provided input data is not enough to start
     *                                  the estimation
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc)
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public ImageOfAbsoluteConic estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROMedSRobustEstimator&lt;ImageOfAbsoluteConic&gt;(</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROMedSRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSRadialDistortionRobustEstimator.html#L346">346</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.html#L307">307</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Returns quality scores corresponding to each provided point.
     * The larger the score value the better the quality of the sampled point.
     *
     * @return quality scores corresponding to each point.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided point.
     * The larger the score value the better the quality of the sampled point.
     *
     * @param qualityScores quality scores corresponding to each point.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than MINIMUM_SIZE (i.e. 3 samples).
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates if estimator is ready to start the radial distortion
     * estimation.
     * This is true when input data (i.e. 2D points and quality scores) are
     * provided and a minimum of 2 points are available.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == distortedPoints.size();
    }

    /**
     * Estimates a radial distortion using a robust estimator and
     * the best set of matched 2D points found using the robust estimator.
     *
     * @return a radial distortion.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws NotReadyException        if provided input data is not enough to start
     *                                  the estimation.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public RadialDistortion estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROMedSRobustEstimator&lt;RadialDistortion&gt;(new PROMedSRobustEstimatorListener&lt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamSparseReconstructor.html#L165">165</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.html#L164">164</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var calibrationData = configuration.getCalibrationData();
        if (calibrationData != null) {
            slamEstimator.setCalibrationData(calibrationData);
        }
    }

    /**
     * Configures listener of SLAM estimator
     */
    protected void setUpSlamEstimatorListener() {
        slamEstimator.setListener(new BaseSlamEstimator.BaseSlamEstimatorListener&lt;&gt;() {
            @Override
            public void onFullSampleReceived(final BaseSlamEstimator&lt;D&gt; estimator) {
                // not used
            }

            @Override
            public void onFullSampleProcessed(final BaseSlamEstimator&lt;D&gt; estimator) {
                notifySlamStateAndCamera();
            }

            @Override
            public void onCorrectWithPositionMeasure(final BaseSlamEstimator&lt;D&gt; estimator) {
                // not used
            }

            @Override
            public void onCorrectedWithPositionMeasure(final BaseSlamEstimator&lt;D&gt; estimator) {
                notifySlamStateAndCamera();
            }

            private void notifySlamStateAndCamera() {
                notifySlamStateIfNeeded();
                notifySlamCameraIfNeeded();
            }
        });
    }

    /**
     * Update scene scale using SLAM data.
     *
     * @param isInitialPairOfViews true if initial pair of views is being processed, false otherwise.
     * @return true if scale was successfully updated, false otherwise.
     */
    protected boolean updateScale(final boolean isInitialPairOfViews) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.html#L262">262</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.html#L224">224</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Returns quality scores corresponding to each provided view.
     * The larger the score value the better the quality of the sampled view.
     *
     * @return quality scores corresponding to each view.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided view.
     * The larger the score value the better the quality of the sampled view.
     *
     * @param qualityScores quality scores corresponding to each view.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than MIN_REQUIRED_VIEWS (i.e. 2 views).
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates if triangulator is ready to start the 3D point triangulation.
     * This is true when input data (i.e. 2D points, cameras and quality scores)
     * are provided and a minimum of 2 views are available.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == points2D.size();
    }


    /**
     * Triangulates provided matched 2D points being projected by each
     * corresponding camera into a single 3D point.
     * At least 2 matched 2D points and their corresponding 2 cameras are
     * required to compute triangulation. If more views are provided, an
     * averaged solution can be found.
     *
     * @return computed triangulated 3D point.
     * @throws LockedException          if this instance is locked.
     * @throws NotReadyException        if lists of points and cameras don't have the
     *                                  same length or less than 2 views are provided.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public Point3D triangulate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new PROMedSRobustEstimator&lt;Point3D&gt;(new PROMedSRobustEstimatorListener&lt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/MSACDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/MSACDualAbsoluteQuadricRobustEstimator.html#L101">101</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/RANSACDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/RANSACDualAbsoluteQuadricRobustEstimator.html#L100">100</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public MSACDualAbsoluteQuadricRobustEstimator(
            final List&lt;PinholeCamera&gt; cameras, final DualAbsoluteQuadricRobustEstimatorListener listener) {
        super(cameras, listener);
        threshold = DEFAULT_THRESHOLD;
    }

    /**
     * Returns threshold to determine whether cameras are inliers or not
     * when testing possible estimation solutions.
     * The threshold refers to the amount of error a possible solution has.
     *
     * @return threshold to determine whether cameras are inliers when testing
     * possible estimation solutions.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether cameras are inliers or not when
     * testing possible estimation solutions.
     * The threshold refers to the amount of error a possible solution has.
     *
     * @param threshold threshold to determine whether cameras are inliers or
     *                  not when testing possible estimation solutions.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Estimates the Dual Absolute Quadric using provided cameras.
     *
     * @return estimated Dual Absolute Quadric (DAQ).
     * @throws LockedException          if robust estimator is locked.
     * @throws NotReadyException        if no valid input data has already been
     *                                  provided.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public DualAbsoluteQuadric estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new MSACRobustEstimator&lt;DualAbsoluteQuadric&gt;(new MSACRobustEstimatorListener&lt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/MSACImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/MSACImageOfAbsoluteConicRobustEstimator.html#L107">107</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/RANSACImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/RANSACImageOfAbsoluteConicRobustEstimator.html#L106">106</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>public MSACImageOfAbsoluteConicRobustEstimator(
            final List&lt;Transformation2D&gt; homographies, final ImageOfAbsoluteConicRobustEstimatorListener listener) {
        super(homographies, listener);
        threshold = DEFAULT_THRESHOLD;
    }

    /**
     * Returns threshold to determine whether homographies are inliers or not
     * when testing possible estimation solutions.
     * The threshold refers to the amount of error a possible solution has on
     * the ortho-normality assumption of rotation matrices.
     *
     * @return threshold to determine whether homographies are inliers or not
     * when testing possible estimation solutions.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether homographies are inliers or not when
     * testing possible estimation solutions.
     * The threshold refers to the amount of error a possible solution has on
     * the ortho-normality assumption of rotation matrices.
     *
     * @param threshold threshold to determine whether homographies are inliers
     *                  or not when testing possible estimation solutions.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Estimates Image of Absolute Conic (IAC).
     *
     * @return estimated IAC.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws NotReadyException        if provided input data is not enough to start
     *                                  the estimation.
     * @throws RobustEstimatorException if estimation fails for any reason
     *                                  (i.e. numerical instability, no solution available, etc).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public ImageOfAbsoluteConic estimate() throws LockedException, NotReadyException, RobustEstimatorException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (!isReady()) {
            throw new NotReadyException();
        }

        final var innerEstimator = new MSACRobustEstimator&lt;ImageOfAbsoluteConic&gt;(new MSACRobustEstimatorListener&lt;&gt;() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1216">1216</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L931">931</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>metricReconstructedPoints = new ArrayList&lt;&gt;();
            final var points = new ArrayList&lt;Point2D&gt;();
            final var numPoints = correctedPoints1.size();
            Point3D triangulatedPoint;
            ReconstructedPoint3D reconstructedPoint;
            for (var i = 0; i &lt; numPoints; i++) {
                points.clear();
                points.add(correctedPoints1.get(i));
                points.add(correctedPoints2.get(i));

                triangulator.setPointsAndCameras(points, cameras);
                triangulatedPoint = triangulator.triangulate();

                reconstructedPoint = new ReconstructedPoint3D();
                reconstructedPoint.setPoint(triangulatedPoint);

                // only points reconstructed in front of both cameras are
                // considered valid
                final var front1 = camera1.isPointInFrontOfCamera(triangulatedPoint);
                final var front2 = camera2.isPointInFrontOfCamera(triangulatedPoint);
                reconstructedPoint.setInlier(front1 &amp;&amp; front2);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.html#L584">584</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/RANSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/RANSACFundamentalMatrixRobustEstimator.html#L375">375</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}
        });

        try {
            locked = true;
            inliersData = null;
            innerEstimator.setComputeAndKeepInliersEnabled(computeAndKeepInliers || refineResult);
            innerEstimator.setComputeAndKeepResidualsEnabled(computeAndKeepResiduals || refineResult);
            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            return attemptRefine(result);
        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROSAC;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1376">1376</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L1061">1061</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var samples2 = currentEstimatedFundamentalMatrix.getRightSamples();

        final var points1 = new ArrayList&lt;Point2D&gt;();
        final var points2 = new ArrayList&lt;Point2D&gt;();
        final var length = samples1.size();
        for (var i = 0; i &lt; length; i++) {
            final var sample1 = samples1.get(i);
            final var sample2 = samples2.get(i);

            final var point1 = sample1.getPoint();
            final var point2 = sample2.getPoint();

            points1.add(point1);
            points2.add(point2);
        }

        try {
            final var estimator = new EssentialMatrixInitialCamerasEstimator(fundamentalMatrix, intrinsic1, intrinsic2,
                    points1, points2);

            estimator.setCorrectorType(configuration.getPairedCamerasCorrectorType());</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROMedSDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSDualAbsoluteQuadricRobustEstimator.html#L190">190</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/PROMedSFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PROMedSFundamentalMatrixRobustEstimator.html#L361">361</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.html#L205">205</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the PROMedS algorithm iterating
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the PROMedS algorithm iterating
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.stopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each provided camera.
     * The larger the score value the better the quality of the sampled
     * camera.
     *
     * @return quality scores corresponding to each camera.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided camera.
     * The larger the score value the better the quality of the sampled
     * camera.
     *
     * @param qualityScores quality scores corresponding to each camera.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than minimum required number of cameras (i.e. 2 cameras).
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates if estimator is ready to start the DAQ estimation.
     * This is true when input data (i.e. cameras) is provided and list contains
     * at least the minimum number of required cameras, and also quality scores
     * are provided.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == cameras.size();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROMedSImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSImageOfAbsoluteConicRobustEstimator.html#L198">198</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/PROMedSFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PROMedSFundamentalMatrixRobustEstimator.html#L361">361</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the PROMedS algorithm iterating
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the PROMedS algorithm iterating
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.stopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each provided homography.
     * The larger the score value the better the quality of the sampled
     * homography
     *
     * @return quality scores corresponding to each homography.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided homography.
     * The larger the score value the better the quality of the sampled
     * homography.
     *
     * @param qualityScores quality scores corresponding to each homography.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than minimum required number of homographies (i.e. 1
     *                                  homography).
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates if estimator is ready to start the IAC estimation.
     * This is true when input data (i.e. homographies) is provided and list
     * contains at least the minimum number of required homographies, and
     * also quality scores are provided.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == homographies.size();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROMedSRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSRadialDistortionRobustEstimator.html#L289">289</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/PROMedSFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PROMedSFundamentalMatrixRobustEstimator.html#L361">361</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm iterating
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @return stop threshold to stop the algorithm prematurely when a certain
     * accuracy has been reached.
     */
    public double getStopThreshold() {
        return stopThreshold;
    }

    /**
     * Sets threshold to be used to keep the algorithm iterating in case that
     * best estimated threshold using median of residuals is not small enough.
     * Once a solution is found that generates a threshold below this value, the
     * algorithm will stop.
     * The stop threshold can be used to prevent the LMedS algorithm iterating
     * too many times in cases where samples have a very similar accuracy.
     * For instance, in cases where proportion of outliers is very small (close
     * to 0%), and samples are very accurate (i.e. 1e-6), the algorithm would
     * iterate for a long time trying to find the best solution when indeed
     * there is no need to do that if a reasonable threshold has already been
     * reached.
     * Because of this behaviour the stop threshold can be set to a value much
     * lower than the one typically used in RANSAC, and yet the algorithm could
     * still produce even smaller thresholds in estimated results.
     *
     * @param stopThreshold stop threshold to stop the algorithm prematurely
     *                      when a certain accuracy has been reached.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setStopThreshold(final double stopThreshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (stopThreshold &lt;= MIN_STOP_THRESHOLD) {
            throw new IllegalArgumentException();
        }

        this.stopThreshold = stopThreshold;
    }

    /**
     * Returns quality scores corresponding to each provided point.
     * The larger the score value the better the quality of the sampled point.
     *
     * @return quality scores corresponding to each point.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided point.
     * The larger the score value the better the quality of the sampled point.
     *
     * @param qualityScores quality scores corresponding to each point.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than MINIMUM_SIZE (i.e. 3 samples).
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates if estimator is ready to start the radial distortion
     * estimation.
     * This is true when input data (i.e. 2D points and quality scores) are
     * provided and a minimum of 2 points are available.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == distortedPoints.size();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROSACDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACDualAbsoluteQuadricRobustEstimator.html#L178">178</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.html#L350">350</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.html#L188">188</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to determine whether cameras are inliers or not when
     * testing possible estimation solutions.
     * The threshold refers to the amount of error a possible solution has.
     *
     * @return threshold to determine whether cameras are inliers or not when
     * testing possible estimation solutions.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether cameras are inliers or not when
     * testing possible estimation solutions.
     * The threshold refers to the amount of error a possible solution has.
     *
     * @param threshold threshold to determine whether cameras are inliers or
     *                  not when testing possible estimation solutions.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each provided camera.
     * The larger the score value the better the quality of the sampled camera.
     *
     * @return quality scores corresponding to each camera.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided camera.
     * The larger the score value the better the quality of the sampled camera.
     *
     * @param qualityScores quality scores corresponding to each camera.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than minimum required number of cameras (i.e. 2 cameras).
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates if estimator is ready to start the DAQ estimation.
     * This is true when input data (i.e. cameras) is provided and contains
     * at least the minimum number of required cameras, and also quality scores
     * are provided.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == cameras.size();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROSACImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACImageOfAbsoluteConicRobustEstimator.html#L186">186</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.html#L350">350</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to determine whether homographies are inliers or not
     * when testing possible estimation solutions.
     * The threshold refers to the amount of error a possible solution has on
     * the ortho-normality assumption of rotation matrices.
     *
     * @return threshold to determine whether homographies are inliers or not
     * when testing possible estimation solutions.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether homographies are inliers or not when
     * testing possible estimation solutions.
     * The threshold refers to the amount of error a possible solution has on
     * the ortho-normality assumption of rotation matrices.
     *
     * @param threshold threshold to determine whether homographies are inliers
     *                  or not when testing possible estimation solutions.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each provided homography.
     * The larger the score value the better the quality of the sampled
     * homography
     *
     * @return quality scores corresponding to each homography.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided homography.
     * The larger the score value the better the quality of the sampled
     * homography
     *
     * @param qualityScores quality scores corresponding to each homography
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than minimum required number of homographies (i.e. 1
     *                                  homography)
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates if estimator is ready to start the IAC estimation.
     * This is true when input data (i.e. homographies) is provided and list
     * contains at least the minimum number of required homographies, and
     * also quality scores are provided.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == homographies.size();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.html#L271">271</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PROSACFundamentalMatrixRobustEstimator.html#L350">350</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>internalSetQualityScores(qualityScores);
    }

    /**
     * Returns threshold to determine whether points are inliers or not when
     * testing possible estimation solutions.
     * The threshold refers to the amount of error (i.e. Euclidean distance) a
     * possible solution has on projected 2D points.
     *
     * @return threshold to determine whether points are inliers or not when
     * testing possible estimation solutions.
     */
    public double getThreshold() {
        return threshold;
    }

    /**
     * Sets threshold to determine whether points are inliers or not when
     * testing possible estimation solutions.
     * The threshold refers to the amount of error (i.e. Euclidean distance) a
     * possible solution has on projected 2D points.
     *
     * @param threshold threshold to be set.
     * @throws IllegalArgumentException if provided value is equal or less than
     *                                  zero.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     */
    public void setThreshold(final double threshold) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (threshold &lt;= MIN_THRESHOLD) {
            throw new IllegalArgumentException();
        }
        this.threshold = threshold;
    }

    /**
     * Returns quality scores corresponding to each provided point.
     * The larger the score value the better the quality of the sampled point.
     *
     * @return quality scores corresponding to each point.
     */
    @Override
    public double[] getQualityScores() {
        return qualityScores;
    }

    /**
     * Sets quality scores corresponding to each provided point.
     * The larger the score value the better the quality of the sampled point.
     *
     * @param qualityScores quality scores corresponding to each point.
     * @throws LockedException          if robust estimator is locked because an
     *                                  estimation is already in progress.
     * @throws IllegalArgumentException if provided quality scores length is
     *                                  smaller than MINIMUM_SIZE (i.e. 2 samples).
     */
    @Override
    public void setQualityScores(final double[] qualityScores) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        internalSetQualityScores(qualityScores);
    }

    /**
     * Indicates if estimator is ready to start the radial distortion
     * estimation.
     * This is true when input data (i.e. 2D points and quality scores) are
     * provided and a minimum of 2 points are available.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
        return super.isReady() &amp;&amp; qualityScores != null &amp;&amp; qualityScores.length == distortedPoints.size();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1071">1071</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1126">1126</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var fundamentalMatrix = currentEstimatedFundamentalMatrix.getFundamentalMatrix();

            final var estimator = new DualAbsoluteQuadricInitialCamerasEstimator(fundamentalMatrix);
            estimator.setAspectRatio(configuration.getPairedCamerasAspectRatio());
            estimator.estimate();

            final var camera1 = estimator.getEstimatedLeftCamera();
            final var camera2 = estimator.getEstimatedRightCamera();

            camera1.decompose();
            camera2.decompose();

            final var intrinsicZeroPrincipalPoint1 = camera1.getIntrinsicParameters();
            final var intrinsicZeroPrincipalPoint2 = camera2.getIntrinsicParameters();

            final var principalPointX = configuration.getPrincipalPointX();
            final var principalPointY = configuration.getPrincipalPointY();

            final var intrinsic1 = new PinholeCameraIntrinsicParameters(intrinsicZeroPrincipalPoint1);
            intrinsic1.setHorizontalPrincipalPoint(intrinsic1.getHorizontalPrincipalPoint() + principalPointX);
            intrinsic1.setVerticalPrincipalPoint(intrinsic1.getVerticalPrincipalPoint() + principalPointY);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructor.html#L213">213</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.html#L164">164</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var calibrationData = configuration.getCalibrationData();
        if (calibrationData != null) {
            slamEstimator.setCalibrationData(calibrationData);
        }
    }

    /**
     * Configures listener of SLAM estimator
     */
    protected void setUpSlamEstimatorListener() {
        slamEstimator.setListener(new BaseSlamEstimator.BaseSlamEstimatorListener&lt;&gt;() {
            @Override
            public void onFullSampleReceived(final BaseSlamEstimator&lt;D&gt; estimator) {
                // not used
            }

            @Override
            public void onFullSampleProcessed(final BaseSlamEstimator&lt;D&gt; estimator) {
                notifySlamStateAndCamera();
            }

            @Override
            public void onCorrectWithPositionMeasure(final BaseSlamEstimator&lt;D&gt; estimator) {
                // not used
            }

            @Override
            public void onCorrectedWithPositionMeasure(final BaseSlamEstimator&lt;D&gt; estimator) {
                notifySlamStateAndCamera();
            }

            private void notifySlamStateAndCamera() {
                notifySlamStateIfNeeded();
                notifySlamCameraIfNeeded();
            }
        });
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1848">1848</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L794">794</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L841">841</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>fundamentalMatrix.normalize();

            final var estimator = new DualAbsoluteQuadricInitialCamerasEstimator(fundamentalMatrix);
            estimator.setAspectRatio(configuration.getInitialCamerasAspectRatio());
            estimator.estimate();

            final var camera1 = estimator.getEstimatedLeftCamera();
            final var camera2 = estimator.getEstimatedRightCamera();

            camera1.decompose();
            camera2.decompose();

            final var intrinsicZeroPrincipalPoint1 = camera1.getIntrinsicParameters();
            final var intrinsicZeroPrincipalPoint2 = camera2.getIntrinsicParameters();

            final var principalPointX = configuration.getPrincipalPointX();
            final var principalPointY = configuration.getPrincipalPointY();

            final var intrinsic1 = new PinholeCameraIntrinsicParameters(intrinsicZeroPrincipalPoint1);
            intrinsic1.setHorizontalPrincipalPoint(intrinsic1.getHorizontalPrincipalPoint() + principalPointX);
            intrinsic1.setVerticalPrincipalPoint(intrinsic1.getVerticalPrincipalPoint() + principalPointY);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/LMSEInhomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/LMSEInhomogeneousSinglePoint3DTriangulator.html#L219">219</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/LMSEInhomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/LMSEInhomogeneousSinglePoint3DTriangulator.html#L238">238</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/WeightedInhomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/WeightedInhomogeneousSinglePoint3DTriangulator.html#L376">376</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/WeightedInhomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/WeightedInhomogeneousSinglePoint3DTriangulator.html#L398">398</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>b[row] = homW * verticalAxisPlane.getD() - homX * principalPlane.getD();

                // normalize equation to increase accuracy
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(row, 0), 2.0)
                        + Math.pow(a.getElementAt(row, 1), 2.0)
                        + Math.pow(a.getElementAt(row, 2), 2.0));

                a.setElementAt(row, 0, a.getElementAt(row, 0) / rowNorm);
                a.setElementAt(row, 1, a.getElementAt(row, 1) / rowNorm);
                a.setElementAt(row, 2, a.getElementAt(row, 2) / rowNorm);
                b[row] /= rowNorm;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L721">721</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L1017">1017</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>|| jacobianU.getColumns() != CONTROL_WITH_ROTATION_ADJUSTMENT_COMPONENTS)) {
            throw new IllegalArgumentException(&quot;jacobian wrt u must be 16x13&quot;);
        }

        // position
        final var r = new InhomogeneousPoint3D(x[0], x[1], x[2]);

        // orientation
        var q = new Quaternion(x[3], x[4], x[5], x[6]);

        // linear velocity
        var vx = x[7];
        var vy = x[8];
        var vz = x[9];

        // linear acceleration
        var ax = x[10];
        var ay = x[11];
        var az = x[12];

        // angular velocity
        var wx = x[13];
        var wy = x[14];
        var wz = x[15];

        // rotation change (control)
        final var dq = new Quaternion(u[0], u[1], u[2], u[3]);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L467">467</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L609">609</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

            final var decomposer = new SingularValueDecomposer(a);
            decomposer.decompose();

            if (decomposer.getNullity() &gt; 1) {
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
                throw new ImageOfAbsoluteConicEstimatorException();
            }

            final var v = decomposer.getV();

            // use last column of V as IAC vector

            // the last column of V contains IAC matrix (B), which is symmetric
            // and positive definite, ordered as follows: B11, B12, B22, B13,
            // B23, B33
            final var b11 = v.getElementAt(0, 4);
            final var b22 = v.getElementAt(1, 4);
            final var b13 = v.getElementAt(2, 4);
            final var b23 = v.getElementAt(3, 4);
            final var b33 = v.getElementAt(4, 4);

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
            // Since skewness is zero b12 = B = 0.0
            return new ImageOfAbsoluteConic(b11, 0.0, b22, b13, b23, b33);
        } catch (final AlgebraException e) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L144">144</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L425">425</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>|| jacobianU.getColumns() != CONTROL_COMPONENTS)) {
            // jacobian wrt u must be 16x9
            throw new IllegalArgumentException();
        }

        // position
        final var r = new InhomogeneousPoint3D(x[0], x[1], x[2]);

        // orientation
        var q = new Quaternion(x[3], x[4], x[5], x[6]);

        // linear velocity
        var vx = x[7];
        var vy = x[8];
        var vz = x[9];

        // linear acceleration
        var ax = x[10];
        var ay = x[11];
        var az = x[12];

        // angular velocity
        var wx = x[13];
        var wy = x[14];
        var wz = x[15];

        // linear velocity change (control)
        final var uvx = u[0];</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L815">815</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L1106">1106</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12 + h21 * h22 / sqrAspectRatio);
                a.setElementAt(counter, 1, h11 * h32 + h31 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L991">991</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L960">960</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>homography.asMatrix(h);
                    if (t == null) {
                        t = new ProjectiveTransformation2D(h);
                    } else {
                        t.setT(h);
                    }

                    // normalize
                    t.normalize();

                    // obtain elements of projective transformation matrix
                    // there is no need to retrieve internal matrix h, as we already
                    // hold a reference
                    h11 = h.getElementAt(0, 0);
                    h12 = h.getElementAt(0, 1);

                    h21 = h.getElementAt(1, 0);
                    h22 = h.getElementAt(1, 1);

                    h31 = h.getElementAt(2, 0);
                    h32 = h.getElementAt(2, 1);

                    // fill first equation
                    a.setElementAt(counter, 0, h11 * h12 + h21 * h22 / sqrAspectRatio);
                    a.setElementAt(counter, 1, h31 * h32);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L853">853</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L594">594</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>currentEstimatedFundamentalMatrix.setRightSamples(rightSamples);

            return true;
        } catch (final Exception e) {
            return false;
        }
    }

    /**
     * Estimates fundamental matrix for provided matches, when 3D points lay in
     * a planar 3D scene.
     *
     * @param matches pairs of matches to find fundamental matrix.
     * @param viewId1 id of first view.
     * @param viewId2 id of second view.
     * @return true if estimation succeeded, false otherwise.
     */
    private boolean estimatePlanarFundamentalMatrix(final List&lt;MatchedSamples&gt; matches, final int viewId1,
                                                    final int viewId2) {
        if (matches == null) {
            return false;
        }

        final var count = matches.size();
        final var leftSamples = new ArrayList&lt;Sample2D&gt;();
        final var rightSamples = new ArrayList&lt;Sample2D&gt;();
        final var leftPoints = new ArrayList&lt;Point2D&gt;();
        final var rightPoints = new ArrayList&lt;Point2D&gt;();
        final var qualityScores = new double[count];
        final double principalPointX;
        final double principalPointY;
        if (configuration.getPairedCamerasEstimatorMethod() == InitialCamerasEstimatorMethod.DUAL_ABSOLUTE_QUADRIC</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationSlamEstimator.html#L621">621</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/SlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/SlamEstimator.html#L563">563</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>stateOrientation.normalize();

        // velocity
        stateVelocityX = x[7] = state.getElementAtIndex(7);
        stateVelocityY = x[8] = state.getElementAtIndex(8);
        stateVelocityZ = x[9] = state.getElementAtIndex(9);

        // linear acceleration
        stateAccelerationX = x[10] = state.getElementAtIndex(10);
        stateAccelerationY = x[11] = state.getElementAtIndex(11);
        stateAccelerationZ = x[12] = state.getElementAtIndex(12);

        // angular velocity
        stateAngularSpeedX = x[13] = state.getElementAtIndex(13);
        stateAngularSpeedY = x[14] = state.getElementAtIndex(14);
        stateAngularSpeedZ = x[15] = state.getElementAtIndex(15);
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L851">851</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L868">868</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 2, h31 * h32);

                    // normalize row
                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                            + Math.pow(a.getElementAt(counter, 1), 2.0)
                            + Math.pow(a.getElementAt(counter, 2), 2.0));
                    factor = weight / rowNorm;

                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);
                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);
                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);

                    counter++;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/LMSEHomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/LMSEHomogeneousSinglePoint3DTriangulator.html#L197">197</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/LMSEInhomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/LMSEInhomogeneousSinglePoint3DTriangulator.html#L198">198</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/WeightedInhomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/WeightedInhomogeneousSinglePoint3DTriangulator.html#L351">351</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>camera.fixCameraSign();

                final var homX = point.getHomX();
                final var homY = point.getHomY();
                final var homW = point.getHomW();

                // pick rows of camera corresponding to different planes
                // (we do not normalize planes, as it would introduce errors)

                // 1st camera row (p1T)
                camera.verticalAxisPlane(verticalAxisPlane);
                // 2nd camera row (p2T)
                camera.horizontalAxisPlane(horizontalAxisPlane);
                // 3rd camera row (p3T)
                camera.principalPlane(principalPlane);

                // 1st equation
                a.setElementAt(row, 0, homX * principalPlane.getA() - homW * verticalAxisPlane.getA());
                a.setElementAt(row, 1, homX * principalPlane.getB() - homW * verticalAxisPlane.getB());
                a.setElementAt(row, 2, homX * principalPlane.getC() - homW * verticalAxisPlane.getC());</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L880">880</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L1024">1024</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>counter++;
            }

            final var decomposer = new SingularValueDecomposer(a);
            decomposer.decompose();

            if (decomposer.getNullity() &gt; 1) {
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
                throw new ImageOfAbsoluteConicEstimatorException();
            }

            final var v = decomposer.getV();

            // use last column of V as IAC vector

            // the last column of V contains IAC matrix (B), which is symmetric
            // and positive definite, ordered as follows: B11, B12, B22, B13,
            // B23, B33
            final var b11 = v.getElementAt(0, 3);
            final var b13 = v.getElementAt(1, 3);
            final var b23 = v.getElementAt(2, 3);
            final var b33 = v.getElementAt(3, 3);

            final var b22 = b11 / sqrAspectRatio;

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
            // Since skewness is zero b12 = B = 0.0
            return new ImageOfAbsoluteConic(b11, 0.0, b22, b13, b23, b33);
        } catch (final AlgebraException e) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1216">1216</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1940">1940</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L931">931</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>metricReconstructedPoints = new ArrayList&lt;&gt;();
            final var points = new ArrayList&lt;Point2D&gt;();
            final var numPoints = correctedPoints1.size();
            Point3D triangulatedPoint;
            ReconstructedPoint3D reconstructedPoint;
            for (var i = 0; i &lt; numPoints; i++) {
                points.clear();
                points.add(correctedPoints1.get(i));
                points.add(correctedPoints2.get(i));

                triangulator.setPointsAndCameras(points, cameras);
                triangulatedPoint = triangulator.triangulate();

                reconstructedPoint = new ReconstructedPoint3D();
                reconstructedPoint.setPoint(triangulatedPoint);

                // only points reconstructed in front of both cameras are
                // considered valid
                final var front1 = camera1.isPointInFrontOfCamera(triangulatedPoint);
                final var front2 = camera2.isPointInFrontOfCamera(triangulatedPoint);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L374">374</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L877">877</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>throw new IllegalArgumentException();
        }

        // position
        final var r = new InhomogeneousPoint3D(x[0], x[1], x[2]);

        // orientation
        var q = new Quaternion(x[3], x[4], x[5], x[6]);

        // linear velocity
        var vx = x[7];
        var vy = x[8];
        var vz = x[9];

        // angular velocity
        var wx = x[10];
        var wy = x[11];
        var wz = x[12];

        // position change (control)
        final var drx = u[0];
        final var dry = u[1];
        final var drz = u[2];

        // linear velocity change (control)
        final var uvx = u[3];</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L244">244</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L988">988</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>double rowNorm;
            for (final var homography : homographies) {
                // convert homography into projective so it can be normalized
                homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L393">393</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L988">988</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>double rowNorm;
            for (final var homography : homographies) {
                // convert homography into projective so it can be normalized
                homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L538">538</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L988">988</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>double rowNorm;
            for (final var homography : homographies) {
                // convert homography into projective so it can be normalized
                homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L678">678</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L988">988</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>double rowNorm;
            for (final var homography : homographies) {
                // convert homography into projective so it can be normalized
                homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/EpipolarDistanceFundamentalMatrixComparator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/EpipolarDistanceFundamentalMatrixComparator.html#L628">628</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/EpipolarDistanceFundamentalMatrixComparator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/EpipolarDistanceFundamentalMatrixComparator.html#L713">713</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var xMaxY = -(maxY * l2real.getB() + l2real.getC()) / l2real.getA();

                    // if epipolar line does not intersect second image, we need
                    // to repeat with a different sample
                    repeat = (((yMinX &lt; minY) &amp;&amp; (yMaxX &lt; minY)) || ((yMinX &gt; maxY)
                            &amp;&amp; (yMaxX &gt; maxY)) || ((xMinY &lt; minX) &amp;&amp; (xMaxY &lt; minX))
                            || ((xMinY &gt; maxX) &amp;&amp; (xMaxY &gt; maxX)));
                    counter++;
                    currentIter++;
                }

                if (counter &gt;= nSamples) {
                    continue;
                }

                // choose point lying on epipolar line l2real :
                // m2.getX() * l2real.getA() + m2.getY() * l2real.getB() +
                // l2real.getC() = 0
                // choose random horizontal component within provided disparity:
                inhomX = m1.getInhomX() + randomizer.nextDouble(minHorizontalDisparity, maxHorizontalDisparity);
                if (Math.abs(l2real.getB()) &gt; Double.MIN_VALUE) {
                    inhomY = -(inhomX * l2real.getA() + l2real.getC()) / l2real.getB();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1817">1817</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L810">810</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final double principalPointY = configuration.getPrincipalPointY();

            final var intrinsic1 = new PinholeCameraIntrinsicParameters(intrinsicZeroPrincipalPoint1);
            intrinsic1.setHorizontalPrincipalPoint(intrinsic1.getHorizontalPrincipalPoint() + principalPointX);
            intrinsic1.setVerticalPrincipalPoint(intrinsic1.getVerticalPrincipalPoint() + principalPointY);

            final var intrinsic2 = new PinholeCameraIntrinsicParameters(intrinsicZeroPrincipalPoint2);
            intrinsic2.setHorizontalPrincipalPoint(intrinsic2.getHorizontalPrincipalPoint() + principalPointX);
            intrinsic2.setVerticalPrincipalPoint(intrinsic2.getVerticalPrincipalPoint() + principalPointY);

            // fix fundamental matrix to account for principal point different
            // from zero
            fixFundamentalMatrix(fundamentalMatrix, intrinsicZeroPrincipalPoint1, intrinsicZeroPrincipalPoint2,
                    intrinsic1, intrinsic2);

            return estimateInitialCamerasAndPointsEssential(intrinsic1, intrinsic2);
        } catch (final Exception e) {
            return false;
        }
    }

    /**
     * Estimates initial cameras and reconstructed points using the Dual
     * Absolute Quadric.
     *
     * @return true if cameras and points could be estimated, false if something
     * failed.
     */
    private boolean estimateInitialCamerasAndPointsDAQ() {
        try {
            final var fundamentalMatrix = currentEstimatedFundamentalMatrix.getFundamentalMatrix();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/PositionPredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/PositionPredictor.html#L70">70</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/PositionPredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/PositionPredictor.html#L488">488</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>throw new IllegalArgumentException(&quot;jacobian wrt r must be 3x3&quot;);
        }
        if (jacobianV != null &amp;&amp; (jacobianV.getRows() != Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH
                || jacobianV.getColumns() != SPEED_COMPONENTS)) {
            throw new IllegalArgumentException(
                    &quot;jacobian wrt speed must be 3x3&quot;);
        }
        if (jacobianA != null &amp;&amp; (jacobianA.getRows() != Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH
                || jacobianA.getColumns() != ACCELERATION_COMPONENTS)) {
            throw new IllegalArgumentException(
                    &quot;jacobian wrt acceleration must be 3x3&quot;);
        }

        if (jacobianR != null) {
            // set to the identity
            jacobianR.initialize(0.0);
            jacobianR.setElementAt(0, 0, 1.0);
            jacobianR.setElementAt(1, 1, 1.0);
            jacobianR.setElementAt(2, 2, 1.0);
        }
        if (jacobianV != null) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L247">247</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L539">539</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L826">826</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);
                a.setElementAt(counter, 1, h11 * h22 + h21 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L396">396</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L389">389</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L685">685</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);
                a.setElementAt(counter, 1, h21 * h22);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L541">541</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L539">539</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L826">826</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);
                a.setElementAt(counter, 1, h11 * h22 + h21 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L681">681</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L389">389</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L685">685</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);
                a.setElementAt(counter, 1, h21 * h22);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L1022">1022</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L1138">1138</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);

                    counter++;

                    // fill second equation
                    a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0)
                            + (Math.pow(h21, 2.0) - Math.pow(h22, 2.0)) / sqrAspectRatio);
                    a.setElementAt(counter, 1, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));

                    // normalize row
                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                            + Math.pow(a.getElementAt(counter, 1), 2.0));</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L835">835</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1010">1010</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1539">1539</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final var inliersData = estimator.getInliersData();
            if (inliersData != null) {
                final var numInliers = inliersData.getNumInliers();
                final var inliers = inliersData.getInliers();
                final var length = inliers.length();
                var fundamentalMatrixQualityScore = 0.0;
                for (i = 0; i &lt; length; i++) {
                    if (inliers.get(i)) {
                        // inlier
                        fundamentalMatrixQualityScore += qualityScores[i] / numInliers;
                    }
                }
                currentEstimatedFundamentalMatrix.setQualityScore(fundamentalMatrixQualityScore);
                currentEstimatedFundamentalMatrix.setInliers(inliers);
            }

            // store left/right samples
            currentEstimatedFundamentalMatrix.setLeftSamples(leftSamples);
            currentEstimatedFundamentalMatrix.setRightSamples(rightSamples);

            return true;
        } catch (final Exception e) {
            return false;
        }
    }

    /**
     * Estimates fundamental matrix for provided matches, when 3D points lay in
     * a planar 3D scene.
     *
     * @param matches pairs of matches to find fundamental matrix.
     * @param viewId1 id of first view.
     * @param viewId2 id of second view.
     * @return true if estimation succeeded, false otherwise.
     */
    private boolean estimatePlanarFundamentalMatrix(final List&lt;MatchedSamples&gt; matches, final int viewId1,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L978">978</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L711">711</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>if (intrinsic1 == null &amp;&amp; intrinsic2 == null) {
                // estimate homography
                final var homography = homographyEstimator.estimate();

                // estimate intrinsic parameters using the Image of Absolute
                // Conic (IAC)
                final var homographies = new ArrayList&lt;Transformation2D&gt;();
                homographies.add(homography);

                final var iacEstimator = new LMSEImageOfAbsoluteConicEstimator(homographies);
                final var iac = iacEstimator.estimate();

                intrinsic1 = intrinsic2 = iac.getIntrinsicParameters();

            } else if (intrinsic1 == null) { // &amp;&amp; intrinsic2 != null
                intrinsic1 = intrinsic2;
            } else if (intrinsic2 == null) { // &amp;&amp; intrinsic1 != null
                intrinsic2 = intrinsic1;
            }
            fundamentalMatrixEstimator.setLeftIntrinsics(intrinsic1);
            fundamentalMatrixEstimator.setRightIntrinsics(intrinsic2);

            fundamentalMatrixEstimator.estimateAndReconstruct();

            final var fundamentalMatrix = fundamentalMatrixEstimator.getFundamentalMatrix();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L576">576</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L743">743</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var inliersData = estimator.getInliersData();
            if (inliersData != null) {
                final var numInliers = inliersData.getNumInliers();
                final var inliers = inliersData.getInliers();
                final var length = inliers.length();
                var fundamentalMatrixQualityScore = 0.0;
                for (i = 0; i &lt; length; i++) {
                    if (inliers.get(i)) {
                        // inlier
                        fundamentalMatrixQualityScore += qualityScores[i] / numInliers;
                    }
                }
                estimatedFundamentalMatrix.setQualityScore(fundamentalMatrixQualityScore);
                estimatedFundamentalMatrix.setInliers(inliers);
            }

            // store left/right samples
            estimatedFundamentalMatrix.setLeftSamples(leftSamples);
            estimatedFundamentalMatrix.setRightSamples(rightSamples);

            return true;
        } catch (final Exception e) {
            return false;
        }
    }

    /**
     * Estimates fundamental matrix for provided matches, when 3D points lay in
     * a planar 3D scene.
     *
     * @param matches pairs of matches to find fundamental matrix.
     * @param viewId1 id of first view.
     * @param viewId2 id of second view.
     * @return true if estimation succeeded, false otherwise.
     */
    private boolean estimatePlanarFundamentalMatrix(</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L146">146</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L722">722</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L1018">1018</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>throw new IllegalArgumentException();
        }

        // position
        final var r = new InhomogeneousPoint3D(x[0], x[1], x[2]);

        // orientation
        var q = new Quaternion(x[3], x[4], x[5], x[6]);

        // linear velocity
        var vx = x[7];
        var vy = x[8];
        var vz = x[9];

        // linear acceleration
        var ax = x[10];
        var ay = x[11];
        var az = x[12];

        // angular velocity
        var wx = x[13];
        var wy = x[14];
        var wz = x[15];

        // linear velocity change (control)
        final var uvx = u[0];</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L427">427</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L722">722</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>throw new IllegalArgumentException();
        }

        // position
        final var r = new InhomogeneousPoint3D(x[0], x[1], x[2]);

        // orientation
        var q = new Quaternion(x[3], x[4], x[5], x[6]);

        // linear velocity
        var vx = x[7];
        var vy = x[8];
        var vz = x[9];

        // linear acceleration
        var ax = x[10];
        var ay = x[11];
        var az = x[12];

        // angular velocity
        var wx = x[13];
        var wy = x[14];
        var wz = x[15];

        // position change (control)
        final var drx = u[0];</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L706">706</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L722">722</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 2, h31 * h32);

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0));

                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);
                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);
                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);

                counter++;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L835">835</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1733">1733</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var inliersData = estimator.getInliersData();
            if (inliersData != null) {
                final var numInliers = inliersData.getNumInliers();
                final var inliers = inliersData.getInliers();
                final var length = inliers.length();
                var fundamentalMatrixQualityScore = 0.0;
                for (i = 0; i &lt; length; i++) {
                    if (inliers.get(i)) {
                        // inlier
                        fundamentalMatrixQualityScore += qualityScores[i] / numInliers;
                    }
                }
                currentEstimatedFundamentalMatrix.setQualityScore(fundamentalMatrixQualityScore);
                currentEstimatedFundamentalMatrix.setInliers(inliers);
            }

            // store left/right samples
            currentEstimatedFundamentalMatrix.setLeftSamples(leftSamples);
            currentEstimatedFundamentalMatrix.setRightSamples(rightSamples);

            return true;
        } catch (final Exception e) {
            return false;
        }
    }

    /**
     * Estimates fundamental matrix for provided matches, when 3D points lay in
     * a planar 3D scene.
     *
     * @param matches pairs of matches to find fundamental matrix.
     * @param viewId1 id of first view.
     * @param viewId2 id of second view.
     * @return true if estimation succeeded, false otherwise.
     */
    private boolean estimatePlanarFundamentalMatrix(final List&lt;MatchedSamples&gt; matches, final int viewId1,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/refiners/HomogeneousRightEpipoleRefiner.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/refiners/HomogeneousRightEpipoleRefiner.html#L190">190</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/refiners/InhomogeneousRightEpipoleRefiner.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/refiners/InhomogeneousRightEpipoleRefiner.html#L194">194</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>private final FundamentalMatrix fundMatrix = new FundamentalMatrix();

                    private final GradientEstimator gradientEstimator = new GradientEstimator(point -&gt; {
                        try {
                            epipole.setCoordinates(point);
                            computeFundamentalMatrix(homography, epipole, fundMatrix);
                            return residual(fundMatrix, leftPoint, rightPoint);
                        } catch (final InvalidFundamentalMatrixException e) {
                            throw new EvaluationException(e);
                        }
                    });

                    @Override
                    public int getNumberOfDimensions() {
                        return nDims;
                    }

                    @Override
                    public double[] createInitialParametersArray() {
                        return initParams;
                    }

                    @Override
                    public double evaluate(final int i, final double[] point, final double[] params,
                                           final double[] derivatives) throws EvaluationException {
                        try {
                            leftPoint.setHomogeneousCoordinates(point[0], point[1], point[2]);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1172">1172</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1265">1265</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1375">1375</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1896">1896</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1988">1988</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L2078">2078</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var samples1 = currentEstimatedFundamentalMatrix.getLeftSamples();
            final var samples2 = currentEstimatedFundamentalMatrix.getRightSamples();

            final var points1 = new ArrayList&lt;Point2D&gt;();
            final var points2 = new ArrayList&lt;Point2D&gt;();
            final var length = samples1.size();
            for (var i = 0; i &lt; length; i++) {
                final var sample1 = samples1.get(i);
                final var sample2 = samples2.get(i);

                final var point1 = sample1.getPoint();
                final var point2 = sample2.getPoint();

                points1.add(point1);
                points2.add(point2);
            }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L887">887</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L973">973</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L1060">1060</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>final var samples1 = estimatedFundamentalMatrix.getLeftSamples();
            final var samples2 = estimatedFundamentalMatrix.getRightSamples();

            final var points1 = new ArrayList&lt;Point2D&gt;();
            final var points2 = new ArrayList&lt;Point2D&gt;();
            final var length = samples1.size();
            for (var i = 0; i &lt; length; i++) {
                final var sample1 = samples1.get(i);
                final var sample2 = samples2.get(i);

                final var point1 = sample1.getPoint();
                final var point2 = sample2.getPoint();

                points1.add(point1);
                points2.add(point2);
            }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L230">230</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L190">190</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>protected BasePairedViewsSparseReconstructor(final C configuration, final L listener) {
        if (configuration == null || listener == null) {
            throw new NullPointerException();
        }
        this.configuration = configuration;
        this.listener = listener;
    }

    /**
     * Gets configuration for this re-constructor.
     *
     * @return configuration for this reconstructor.
     */
    public C getConfiguration() {
        return configuration;
    }

    /**
     * Gets listener in charge of handling events such as when reconstruction
     * starts, ends, when certain data is needed or when estimation of data has
     * been computed.
     *
     * @return listener in charge of handling events.
     */
    public L getListener() {
        return listener;
    }

    /**
     * Indicates whether reconstruction is running or not.
     *
     * @return true if reconstruction is running, false if reconstruction has
     * stopped for any reason.
     */
    public boolean isRunning() {
        return running;
    }

    /**
     * Indicates whether reconstruction has been cancelled or not.
     *
     * @return true if reconstruction has been cancelled, false otherwise.
     */
    public boolean isCancelled() {
        return cancelled;
    }

    /**
     * Indicates whether reconstruction has failed or not.
     *
     * @return true if reconstruction has failed, false otherwise.
     */
    public boolean hasFailed() {
        return failed;
    }

    /**
     * Indicates whether the reconstruction has finished.
     *
     * @return true if reconstruction has finished, false otherwise.
     */
    public boolean isFinished() {
        return finished;
    }

    /**
     * Gets counter of number of processed views.
     *
     * @return counter of number of processed views.
     */
    public int getViewCount() {
        return viewCount;
    }

    /**
     * Gets estimated fundamental matrix for current view.
     * This fundamental matrix relates current view with the previously processed one.
     *
     * @return current estimated fundamental matrix.
     */
    public EstimatedFundamentalMatrix getCurrentEstimatedFundamentalMatrix() {
        return currentEstimatedFundamentalMatrix;
    }

    /**
     * Gets estimated euclidean camera for current view (i.e. with actual scale).
     *
     * @return current estimated euclidean camera.
     */
    public EstimatedCamera getCurrentEuclideanEstimatedCamera() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROMedSDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROMedSDualAbsoluteQuadricRobustEstimator.html#L388">388</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROSACDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACDualAbsoluteQuadricRobustEstimator.html#L355">355</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/PROSACImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACImageOfAbsoluteConicRobustEstimator.html#L369">369</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/PROSACRadialDistortionRobustEstimator.html#L473">473</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROMedSRobustSinglePoint3DTriangulator.html#L428">428</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PROSACRobustSinglePoint3DTriangulator.html#L387">387</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>listener.onEstimateProgressChange(PROMedSDualAbsoluteQuadricRobustEstimator.this,
                            progress);
                }
            }

            @Override
            public double[] getQualityScores() {
                return qualityScores;
            }
        });

        try {
            locked = true;
            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            return innerEstimator.estimate();
        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.PROMEDS;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/PROMedSFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PROMedSFundamentalMatrixRobustEstimator.html#L501">501</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/RANSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/RANSACFundamentalMatrixRobustEstimator.html#L309">309</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

                    @Override
                    public int getTotalSamples() {
                        return leftPoints.size();
                    }

                    @Override
                    public int getSubsetSize() {
                        return getMinRequiredPoints();
                    }

                    @Override
                    public void estimatePreliminarSolutions(
                            final int[] samplesIndices, final List&lt;FundamentalMatrix&gt; solutions) {

                        subsetLeftPoints.clear();
                        subsetRightPoints.clear();
                        for (final var samplesIndex : samplesIndices) {
                            subsetLeftPoints.add(leftPoints.get(samplesIndex));
                            subsetRightPoints.add(rightPoints.get(samplesIndex));
                        }

                        nonRobustEstimate(solutions, subsetLeftPoints, subsetRightPoints);
                    }

                    @Override
                    public double computeResidual(final FundamentalMatrix currentEstimation, final int i) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/LMedSFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/LMedSFundamentalMatrixRobustEstimator.html#L270">270</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/RANSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/RANSACFundamentalMatrixRobustEstimator.html#L311">311</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>@Override
            public int getTotalSamples() {
                return leftPoints.size();
            }

            @Override
            public int getSubsetSize() {
                return getMinRequiredPoints();
            }

            @Override
            public void estimatePreliminarSolutions(
                    final int[] samplesIndices, final List&lt;FundamentalMatrix&gt; solutions) {

                subsetLeftPoints.clear();
                subsetRightPoints.clear();
                for (final var samplesIndex : samplesIndices) {
                    subsetLeftPoints.add(leftPoints.get(samplesIndex));
                    subsetRightPoints.add(rightPoints.get(samplesIndex));
                }

                nonRobustEstimate(solutions, subsetLeftPoints, subsetRightPoints);
            }

            @Override
            public double computeResidual(final FundamentalMatrix currentEstimation, final int i) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/MSACFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/MSACFundamentalMatrixRobustEstimator.html#L298">298</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/estimators/PROMedSFundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/PROMedSFundamentalMatrixRobustEstimator.html#L574">574</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}
        });

        try {
            locked = true;
            inliersData = null;
            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            final var result = innerEstimator.estimate();
            inliersData = innerEstimator.getInliersData();
            return attemptRefine(result);
        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.MSAC;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1191">1191</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L906">906</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final List&lt;Point2D&gt; correctedPoints2;
            if (corrector != null) {
                corrector.setLeftAndRightPoints(points1, points2);
                corrector.correct();

                correctedPoints1 = corrector.getLeftCorrectedPoints();
                correctedPoints2 = corrector.getRightCorrectedPoints();
            } else {
                correctedPoints1 = points1;
                correctedPoints2 = points2;
            }

            // triangulate points
            final SinglePoint3DTriangulator triangulator;
            if (configuration.getDaqUseHomogeneousPointTriangulator()) {
                triangulator = SinglePoint3DTriangulator.create(Point3DTriangulatorType.LMSE_HOMOGENEOUS_TRIANGULATOR);
            } else {
                triangulator = SinglePoint3DTriangulator.create(
                        Point3DTriangulatorType.LMSE_INHOMOGENEOUS_TRIANGULATOR);
            }

            final var cameras = new ArrayList&lt;PinholeCamera&gt;();
            cameras.add(camera1);
            cameras.add(camera2);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1915">1915</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L906">906</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final List&lt;Point2D&gt; correctedPoints2;
            if (corrector != null) {
                corrector.setLeftAndRightPoints(points1, points2);
                corrector.correct();

                correctedPoints1 = corrector.getLeftCorrectedPoints();
                correctedPoints2 = corrector.getRightCorrectedPoints();
            } else {
                correctedPoints1 = points1;
                correctedPoints2 = points2;
            }

            // triangulate points
            final SinglePoint3DTriangulator triangulator;
            if (configuration.getDaqUseHomogeneousPointTriangulator()) {
                triangulator = SinglePoint3DTriangulator.create(Point3DTriangulatorType.LMSE_HOMOGENEOUS_TRIANGULATOR);
            } else {
                triangulator = SinglePoint3DTriangulator.create(
                        Point3DTriangulatorType.LMSE_INHOMOGENEOUS_TRIANGULATOR);
            }

            final var cameras = new ArrayList&lt;PinholeCamera&gt;();
            cameras.add(camera1);
            cameras.add(camera2);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L183">183</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L469">469</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L762">762</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L1063">1063</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var uwz = u[8];

        try {
            // update velocity
            final var vv = new Matrix(SPEED_COMPONENTS, SPEED_COMPONENTS);
            final var va = new Matrix(SPEED_COMPONENTS, ACCELERATION_COMPONENTS);
            final var v = VelocityPredictor.predict(vx, vy, vz, ax, ay, az, dt, vv, va);

            // update position
            Matrix rr = null;
            Matrix rv = null;
            Matrix ra = null;
            if (jacobianX != null) {
                rr = new Matrix(Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH,
                        Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH);
                rv = new Matrix(Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH, SPEED_COMPONENTS);
                ra = new Matrix(Point3D.POINT3D_INHOMOGENEOUS_COORDINATES_LENGTH, ACCELERATION_COMPONENTS);
            }
            PositionPredictor.predict(r, vx, vy, vz, ax, ay, az, dt, r, rr, rv, ra);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/ImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/ImageOfAbsoluteConicEstimator.html#L273">273</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/KruppaDualImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/KruppaDualImageOfAbsoluteConicEstimator.html#L222">222</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}

    /**
     * Returns boolean indicating whether aspect ratio of focal distances (i.e.
     * vertical focal distance divided by horizontal focal distance) is known or
     * not.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio. Typically, LCD sensor cells are square and hence aspect
     * ratio of focal distances is known and equal to 1.
     * This value is only taken into account if skewness is assumed to be zero,
     * otherwise it is ignored.
     *
     * @return true if focal distance aspect ratio is known, false otherwise.
     */
    public boolean isFocalDistanceAspectRatioKnown() {
        return focalDistanceAspectRatioKnown;
    }

    /**
     * Sets value indicating whether aspect ratio of focal distances (i.e.
     * vertical focal distance divided by horizontal focal distance) is known or
     * not.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio. Typically, LCD sensor cells are square and hence aspect
     * ratio of focal distances is known and equal to 1.
     * This value is only taken into account if skewness is assumed to be zero,
     * otherwise it is ignored.
     *
     * @param focalDistanceAspectRatioKnown true if focal distance aspect ratio
     *                                      is known, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFocalDistanceAspectRatioKnown(final boolean focalDistanceAspectRatioKnown) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }

        this.focalDistanceAspectRatioKnown = focalDistanceAspectRatioKnown;
    }

    /**
     * Returns aspect ratio of focal distances (i.e. vertical focal distance
     * divided by horizontal focal distance).
     * This value is only taken into account if skewness is assumed to be zero
     * and focal distance aspect ratio is marked as known, otherwise it is
     * ignored.
     * By default, this is 1.0, since it is taken into account that typically
     * LCD sensor cells are square and hence aspect ratio focal distances is
     * known and equal to 1.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio
     * Notice that a negative aspect ratio indicates that vertical axis is
     * reversed. This can be useful in some situations where image vertical
     * coordinates are reversed respect to the physical world (i.e. in computer
     * graphics typically image vertical coordinates go downwards, while in
     * physical world they go upwards).
     *
     * @return aspect ratio of focal distances.
     */
    public double getFocalDistanceAspectRatio() {
        return focalDistanceAspectRatio;
    }

    /**
     * Sets aspect ratio of focal distances (i.e. vertical focal distance
     * divided by horizontal focal distance).
     * This value is only taken into account if skewness is assumed to be zero
     * and focal distance aspect ratio is marked as known, otherwise it is
     * ignored.
     * By default, this is 1.0, since it is taken into account that typically
     * LCD sensor cells are square and hence aspect ratio focal distances is
     * known and equal to 1.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio.
     * Notice that a negative aspect ratio indicates that vertical axis is
     * reversed. This can be useful in some situations where image vertical
     * coordinates are reversed respect to the physical world (i.e. in computer
     * graphics typically image vertical coordinates go downwards, while in
     * physical world they go upwards).
     *
     * @param focalDistanceAspectRatio aspect ratio of focal distances to be
     *                                 set.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if focal distance aspect ratio is too
     *                                  close to zero, as it might produce numerical instabilities.
     */
    public void setFocalDistanceAspectRatio(final double focalDistanceAspectRatio) throws LockedException {
        if (isLocked()) {
            throw new LockedException();
        }
        if (Math.abs(focalDistanceAspectRatio) &lt; MIN_ABS_FOCAL_DISTANCE_ASPECT_RATIO) {
            throw new IllegalArgumentException();
        }

        this.focalDistanceAspectRatio = focalDistanceAspectRatio;
    }

    /**
     * Indicates whether this instance is locked.
     *
     * @return true if this estimator is busy estimating an IAC, false
     * otherwise.
     */
    public boolean isLocked() {
        return locked;
    }

    /**
     * Returns listener to be notified of events such as when estimation starts,
     * ends or estimation progress changes.
     *
     * @return listener to be notified of events.
     */
    public ImageOfAbsoluteConicEstimatorListener getListener() {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructor.html#L322">322</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/PairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/PairedViewsSparseReconstructor.html#L137">137</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>euclideanReconstructedPoint = new ReconstructedPoint3D();
                euclideanReconstructedPoint.setPoint(euclideanPoint);
                euclideanReconstructedPoint.setInlier(metricReconstructedPoint.isInlier());
                euclideanReconstructedPoint.setId(metricReconstructedPoint.getId());
                euclideanReconstructedPoint.setColorData(metricReconstructedPoint.getColorData());
                if (metricReconstructedPoint.getCovariance() != null) {
                    euclideanReconstructedPoint.setCovariance(metricReconstructedPoint.getCovariance()
                            .multiplyByScalarAndReturnNew(sqrScale));
                }
                euclideanReconstructedPoint.setQualityScore(metricReconstructedPoint.getQualityScore());
                euclideanReconstructedPoints.add(euclideanReconstructedPoint);
            }

        } catch (final AlgebraException e) {
            return false;
        }

        return super.transformPairOfCamerasAndPoints(isInitialPairOfViews, hasAbsoluteOrientation);
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamPairedViewsSparseReconstructor.html#L470">470</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSlamSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamSparseReconstructor.html#L418">418</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var positionZ = lastPosZ + slamEstimator.getStatePositionZ();
            slamPosition.setInhomogeneousCoordinates(positionX, positionY, positionZ);

            final var quaternionA = slamEstimator.getStateQuaternionA();
            final var quaternionB = slamEstimator.getStateQuaternionB();
            final var quaternionC = slamEstimator.getStateQuaternionC();
            final var quaternionD = slamEstimator.getStateQuaternionD();
            slamRotation.setA(quaternionA);
            slamRotation.setB(quaternionB);
            slamRotation.setC(quaternionC);
            slamRotation.setD(quaternionD);

            slamCamera.setIntrinsicAndExtrinsicParameters(intrinsicParameters, slamRotation, slamPosition);

            //noinspection unchecked
            listener.onSlamCameraEstimated((R) this, slamCamera);

        } catch (final GeometryException ignore) {
            // do nothing
        }
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L247">247</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L960">960</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L1106">1106</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L396">396</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L960">960</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L1106">1106</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L541">541</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L960">960</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L1106">1106</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L681">681</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L960">960</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L1106">1106</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L815">815</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L389">389</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L539">539</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L685">685</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L826">826</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>homography.asMatrix(h);
                if (t == null) {
                    t = new ProjectiveTransformation2D(h);
                } else {
                    t.setT(h);
                }

                // normalize
                t.normalize();

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
                h11 = h.getElementAt(0, 0);
                h12 = h.getElementAt(0, 1);

                h21 = h.getElementAt(1, 0);
                h22 = h.getElementAt(1, 1);

                h31 = h.getElementAt(2, 0);
                h32 = h.getElementAt(2, 1);

                // fill first equation
                a.setElementAt(counter, 0, h11 * h12 + h21 * h22 / sqrAspectRatio);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L991">991</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L389">389</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L539">539</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L685">685</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L826">826</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>homography.asMatrix(h);
                    if (t == null) {
                        t = new ProjectiveTransformation2D(h);
                    } else {
                        t.setT(h);
                    }

                    // normalize
                    t.normalize();

                    // obtain elements of projective transformation matrix
                    // there is no need to retrieve internal matrix h, as we already
                    // hold a reference
                    h11 = h.getElementAt(0, 0);
                    h12 = h.getElementAt(0, 1);

                    h21 = h.getElementAt(1, 0);
                    h22 = h.getElementAt(1, 1);

                    h31 = h.getElementAt(2, 0);
                    h32 = h.getElementAt(2, 1);

                    // fill first equation
                    a.setElementAt(counter, 0, h11 * h12 + h21 * h22 / sqrAspectRatio);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMedSDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMedSDualAbsoluteQuadricRobustEstimator.html#L265">265</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMedSImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMedSImageOfAbsoluteConicRobustEstimator.html#L272">272</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMedSRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMedSRadialDistortionRobustEstimator.html#L347">347</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/LMedSRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/LMedSRobustSinglePoint3DTriangulator.html#L304">304</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>listener.onEstimateProgressChange(LMedSDualAbsoluteQuadricRobustEstimator.this, progress);
                }
            }
        });

        try {
            locked = true;
            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            innerEstimator.setStopThreshold(stopThreshold);
            return innerEstimator.estimate();
        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.LMEDS;
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1266">1266</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L1061">1061</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var samples2 = currentEstimatedFundamentalMatrix.getRightSamples();

        final var points1 = new ArrayList&lt;Point2D&gt;();
        final var points2 = new ArrayList&lt;Point2D&gt;();
        final var length = samples1.size();
        for (var i = 0; i &lt; length; i++) {
            final var sample1 = samples1.get(i);
            final var sample2 = samples2.get(i);

            final var point1 = sample1.getPoint();
            final var point2 = sample2.getPoint();

            points1.add(point1);
            points2.add(point2);
        }

        try {
            final var estimator = new DualImageOfAbsoluteConicInitialCamerasEstimator(fundamentalMatrix, points1,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1376">1376</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L974">974</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var samples2 = currentEstimatedFundamentalMatrix.getRightSamples();

        final var points1 = new ArrayList&lt;Point2D&gt;();
        final var points2 = new ArrayList&lt;Point2D&gt;();
        final var length = samples1.size();
        for (var i = 0; i &lt; length; i++) {
            final var sample1 = samples1.get(i);
            final var sample2 = samples2.get(i);

            final var point1 = sample1.getPoint();
            final var point2 = sample2.getPoint();

            points1.add(point1);
            points2.add(point2);
        }

        try {
            final var estimator = new EssentialMatrixInitialCamerasEstimator(fundamentalMatrix, intrinsic1, intrinsic2,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1989">1989</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L1061">1061</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var samples2 = currentEstimatedFundamentalMatrix.getRightSamples();

        final var points1 = new ArrayList&lt;Point2D&gt;();
        final var points2 = new ArrayList&lt;Point2D&gt;();
        final var length = samples1.size();
        for (var i = 0; i &lt; length; i++) {
            final var sample1 = samples1.get(i);
            final var sample2 = samples2.get(i);

            final var point1 = sample1.getPoint();
            final var point2 = sample2.getPoint();

            points1.add(point1);
            points2.add(point2);
        }

        try {
            final var estimator = new DualImageOfAbsoluteConicInitialCamerasEstimator(fundamentalMatrix, points1,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L2079">2079</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L974">974</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final var samples2 = currentEstimatedFundamentalMatrix.getRightSamples();

        final var points1 = new ArrayList&lt;Point2D&gt;();
        final var points2 = new ArrayList&lt;Point2D&gt;();
        final var length = samples1.size();
        for (var i = 0; i &lt; length; i++) {
            final var sample1 = samples1.get(i);
            final var sample2 = samples2.get(i);

            final var point1 = sample1.getPoint();
            final var point2 = sample2.getPoint();

            points1.add(point1);
            points2.add(point2);
        }

        try {
            final var estimator = new EssentialMatrixInitialCamerasEstimator(fundamentalMatrix, intrinsic1, intrinsic2,</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L425">425</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L573">573</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L596">596</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>+ Math.pow(a.getElementAt(counter, 5), 2.0));
                    factor = weight / rowNorm;

                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);
                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);
                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);
                    a.setElementAt(counter, 3, a.getElementAt(counter, 3) * factor);
                    a.setElementAt(counter, 4, a.getElementAt(counter, 4) * factor);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L451">451</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L573">573</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L596">596</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>+ Math.pow(a.getElementAt(counter, 5), 2.0));
                    factor = weight / rowNorm;

                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);
                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);
                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);
                    a.setElementAt(counter, 3, a.getElementAt(counter, 3) * factor);
                    a.setElementAt(counter, 4, a.getElementAt(counter, 4) * factor);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1074">1074</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSparseReconstructor.html#L1851">1851</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L844">844</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>estimator.setAspectRatio(configuration.getPairedCamerasAspectRatio());
            estimator.estimate();

            final var camera1 = estimator.getEstimatedLeftCamera();
            final var camera2 = estimator.getEstimatedRightCamera();

            camera1.decompose();
            camera2.decompose();

            final var intrinsicZeroPrincipalPoint1 = camera1.getIntrinsicParameters();
            final var intrinsicZeroPrincipalPoint2 = camera2.getIntrinsicParameters();

            final var principalPointX = configuration.getPrincipalPointX();
            final var principalPointY = configuration.getPrincipalPointY();

            final var intrinsic1 = new PinholeCameraIntrinsicParameters(intrinsicZeroPrincipalPoint1);
            intrinsic1.setHorizontalPrincipalPoint(intrinsic1.getHorizontalPrincipalPoint() + principalPointX);
            intrinsic1.setVerticalPrincipalPoint(intrinsic1.getVerticalPrincipalPoint() + principalPointY);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BasePairedViewsSparseReconstructor.html#L1129">1129</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseTwoViewsSparseReconstructor.html#L797">797</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>estimator.setAspectRatio(configuration.getPairedCamerasAspectRatio());
            estimator.estimate();

            final var camera1 = estimator.getEstimatedLeftCamera();
            final var camera2 = estimator.getEstimatedRightCamera();

            camera1.decompose();
            camera2.decompose();

            final var intrinsicZeroPrincipalPoint1 = camera1.getIntrinsicParameters();
            final var intrinsicZeroPrincipalPoint2 = camera2.getIntrinsicParameters();

            final var principalPointX = configuration.getPrincipalPointX();
            final var principalPointY = configuration.getPrincipalPointY();

            final var intrinsic1 = new PinholeCameraIntrinsicParameters(intrinsicZeroPrincipalPoint1);
            intrinsic1.setHorizontalPrincipalPoint(intrinsic1.getHorizontalPrincipalPoint() + principalPointX);
            intrinsic1.setVerticalPrincipalPoint(intrinsic1.getVerticalPrincipalPoint() + principalPointY);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L306">306</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L445">445</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L443">443</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L589">589</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>a.setElementAt(counter, 5, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0)
                        + Math.pow(a.getElementAt(counter, 3), 2.0)
                        + Math.pow(a.getElementAt(counter, 4), 2.0)</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L275">275</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L417">417</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/WeightedImageOfAbsoluteConicEstimator.html#L443">443</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>a.setElementAt(counter, 5, h31 * h32);

                // normalize row
                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)
                        + Math.pow(a.getElementAt(counter, 1), 2.0)
                        + Math.pow(a.getElementAt(counter, 2), 2.0)
                        + Math.pow(a.getElementAt(counter, 3), 2.0)
                        + Math.pow(a.getElementAt(counter, 4), 2.0)
                        + Math.pow(a.getElementAt(counter, 5), 2.0));</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/FundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/FundamentalMatrixRobustEstimator.html#L728">728</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/refiners/RightEpipoleRefiner.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/refiners/RightEpipoleRefiner.html#L240">240</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>protected double residual(
            final FundamentalMatrix fundamentalMatrix, final Point2D leftPoint, final Point2D rightPoint) {
        try {
            leftPoint.normalize();
            rightPoint.normalize();
            fundamentalMatrix.normalize();
            fundamentalMatrix.leftEpipolarLine(rightPoint, testLine);
            final var leftDistance = Math.abs(testLine.signedDistance(leftPoint));
            fundamentalMatrix.rightEpipolarLine(leftPoint, testLine);
            final var rightDistance = Math.abs(testLine.signedDistance(rightPoint));
            // return average distance as an error residual
            return 0.5 * (leftDistance + rightDistance);
        } catch (final NotReadyException e) {
            return Double.MAX_VALUE;
        }
    }

    /**
     * Estimates a fundamental matrix using a non-robust method and provided
     * subset of matched points and stores the solution in provided array of
     * solutions.
     *
     * @param solutions         list where solutions will be stored.
     * @param subsetLeftPoints  subset of left view matched points.
     * @param subsetRightPoints subset of right view matched points.
     */
    protected void nonRobustEstimate(</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/LMSEHomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/LMSEHomogeneousSinglePoint3DTriangulator.html#L251">251</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/WeightedHomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/WeightedHomogeneousSinglePoint3DTriangulator.html#L407">407</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>}
            }

            // make SVD to find solution of A * M = 0
            final var decomposer = new SingularValueDecomposer(a);
            decomposer.decompose();

            if (decomposer.getNullity() &gt; 1) {
                // degenerate case. Unique solution (up to scale) cannot be found
                throw new Point3DTriangulationException();
            }

            final var v = decomposer.getV();

            // last column of v will contain homogeneous coordinates of
            // triangulated point
            result.setHomogeneousCoordinates(v.getElementAt(0, 3),
                    v.getElementAt(1, 3), v.getElementAt(2, 3),
                    v.getElementAt(3, 3));

            if (listener != null) {
                listener.onTriangulateEnd(this);
            }
        } catch (final AlgebraException | CameraException e) {</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.html#L562">562</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.html#L510">510</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/slam/SlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/SlamEstimator.html#L544">544</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>x[12] = state.getElementAtIndex(12);
    }

    /**
     * Updates state data of the device by using state matrix obtained from
     * Kalman filter after correction.
     *
     * @param state state matrix obtained from Kalman filter.
     */
    private void updateCorrectedState(final Matrix state) {
        // position
        statePositionX = x[0] = state.getElementAtIndex(0);
        statePositionY = x[1] = state.getElementAtIndex(1);
        statePositionZ = x[2] = state.getElementAtIndex(2);

        // quaternion
        stateQuaternionA = x[3] = state.getElementAtIndex(3);
        stateQuaternionB = x[4] = state.getElementAtIndex(4);
        stateQuaternionC = x[5] = state.getElementAtIndex(5);
        stateQuaternionD = x[6] = state.getElementAtIndex(6);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L194">194</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L226">226</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L513">513</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L810">810</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L1111">1111</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = wx;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L437">437</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L226">226</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L513">513</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L810">810</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L1111">1111</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = wx;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L686">686</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L226">226</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L513">513</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L810">810</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L1111">1111</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = wx;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L944">944</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L226">226</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L513">513</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L810">810</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/slam/StatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/StatePredictor.html#L1111">1111</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>wx += uwx;
            wy += uwy;
            wz += uwz;

            // set new state
            result[0] = r.getInhomX();
            result[1] = r.getInhomY();
            result[2] = r.getInhomZ();

            result[3] = q.getA();
            result[4] = q.getB();
            result[5] = q.getC();
            result[6] = q.getD();

            result[7] = vx;
            result[8] = vy;
            result[9] = vz;

            result[10] = wx;</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/DualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/DualAbsoluteQuadricRobustEstimator.html#L901">901</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/DualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/DualAbsoluteQuadricRobustEstimator.html#L936">936</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final double p13, final double p33, final double p14, final double p34) {

        final var a = daq.getA();
        final var b = daq.getB();
        final var c = daq.getC();
        final var d = daq.getD();
        final var e = daq.getE();
        final var f = daq.getF();
        final var g = daq.getG();
        final var h = daq.getH();
        final var i = daq.getI();
        final var j = daq.getJ();

        return a * p31 * p11 + b * p32 * p12 + c * p33 * p13 + d * (p32 * p11 + p32 * p12)</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/estimators/FundamentalMatrixRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/estimators/FundamentalMatrixRobustEstimator.html#L728">728</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/epipolar/refiners/FundamentalMatrixRefiner.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/refiners/FundamentalMatrixRefiner.html#L338">338</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/epipolar/refiners/RightEpipoleRefiner.java</td>
<td><a href="./xref/com/irurueta/ar/epipolar/refiners/RightEpipoleRefiner.html#L240">240</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>protected double residual(
            final FundamentalMatrix fundamentalMatrix, final Point2D leftPoint, final Point2D rightPoint) {
        try {
            leftPoint.normalize();
            rightPoint.normalize();
            fundamentalMatrix.normalize();
            fundamentalMatrix.leftEpipolarLine(rightPoint, testLine);
            final var leftDistance = Math.abs(testLine.signedDistance(leftPoint));
            fundamentalMatrix.rightEpipolarLine(leftPoint, testLine);
            final var rightDistance = Math.abs(testLine.signedDistance(rightPoint));
            // return average distance as an error residual
            return 0.5 * (leftDistance + rightDistance);
        } catch (final NotReadyException e) {
            return Double.MAX_VALUE;
        }
    }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/AbsoluteOrientationConstantVelocityModelSlamEstimator.html#L301">301</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelSlamEstimator.html#L278">278</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>final long timestamp = getMostRecentTimestampNanos();
        if (lastTimestampNanos &lt; 0) {
            // first time receiving control data, we just set linear acceleration
            // and angular speed into system state
            stateAccelerationX = accumulatedAccelerationSampleX;
            stateAccelerationY = accumulatedAccelerationSampleY;
            stateAccelerationZ = accumulatedAccelerationSampleZ;
            lastAngularSpeedX = stateAngularSpeedX = x[10] = accumulatedAngularSpeedSampleX;
            lastAngularSpeedY = stateAngularSpeedY = x[11] = accumulatedAngularSpeedSampleY;
            lastAngularSpeedZ = stateAngularSpeedZ = x[12] = accumulatedAngularSpeedSampleZ;

            try {
                kalmanFilter.getStatePre().fromArray(x);
                kalmanFilter.getStatePost().fromArray(x);
            } catch (final WrongSizeException ignore) {
                // never thrown
            }

            lastTimestampNanos = timestamp;

            if (listener != null) {
                listener.onFullSampleProcessed(this);
            }

            return;
        }</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L138">138</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.java</td>
<td><a href="./xref/com/irurueta/ar/slam/ConstantVelocityModelStatePredictor.html#L372">372</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>|| jacobianU.getColumns() != CONTROL_COMPONENTS)) {
            // jacobian wrt u must be 13x6
            throw new IllegalArgumentException();
        }

        // position
        final var r = new InhomogeneousPoint3D(x[0], x[1], x[2]);

        // orientation
        var q = new Quaternion(x[3], x[4], x[5], x[6]);

        // linear velocity
        var vx = x[7];
        var vy = x[8];
        var vz = x[9];

        // angular velocity
        var wx = x[10];
        var wy = x[11];
        var wz = x[12];

        // linear velocity change (control)
        final var uvx = u[0];</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L283">283</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L430">430</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L452">452</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>+ Math.pow(a.getElementAt(counter, 5), 2.0));

                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);
                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);
                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);
                a.setElementAt(counter, 3, a.getElementAt(counter, 3) / rowNorm);
                a.setElementAt(counter, 4, a.getElementAt(counter, 4) / rowNorm);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L314">314</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L430">430</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/LMSEImageOfAbsoluteConicEstimator.html#L452">452</a></td></tr>
<tr class="a">
<td colspan="2">
<pre>+ Math.pow(a.getElementAt(counter, 5), 2.0));

                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);
                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);
                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);
                a.setElementAt(counter, 3, a.getElementAt(counter, 3) / rowNorm);
                a.setElementAt(counter, 4, a.getElementAt(counter, 4) / rowNorm);</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/MSACDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/MSACDualAbsoluteQuadricRobustEstimator.html#L236">236</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/MSACImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/MSACImageOfAbsoluteConicRobustEstimator.html#L245">245</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/MSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/MSACRadialDistortionRobustEstimator.html#L312">312</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/MSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/MSACRobustSinglePoint3DTriangulator.html#L268">268</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>listener.onEstimateProgressChange(MSACDualAbsoluteQuadricRobustEstimator.this, progress);
                }
            }
        });

        try {
            locked = true;
            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            return innerEstimator.estimate();
        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.MSAC;
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/RANSACDualAbsoluteQuadricRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/RANSACDualAbsoluteQuadricRobustEstimator.html#L237">237</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/calibration/estimators/RANSACImageOfAbsoluteConicRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/RANSACImageOfAbsoluteConicRobustEstimator.html#L247">247</a></td></tr>
<tr class="b">
<td>com/irurueta/ar/calibration/estimators/RANSACRadialDistortionRobustEstimator.java</td>
<td><a href="./xref/com/irurueta/ar/calibration/estimators/RANSACRadialDistortionRobustEstimator.html#L312">312</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/RANSACRobustSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/RANSACRobustSinglePoint3DTriangulator.html#L270">270</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>RANSACDualAbsoluteQuadricRobustEstimator.this, progress);
                        }
                    }
                });

        try {
            locked = true;
            innerEstimator.setConfidence(confidence);
            innerEstimator.setMaxIterations(maxIterations);
            innerEstimator.setProgressDelta(progressDelta);
            return innerEstimator.estimate();
        } catch (final com.irurueta.numerical.LockedException e) {
            throw new LockedException(e);
        } catch (final com.irurueta.numerical.NotReadyException e) {
            throw new NotReadyException(e);
        } finally {
            locked = false;
        }
    }

    /**
     * Returns method being used for robust estimation.
     *
     * @return method being used for robust estimation.
     */
    @Override
    public RobustEstimatorMethod getMethod() {
        return RobustEstimatorMethod.RANSAC;
    }
}</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/BaseAbsoluteOrientationSlamTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseAbsoluteOrientationSlamTwoViewsSparseReconstructor.html#L93">93</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/BaseSlamTwoViewsSparseReconstructor.html#L207">207</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>protected boolean updateScaleAndOrientation() {

        // obtain baseline (camera separation from slam estimator data
        final var posX = slamEstimator.getStatePositionX();
        final var posY = slamEstimator.getStatePositionY();
        final var posZ = slamEstimator.getStatePositionZ();

        // to estimate baseline, we assume that first camera is placed at
        // world origin
        final var baseline = Math.sqrt(posX * posX + posY * posY + posZ * posZ);

        try {
            final var camera1 = estimatedCamera1.getCamera();
            final var camera2 = estimatedCamera2.getCamera();

            camera1.decompose();
            camera2.decompose();

            final var center1 = camera1.getCameraCenter();
            final var center2 = camera2.getCameraCenter();

            // R1' = R1*Rdiff
            // Rdiff = R1^T*R1'

            // where R1' is the desired orientation (obtained by sampling a
            // sensor)
            // and R1 is always the identity for the 1st camera.
            // Hence R1' = Rdiff

            // t1' is the desired translation which is zero for the 1st
            // camera.

            // We want: P1' = K*[R1' t1'] = K*[R1' 0]
            // And we have P1 = K[I 0]

            // We need a transformation T so that:
            // P1' = P1*T^-1 = K[I 0][R1' 0]
            //                      [0   1]

            // Hence: T^-1 = [R1' 0]
            //              [0   1]

            // or T = [R1'^T 0]
            //       [0     1]

            // because we are also applying a transformation of scale s,
            // the combination of both transformations is
            // T = [s*R1'^T 0]
            //     [0       1]

            final var r = firstOrientation.inverseRotationAndReturnNew();</pre></td></tr></table>
<table class="table table-striped">
<tr class="a">
<th>File</th>
<th>Line</th></tr>
<tr class="b">
<td>com/irurueta/ar/sfm/WeightedHomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/WeightedHomogeneousSinglePoint3DTriangulator.html#L425">425</a></td></tr>
<tr class="a">
<td>com/irurueta/ar/sfm/WeightedInhomogeneousSinglePoint3DTriangulator.java</td>
<td><a href="./xref/com/irurueta/ar/sfm/WeightedInhomogeneousSinglePoint3DTriangulator.html#L421">421</a></td></tr>
<tr class="b">
<td colspan="2">
<pre>v.getElementAt(3, 3));

            if (listener != null) {
                listener.onTriangulateEnd(this);
            }
        } catch (final AlgebraException | SortingException e) {
            throw new Point3DTriangulationException(e);
        } finally {
            locked = false;
        }

    }

    /**
     * Internal method to set list of matched 2D points for each view and their
     * corresponding cameras used to project them along with their weights.
     * This method does not check whether instance is locked.
     *
     * @param points2D list of matched 2D points on each view. Each point in the
     *                 list is assumed to be projected by the corresponding camera in the list.
     * @param cameras  cameras for each view where 2D points are represented.
     * @param weights  weights assigned to each view.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  length or their length is less than 2 views, which is the minimum
     *                                  required to compute triangulation.
     */
    private void internalSetPointsCamerasAndWeights(
            final List&lt;Point2D&gt; points2D, final List&lt;PinholeCamera&gt; cameras, final double[] weights) {
        if (!areValidPointsCamerasAndWeights(points2D, cameras, weights)) {
            throw new IllegalArgumentException();
        }

        this.points2D = points2D;
        this.cameras = cameras;
        this.weights = weights;
    }
}</pre></td></tr></table></section></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Â©      2018â€“2025
</p>
        </div>
      </div>
    </footer>
<script>
  if(anchors) {
    anchors.add();
  }
</script>
  </body>
</html>
