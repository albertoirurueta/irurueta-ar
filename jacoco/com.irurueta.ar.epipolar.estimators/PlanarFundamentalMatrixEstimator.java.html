<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PlanarFundamentalMatrixEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.epipolar.estimators</a> &gt; <span class="el_source">PlanarFundamentalMatrixEstimator.java</span></div><h1>PlanarFundamentalMatrixEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.epipolar.estimators;

import com.irurueta.ar.epipolar.EssentialMatrix;
import com.irurueta.ar.epipolar.FundamentalMatrix;
import com.irurueta.geometry.GeometryException;
import com.irurueta.geometry.HomogeneousPoint2D;
import com.irurueta.geometry.PinholeCameraIntrinsicParameters;
import com.irurueta.geometry.Transformation2D;
import com.irurueta.geometry.estimators.LockedException;
import com.irurueta.geometry.estimators.NotReadyException;

import java.util.ArrayList;
import java.util.List;

/**
 * This class takes an input 2D homography (e.g. transformation) and a given
 * pair of intrinsic parameters for left and right views, and estimates all
 * possible fundamental matrices generating such homography in a planar scene.
 * This estimator will generate either 2 or 4 possible solutions, however only
 * 1 solution will be physically possible, which corresponds to the solution
 * that generates triangulated points located in front of the cameras generating
 * such epipolar geometries.
 * This class is useful in planar scenes where 8-point and 7-point algorithms
 * will fail since this kind of geometry is a degenerate configuration of
 * points.
 */
public class PlanarFundamentalMatrixEstimator {

    /**
     * 2D transformation relating two views (left view to right view).
     */
    private Transformation2D homography;

    /**
     * Intrinsic parameters to be used on left view.
     */
    private PinholeCameraIntrinsicParameters leftIntrinsics;

    /**
     * Intrinsic parameters to be used on right view.
     */
    private PinholeCameraIntrinsicParameters rightIntrinsics;

    /**
     * Listener to attend events generated by this instance.
     */
    private PlanarFundamentalMatrixEstimatorListener listener;

    /**
     * Indicates whether estimator is locked while estimating fundamental
     * matrix.
     */
    private boolean locked;

    /**
     * Constructor.
     */
<span class="fc" id="L73">    public PlanarFundamentalMatrixEstimator() {</span>
<span class="fc" id="L74">    }</span>

    /**
     * Constructor.
     *
     * @param homography      2D transformation relating two views (left view to
     *                        right view).
     * @param leftIntrinsics  intrinsic parameters to be used on left view.
     * @param rightIntrinsics intrinsic parameters to be used on right view.
     */
    public PlanarFundamentalMatrixEstimator(final Transformation2D homography,
                                            final PinholeCameraIntrinsicParameters leftIntrinsics,
<span class="fc" id="L86">                                            final PinholeCameraIntrinsicParameters rightIntrinsics) {</span>
<span class="fc" id="L87">        this.homography = homography;</span>
<span class="fc" id="L88">        this.leftIntrinsics = leftIntrinsics;</span>
<span class="fc" id="L89">        this.rightIntrinsics = rightIntrinsics;</span>
<span class="fc" id="L90">    }</span>

    /**
     * Constructor.
     *
     * @param homography      2D transformation relating two views (left view to
     *                        right view).
     * @param leftIntrinsics  intrinsic parameters to be used on left view.
     * @param rightIntrinsics intrinsic parameters to be used on right view.
     * @param listener        listener to attend events generated by this instance.
     */
    public PlanarFundamentalMatrixEstimator(final Transformation2D homography,
                                            final PinholeCameraIntrinsicParameters leftIntrinsics,
                                            final PinholeCameraIntrinsicParameters rightIntrinsics,
                                            final PlanarFundamentalMatrixEstimatorListener listener) {
<span class="fc" id="L105">        this(homography, leftIntrinsics, rightIntrinsics);</span>
<span class="fc" id="L106">        this.listener = listener;</span>
<span class="fc" id="L107">    }</span>

    /**
     * Gets 2D transformation relating two views (left view to right view).
     *
     * @return 2D transformation relating two views.
     */
    public Transformation2D getHomography() {
<span class="fc" id="L115">        return homography;</span>
    }

    /**
     * Sets 2D transformation relating two views (left view to right view).
     *
     * @param homography 2D transformation relating two views.
     * @throws LockedException if estimator is locked.
     */
    public void setHomography(final Transformation2D homography) throws LockedException {
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L126">            throw new LockedException();</span>
        }
<span class="fc" id="L128">        this.homography = homography;</span>
<span class="fc" id="L129">    }</span>

    /**
     * Gets intrinsic parameters to be used on left view.
     *
     * @return intrinsic parameters to be used on left view.
     */
    public PinholeCameraIntrinsicParameters getLeftIntrinsics() {
<span class="fc" id="L137">        return leftIntrinsics;</span>
    }

    /**
     * Sets intrinsic parameters to be used on left view.
     *
     * @param leftIntrinsics intrinsic parameters to be used on left view.
     * @throws LockedException if estimator is locked.
     */
    public void setLeftIntrinsics(final PinholeCameraIntrinsicParameters leftIntrinsics) throws LockedException {
<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L148">            throw new LockedException();</span>
        }
<span class="fc" id="L150">        this.leftIntrinsics = leftIntrinsics;</span>
<span class="fc" id="L151">    }</span>

    /**
     * Gets intrinsic parameters to be used on right view.
     *
     * @return intrinsic parameters to be used on right view.
     */
    public PinholeCameraIntrinsicParameters getRightIntrinsics() {
<span class="fc" id="L159">        return rightIntrinsics;</span>
    }

    /**
     * Sets intrinsic parameters to be used on right view.
     *
     * @param rightIntrinsics intrinsic parameters to be used on right view.
     * @throws LockedException if estimator is locked.
     */
    public void setRightIntrinsics(final PinholeCameraIntrinsicParameters rightIntrinsics) throws LockedException {
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L170">            throw new LockedException();</span>
        }
<span class="fc" id="L172">        this.rightIntrinsics = rightIntrinsics;</span>
<span class="fc" id="L173">    }</span>

    /**
     * Gets listener to attend events generated by this instance.
     *
     * @return listener to attend events generated by this instance.
     */
    public PlanarFundamentalMatrixEstimatorListener getListener() {
<span class="fc" id="L181">        return listener;</span>
    }

    /**
     * Sets listener to attend events generated by this instance.
     *
     * @param listener listener to attend events generated by this instance.
     */
    public void setListener(final PlanarFundamentalMatrixEstimatorListener listener) {
<span class="fc" id="L190">        this.listener = listener;</span>
<span class="fc" id="L191">    }</span>

    /**
     * Indicates whether estimator is locked while estimating fundamental
     * matrix.
     *
     * @return true if estimator is locked, false otherwise.
     */
    public boolean isLocked() {
<span class="fc" id="L200">        return locked;</span>
    }

    /**
     * Indicates whether estimator is ready to start the estimation when all
     * required data has been provided.
     *
     * @return true if estimator is ready, false otherwise.
     */
    public boolean isReady() {
<span class="pc bpc" id="L210" title="2 of 6 branches missed.">        return homography != null &amp;&amp; leftIntrinsics != null &amp;&amp; rightIntrinsics != null;</span>
    }

    /**
     * Estimates fundamental matrices and returns the estimated result.
     *
     * @return estimated fundamental matrices.
     * @throws LockedException                     if estimator is locked.
     * @throws NotReadyException                   if estimator is not ready.
     * @throws FundamentalMatrixEstimatorException if estimation fails for some
     *                                             reason.
     */
    public List&lt;FundamentalMatrix&gt; estimate() throws LockedException, NotReadyException,
            FundamentalMatrixEstimatorException {
<span class="fc" id="L224">        final var result = new ArrayList&lt;FundamentalMatrix&gt;();</span>
<span class="fc" id="L225">        estimate(result);</span>
<span class="fc" id="L226">        return result;</span>
    }

    /**
     * Estimates fundamental matrices and stores result into provided instance.
     *
     * @param result instance where result will be stored.
     * @throws LockedException                     if estimator is locked.
     * @throws NotReadyException                   if estimator is not ready.
     * @throws FundamentalMatrixEstimatorException if estimation fails for some
     *                                             reason.
     */
    public void estimate(final List&lt;FundamentalMatrix&gt; result) throws LockedException, NotReadyException,
            FundamentalMatrixEstimatorException {
<span class="fc bfc" id="L240" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L241">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L244">            throw new NotReadyException();</span>
        }

        try {
<span class="fc" id="L248">            locked = true;</span>

<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L251">                listener.onEstimateStart(this);</span>
            }

<span class="fc" id="L254">            final var decomposer = new HomographyDecomposer(homography, leftIntrinsics, rightIntrinsics);</span>

<span class="fc" id="L256">            final var decompositions = decomposer.decompose();</span>
<span class="fc" id="L257">            result.clear();</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">            for (final var decomposition : decompositions) {</span>
<span class="fc" id="L259">                final var rotation = decomposition.getTransformation().getRotation();</span>
<span class="fc" id="L260">                final var translation = new HomogeneousPoint2D(decomposition.getTransformation().getTranslation());</span>
<span class="fc" id="L261">                final var essential = new EssentialMatrix(rotation, translation);</span>
<span class="fc" id="L262">                final var fundamentalMatrix = essential.toFundamentalMatrix(leftIntrinsics, rightIntrinsics);</span>
<span class="fc" id="L263">                result.add(fundamentalMatrix);</span>
<span class="fc" id="L264">            }</span>

<span class="fc bfc" id="L266" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L267">                listener.onEstimateEnd(this, result);</span>
            }

<span class="nc" id="L270">        } catch (final GeometryException e) {</span>
<span class="nc" id="L271">            throw new FundamentalMatrixEstimatorException(e);</span>
        } finally {
<span class="fc" id="L273">            locked = false;</span>
        }
<span class="fc" id="L275">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>