<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AffineFundamentalMatrixEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.epipolar.estimators</a> &gt; <span class="el_source">AffineFundamentalMatrixEstimator.java</span></div><h1>AffineFundamentalMatrixEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.epipolar.estimators;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.SingularValueDecomposer;
import com.irurueta.algebra.Utils;
import com.irurueta.ar.epipolar.FundamentalMatrix;
import com.irurueta.ar.epipolar.InvalidFundamentalMatrixException;
import com.irurueta.geometry.Point2D;
import com.irurueta.geometry.ProjectiveTransformation2D;
import com.irurueta.geometry.estimators.LockedException;
import com.irurueta.geometry.estimators.NormalizerException;
import com.irurueta.geometry.estimators.NotReadyException;
import com.irurueta.geometry.estimators.Point2DNormalizer;

import java.util.List;

/**
 * Non-robust fundamental matrix estimator for Affine camera projection model.
 * This implementation uses 4 matched 2D points on left and right views.
 */
public class AffineFundamentalMatrixEstimator extends FundamentalMatrixEstimator {

    /**
     * Constant indicating that by default an LMSE solution is not allowed.
     */
    public static final boolean DEFAULT_ALLOW_LMSE_SOLUTION = false;

    /**
     * Minimum number of matched 2D points to start the estimation.
     */
    public static final int MIN_REQUIRED_POINTS = 4;

    /**
     * Indicates if by default provided point correspondences are normalized to
     * increase the accuracy of the estimation.
     */
    public static final boolean DEFAULT_NORMALIZE_POINT_CORRESPONDENCES = true;

    /**
     * Indicates whether an LMSE (the Least Mean Square Error) solution is allowed
     * or not.
     */
    private boolean allowLMSESolution;

    /**
     * Indicates whether provided matched 2D points must be normalized to
     * increase the accuracy of the estimation.
     */
    private boolean normalizePoints;

    /**
     * Constructor.
     */
    public AffineFundamentalMatrixEstimator() {
<span class="fc" id="L71">        super();</span>
<span class="fc" id="L72">        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;</span>
<span class="fc" id="L73">        normalizePoints = DEFAULT_NORMALIZE_POINT_CORRESPONDENCES;</span>
<span class="fc" id="L74">    }</span>

    /**
     * Constructor with matched 2D points.
     *
     * @param leftPoints  2D points on left view.
     * @param rightPoints 2D points on right view.
     * @throws IllegalArgumentException if provided list of points do not
     *                                  have the same length.
     */
    public AffineFundamentalMatrixEstimator(final List&lt;Point2D&gt; leftPoints, final List&lt;Point2D&gt; rightPoints) {
<span class="fc" id="L85">        super(leftPoints, rightPoints);</span>
<span class="fc" id="L86">        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;</span>
<span class="fc" id="L87">        normalizePoints = DEFAULT_NORMALIZE_POINT_CORRESPONDENCES;</span>
<span class="fc" id="L88">    }</span>

    /**
     * Returns boolean indicating whether an LMSE (the Least Mean Square Error)
     * solution is allowed or not. When an LMSE solution is allowed, more than 8
     * matched points can be used for fundamental matrix estimation. If LMSE
     * solution is not allowed then only the 4 former matched points will be
     * taken into account.
     *
     * @return true if an LMSE solution is allowed, false otherwise.
     */
    public boolean isLMSESolutionAllowed() {
<span class="fc" id="L100">        return allowLMSESolution;</span>
    }

    /**
     * Sets boolean indicating whether an LMSE (the Least Mean Square Error)
     * solution is allowed or not. When an LMSE solution is allowed, more than 8
     * matched points can be used for fundamental matrix estimation. If LMSE
     * solution is not allowed then only the 4 former matched points will be
     * taken into account.
     *
     * @param allowed true if an LMSE solution is allowed, false otherwise.
     * @throws LockedException if this instance is locked because an estimation
     *                         is in progress.
     */
    public void setLMSESolutionAllowed(final boolean allowed) throws LockedException {
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L116">            throw new LockedException();</span>
        }

<span class="fc" id="L119">        allowLMSESolution = allowed;</span>
<span class="fc" id="L120">    }</span>

    /**
     * Indicates whether provided matched 2D points must be normalized to
     * increase the accuracy of the estimation.
     *
     * @return true if points must be normalized, false otherwise.
     */
    public boolean arePointsNormalized() {
<span class="fc" id="L129">        return normalizePoints;</span>
    }

    /**
     * Sets boolean indicating whether provided matched 2D points must be
     * normalized to increase the accuracy of the estimation.
     *
     * @param normalizePoints true if points must be normalized, false
     *                        otherwise.
     * @throws LockedException if this instance is locked because an estimation
     *                         is in progress.
     */
    public void setPointsNormalized(final boolean normalizePoints) throws LockedException {
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L143">            throw new LockedException();</span>
        }

<span class="fc" id="L146">        this.normalizePoints = normalizePoints;</span>
<span class="fc" id="L147">    }</span>

    /**
     * Returns boolean indicating whether estimator is ready to start the
     * fundamental matrix estimation.
     * This is true when the required minimum number of matched points is
     * provided to obtain a solution and both left and right views have the
     * same number of matched points.
     *
     * @return true if estimator is ready to start the fundamental matrix
     * estimation, false otherwise.
     */
    @Override
    public boolean isReady() {
<span class="pc bpc" id="L161" title="2 of 6 branches missed.">        return leftPoints != null &amp;&amp; rightPoints != null &amp;&amp; leftPoints.size() == rightPoints.size()</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">                &amp;&amp; leftPoints.size() &gt;= MIN_REQUIRED_POINTS;</span>
    }

    /**
     * Estimates a fundamental matrix using provided lists of matched points on
     * left and right views.
     *
     * @return a fundamental matrix.
     * @throws LockedException                     if estimator is locked doing an estimation.
     * @throws NotReadyException                   if estimator is not ready because required
     *                                             input points have not already been provided.
     * @throws FundamentalMatrixEstimatorException if configuration of provided
     *                                             2D points is degenerate and fundamental matrix
     *                                             estimation fails.
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    public FundamentalMatrix estimate() throws LockedException, NotReadyException, FundamentalMatrixEstimatorException {
<span class="fc bfc" id="L180" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L181">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (!isReady()) {</span>
<span class="fc" id="L184">            throw new NotReadyException();</span>
        }

<span class="fc" id="L187">        locked = true;</span>

<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (listener != null) {</span>
<span class="fc" id="L190">            listener.onEstimateStart(this);</span>
        }

<span class="fc" id="L193">        final var nPoints = leftPoints.size();</span>

        try {
<span class="fc" id="L196">            ProjectiveTransformation2D leftNormalization = null;</span>
<span class="fc" id="L197">            ProjectiveTransformation2D rightNormalization = null;</span>
            final List&lt;Point2D&gt; leftPoints;
            final List&lt;Point2D&gt; rightPoints;
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (normalizePoints) {</span>
                // normalize points on left view
<span class="fc" id="L202">                final var normalizer = new Point2DNormalizer(this.leftPoints);</span>
<span class="fc" id="L203">                normalizer.compute();</span>

<span class="fc" id="L205">                leftNormalization = normalizer.getTransformation();</span>

                // normalize points on right view
<span class="fc" id="L208">                normalizer.setPoints(this.rightPoints);</span>
<span class="fc" id="L209">                normalizer.compute();</span>

<span class="fc" id="L211">                rightNormalization = normalizer.getTransformation();</span>

                // normalize to increase accuracy
<span class="fc" id="L214">                leftNormalization.normalize();</span>
<span class="fc" id="L215">                rightNormalization.normalize();</span>

<span class="fc" id="L217">                leftPoints = leftNormalization.transformPointsAndReturnNew(this.leftPoints);</span>
<span class="fc" id="L218">                rightPoints = rightNormalization.transformPointsAndReturnNew(this.rightPoints);</span>
<span class="fc" id="L219">            } else {</span>
<span class="fc" id="L220">                leftPoints = this.leftPoints;</span>
<span class="fc" id="L221">                rightPoints = this.rightPoints;</span>
            }

            final Matrix a;
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (isLMSESolutionAllowed()) {</span>
<span class="fc" id="L226">                a = new Matrix(nPoints, 5);</span>
            } else {
<span class="fc" id="L228">                a = new Matrix(MIN_REQUIRED_POINTS, 5);</span>
            }

            Point2D leftPoint;
            Point2D rightPoint;
            double homLeftX;
            double homLeftY;
            double homLeftW;
            double homRightX;
            double homRightY;
            double homRightW;
            double value0;
            double value1;
            double value2;
            double value3;
            double value4;
            double rowNorm;
<span class="fc bfc" id="L245" title="All 2 branches covered.">            for (var i = 0; i &lt; nPoints; i++) {</span>
<span class="fc" id="L246">                leftPoint = leftPoints.get(i);</span>
<span class="fc" id="L247">                rightPoint = rightPoints.get(i);</span>

                // normalize points to increase accuracy
<span class="fc" id="L250">                leftPoint.normalize();</span>
<span class="fc" id="L251">                rightPoint.normalize();</span>

<span class="fc" id="L253">                homLeftX = leftPoint.getHomX();</span>
<span class="fc" id="L254">                homLeftY = leftPoint.getHomY();</span>
<span class="fc" id="L255">                homLeftW = leftPoint.getHomW();</span>

<span class="fc" id="L257">                homRightX = rightPoint.getHomX();</span>
<span class="fc" id="L258">                homRightY = rightPoint.getHomY();</span>
<span class="fc" id="L259">                homRightW = rightPoint.getHomW();</span>

                // set a row values
<span class="fc" id="L262">                value0 = homLeftW * homRightX;</span>
<span class="fc" id="L263">                value1 = homLeftW * homRightY;</span>
<span class="fc" id="L264">                value2 = homLeftX * homRightW;</span>
<span class="fc" id="L265">                value3 = homLeftY * homRightW;</span>
<span class="fc" id="L266">                value4 = homLeftW * homRightW;</span>

                // normalize row to increase accuracy
<span class="fc" id="L269">                rowNorm = Math.sqrt(Math.pow(value0, 2.0)</span>
<span class="fc" id="L270">                        + Math.pow(value1, 2.0) + Math.pow(value2, 2.0)</span>
<span class="fc" id="L271">                        + Math.pow(value3, 2.0) + Math.pow(value4, 2.0));</span>

<span class="fc" id="L273">                a.setElementAt(i, 0, value0 / rowNorm);</span>
<span class="fc" id="L274">                a.setElementAt(i, 1, value1 / rowNorm);</span>
<span class="fc" id="L275">                a.setElementAt(i, 2, value2 / rowNorm);</span>
<span class="fc" id="L276">                a.setElementAt(i, 3, value3 / rowNorm);</span>
<span class="fc" id="L277">                a.setElementAt(i, 4, value4 / rowNorm);</span>

<span class="fc bfc" id="L279" title="All 4 branches covered.">                if (!isLMSESolutionAllowed() &amp;&amp; i == (MIN_REQUIRED_POINTS - 1)) {</span>
<span class="fc" id="L280">                    break;</span>
                }
            }

<span class="fc" id="L284">            final var decomposer = new SingularValueDecomposer(a);</span>

<span class="fc" id="L286">            decomposer.decompose();</span>

            // if nullity of provided a matrix is not of dimension 1 (number of
            // dimensions of null-space), then epipolar geometry is degenerate
            // because there is more than one possible solution (up to scale).
            // This is typically due to co-linearities or co-planarities on
            // projected 2D points. In this case we throw an exception
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">            if (decomposer.getNullity() &gt; 1) {</span>
<span class="nc" id="L294">                throw new FundamentalMatrixEstimatorException();</span>
            }

<span class="fc" id="L297">            var v = decomposer.getV();</span>

            // The fundamental matrix is contained in vector form on the last
            // column of V, we reshape such vector into a 3x3 matrix
<span class="fc" id="L301">            var fundMatrix = new Matrix(FundamentalMatrix.FUNDAMENTAL_MATRIX_ROWS,</span>
                    FundamentalMatrix.FUNDAMENTAL_MATRIX_COLS);
<span class="fc" id="L303">            fundMatrix.setElementAt(0, 2, v.getElementAt(0, 4));</span>
<span class="fc" id="L304">            fundMatrix.setElementAt(1, 2, v.getElementAt(1, 4));</span>
<span class="fc" id="L305">            fundMatrix.setElementAt(2, 0, v.getElementAt(2, 4));</span>
<span class="fc" id="L306">            fundMatrix.setElementAt(2, 1, v.getElementAt(3, 4));</span>
<span class="fc" id="L307">            fundMatrix.setElementAt(2, 2, v.getElementAt(4, 4));</span>

<span class="pc bpc" id="L309" title="1 of 4 branches missed.">            if (normalizePoints &amp;&amp; leftNormalization != null) {</span>
                // denormalize fundMatrix
<span class="fc" id="L311">                final var transposedRightTransformationMatrix = rightNormalization.asMatrix().transposeAndReturnNew();</span>
<span class="fc" id="L312">                final var leftTransformationMatrix = leftNormalization.asMatrix();</span>

                // compute fundMatrix = transposedRightTransformationMatrix *
                // fundMatrix * leftTransformationMatrix
<span class="fc" id="L316">                fundMatrix.multiply(leftTransformationMatrix);</span>
<span class="fc" id="L317">                transposedRightTransformationMatrix.multiply(fundMatrix);</span>
<span class="fc" id="L318">                fundMatrix = transposedRightTransformationMatrix;</span>

                // normalize by Frobenius norm to increase accuracy after point
                // de-normalization
<span class="fc" id="L322">                final var norm = Utils.normF(fundMatrix);</span>
<span class="fc" id="L323">                fundMatrix.multiplyByScalar(1.0 / norm);</span>
            }

            // enforce rank 2
<span class="fc" id="L327">            decomposer.setInputMatrix(fundMatrix);</span>

<span class="fc" id="L329">            decomposer.decompose();</span>

            // if rank is not already correct, then we enforce it
<span class="fc" id="L332">            final var rank = decomposer.getRank();</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">            if (rank &gt; FundamentalMatrix.FUNDAMENTAL_MATRIX_RANK) {</span>
                // rank needs to be reduced
<span class="nc" id="L335">                final var u = decomposer.getU();</span>
<span class="nc" id="L336">                final var w = decomposer.getW();</span>
<span class="nc" id="L337">                v = decomposer.getV();</span>

                // transpose V
<span class="nc" id="L340">                v.transpose();</span>
<span class="nc" id="L341">                final var transV = v;</span>

                // set last singular value to zero to enforce rank 2
<span class="nc" id="L344">                w.setElementAt(2, 2, 0.0);</span>

                // compute fundMatrix = U * W * V'
<span class="nc" id="L347">                w.multiply(transV);</span>
<span class="nc" id="L348">                u.multiply(w);</span>
<span class="nc" id="L349">                fundMatrix = u;</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            } else if (rank &lt; FundamentalMatrix.FUNDAMENTAL_MATRIX_RANK) {</span>
                // rank is 1, which is lower than required fundamental matrix
                // rank (rank 2)
<span class="nc" id="L353">                throw new FundamentalMatrixEstimatorException();</span>
            }

<span class="fc" id="L356">            final var result = new FundamentalMatrix(fundMatrix);</span>

<span class="fc bfc" id="L358" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L359">                listener.onEstimateEnd(this, result);</span>
            }

<span class="fc" id="L362">            return result;</span>

<span class="nc" id="L364">        } catch (final InvalidFundamentalMatrixException | AlgebraException | NormalizerException e) {</span>
<span class="nc" id="L365">            throw new FundamentalMatrixEstimatorException(e);</span>
        } finally {
<span class="fc" id="L367">            locked = false;</span>
        }
    }

    /**
     * Returns method of non-robust fundamental matrix estimator.
     *
     * @return method of fundamental matrix estimator.
     */
    @Override
    public FundamentalMatrixEstimatorMethod getMethod() {
<span class="fc" id="L378">        return FundamentalMatrixEstimatorMethod.AFFINE_ALGORITHM;</span>
    }

    /**
     * Returns minimum number of matched pair of points required to start
     * the estimation. This implementation requires a minimum of 4 points
     *
     * @return minimum number of matched pair of points required to start
     * the estimation. Always returns 4.
     */
    @Override
    public int getMinRequiredPoints() {
<span class="fc" id="L390">        return MIN_REQUIRED_POINTS;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>