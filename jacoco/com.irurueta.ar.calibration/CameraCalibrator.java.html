<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CameraCalibrator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.calibration</a> &gt; <span class="el_source">CameraCalibrator.java</span></div><h1>CameraCalibrator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2015 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.calibration;

import com.irurueta.ar.calibration.estimators.ImageOfAbsoluteConicRobustEstimator;
import com.irurueta.ar.calibration.estimators.ImageOfAbsoluteConicRobustEstimatorListener;
import com.irurueta.ar.calibration.estimators.LMedSImageOfAbsoluteConicRobustEstimator;
import com.irurueta.ar.calibration.estimators.MSACImageOfAbsoluteConicRobustEstimator;
import com.irurueta.ar.calibration.estimators.PROMedSImageOfAbsoluteConicRobustEstimator;
import com.irurueta.ar.calibration.estimators.PROSACImageOfAbsoluteConicRobustEstimator;
import com.irurueta.ar.calibration.estimators.RANSACImageOfAbsoluteConicRobustEstimator;
import com.irurueta.geometry.GeometryException;
import com.irurueta.geometry.HomogeneousPoint2D;
import com.irurueta.geometry.PinholeCameraIntrinsicParameters;
import com.irurueta.geometry.Point2D;
import com.irurueta.geometry.Transformation2D;
import com.irurueta.geometry.estimators.*;
import com.irurueta.numerical.NumericalException;
import com.irurueta.numerical.robust.RobustEstimatorMethod;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Calibrates a camera in order to find its intrinsic parameters and other
 * parameters such as radial distortion.
 */
public abstract class CameraCalibrator {

    /**
     * Default robust estimator method to be used for homography estimations.
     */
<span class="fc" id="L49">    public static final RobustEstimatorMethod DEFAULT_HOMOGRAPHY_METHOD = RobustEstimatorMethod.PROSAC;</span>

    /**
     * Default robust estimator method to be used for IAC estimation.
     */
<span class="fc" id="L54">    public static final RobustEstimatorMethod DEFAULT_IAC_METHOD = RobustEstimatorMethod.PROSAC;</span>

    /**
     * Indicates whether radial distortion must be estimated or not by default.
     */
    public static final boolean DEFAULT_ESTIMATE_RADIAL_DISTORTION = true;

    /**
     * Default amount of progress variation before notifying a change in
     * estimation progress. By default, this is set to 5%.
     */
    public static final float DEFAULT_PROGRESS_DELTA = 0.05f;

    /**
     * Minimum allowed value for progress delta.
     */
    public static final float MIN_PROGRESS_DELTA = 0.0f;

    /**
     * Maximum allowed value for progress delta.
     */
    public static final float MAX_PROGRESS_DELTA = 1.0f;

    /**
     * Default method used for camera calibration.
     * The default method uses an alternating technique where first intrinsic
     * parameters and camera pose are estimated without accounting for
     * distortion and then the results are used to obtain an initial guess
     * for distortion, which is then used to correct initially sampled points
     * and repeat the whole process until convergence is achieved.
     */
<span class="fc" id="L85">    public static final CameraCalibratorMethod DEFAULT_METHOD = CameraCalibratorMethod.ERROR_OPTIMIZATION;</span>

    /**
     * Pattern used for camera calibration. Each pattern contains a unique
     * combination of 2D points that must be sampled using the camera to be
     * calibrated.
     */
    protected Pattern2D pattern;

    /**
     * List of samples obtained from different pictures using the same camera
     * device (or same camera model). Several samples can be used to calibrate
     * the camera. The more samples are used, typically the better the results.
     */
    protected List&lt;CameraCalibratorSample&gt; samples;

    /**
     * Quality scores for samples. This can be used on certain
     * robust estimation methods of the IAC such as PROSAC and PROMedS.
     * If not provided, homography quality scores will be estimated based on
     * re-projection error and this value will be ignored.
     * Typically, this will not be provided, but it can be used in case that it
     * can be assured by some means that one sample is better than another.
     */
    protected double[] samplesQualityScores;

    /**
     * Estimated homographies from provided list of samples respect to provided
     * pattern.
     */
    protected List&lt;Transformation2D&gt; homographies;

    /**
     * Quality scores for estimated homographies to be used during IAC
     * estimation when PROSAC or PROMedS robust method is used. This value
     * is only computed when no samples quality scores are provided.
     * Homography quality scores are obtained based on re-projection error of
     * marker coordinates.
     */
    protected double[] homographyQualityScores;

    /**
     * Indicates whether homography quality scores need to be estimated if
     * samples quality scores are not provided.
     */
    protected boolean homographyQualityScoresRequired;

    /**
     * Estimated image of absolute conic. This can be used to obtain intrinsic
     * pinhole camera intrinsic parameters.
     */
    protected ImageOfAbsoluteConic iac;

    /**
     * Estimated intrinsic pinhole camera parameters. Intrinsic parameters
     * contain data related to the camera sensor such as focal length,
     * skewness or principal point. Except focal length, typically intrinsic
     * parameters are fixed, and even in some situations such as when camera
     * lens is fixed, focal length also remains constant. Because the latter is
     * true in most phone cameras, it can be considered that intrinsic
     * parameters remain constant for all phones of the same maker and model,
     * and for that reason a calibrator can be used with pictures taken from
     * different phones as long as they are the same phone model.
     */
    protected PinholeCameraIntrinsicParameters intrinsic;

    /**
     * Estimated radial distortion. Radial distortion is inherent to the camera
     * lens, and remains constant as long as the lens doesn't change.
     * Because in most phone cameras the lens remains constant, lens distortion
     * can be modeled once for each phone model, and for that reason a single
     * calibrator can be used with pictures taken from different phones as long
     * as they are the same phone model.
     */
    protected RadialDistortion distortion;

    /**
     * Indicates whether radial distortion must be estimated or not.
     */
    protected boolean estimateRadialDistortion;

    /**
     * Robust estimator method to be used during homography estimation.
     * This will only be taken into account if more than 4 markers are detected
     * on a single sample, otherwise no robust method is used and a single LMSE
     * solution for the homography is found.
     */
    protected RobustEstimatorMethod homographyMethod;

    /**
     * Robust estimator method to be used during IAC estimation.
     * This will only be taken into account if more than 1 sample is provided,
     * otherwise no robust method is used and a single LMSE solution for the
     * IAC is found.
     */
    protected RobustEstimatorMethod imageOfAbsoluteConicMethod;

    /**
     * Robust estimator of homographies between sampled markers and ideal
     * pattern markers.
     */
    protected PointCorrespondenceProjectiveTransformation2DRobustEstimator homographyEstimator;

    /**
     * Robust estimator of the Image of Absolute Conic (IAC).
     */
    protected ImageOfAbsoluteConicRobustEstimator iacEstimator;

    /**
     * Listener for homography estimator.
     */
    protected ProjectiveTransformation2DRobustEstimatorListener homographyEstimatorListener;

    /**
     * Listener for image of absolute conic estimator.
     */
    protected ImageOfAbsoluteConicRobustEstimatorListener iacEstimatorListener;

    /**
     * Indicates whether this instance is locked because calibration is in
     * progress.
     */
    protected volatile boolean locked;

    /**
     * Amount of progress variation before notifying a progress change during
     * estimation.
     */
    protected float progressDelta;

    /**
     * Listener to notify when calibration starts, finishes or its progress
     * significantly changes.
     */
    protected CameraCalibratorListener listener;

    /**
     * Indicates progress of homography estimation.
     */
    protected float homographyProgress;

    /**
     * Indicates progress of homography estimation for all samples.
     */
    protected float sampleProgress;

    /**
     * Indicates progress of IAC estimation.
     */
    protected float iacProgress;

    /**
     * Indicates progress of estimation of intrinsic parameters.
     */
    protected float intrinsicProgress;

    /**
     * Constructor.
     */
<span class="fc" id="L244">    protected CameraCalibrator() {</span>
<span class="fc" id="L245">        pattern = null;</span>
<span class="fc" id="L246">        homographies = null;</span>
<span class="fc" id="L247">        homographyQualityScores = null;</span>
<span class="fc" id="L248">        iac = null;</span>
<span class="fc" id="L249">        intrinsic = null;</span>
<span class="fc" id="L250">        distortion = null;</span>
<span class="fc" id="L251">        estimateRadialDistortion = DEFAULT_ESTIMATE_RADIAL_DISTORTION;</span>

<span class="fc" id="L253">        internalSetHomographyMethod(DEFAULT_HOMOGRAPHY_METHOD);</span>
<span class="fc" id="L254">        internalSetImageOfAbsoluteConicMethod(DEFAULT_IAC_METHOD);</span>

<span class="fc" id="L256">        samples = null;</span>
<span class="fc" id="L257">        samplesQualityScores = null;</span>

<span class="fc" id="L259">        progressDelta = DEFAULT_PROGRESS_DELTA;</span>
<span class="fc" id="L260">    }</span>

    /**
     * Constructor.
     *
     * @param pattern 2D pattern to use for calibration.
     * @param samples samples of the pattern taken with the camera to calibrate.
     * @throws IllegalArgumentException if not enough samples are provided.
     */
<span class="fc" id="L269">    protected CameraCalibrator(final Pattern2D pattern, final List&lt;CameraCalibratorSample&gt; samples) {</span>
<span class="fc" id="L270">        this.pattern = pattern;</span>
<span class="fc" id="L271">        homographies = null;</span>
<span class="fc" id="L272">        homographyQualityScores = null;</span>
<span class="fc" id="L273">        iac = null;</span>
<span class="fc" id="L274">        intrinsic = null;</span>
<span class="fc" id="L275">        distortion = null;</span>
<span class="fc" id="L276">        estimateRadialDistortion = DEFAULT_ESTIMATE_RADIAL_DISTORTION;</span>

<span class="fc" id="L278">        internalSetHomographyMethod(DEFAULT_HOMOGRAPHY_METHOD);</span>
<span class="fc" id="L279">        internalSetImageOfAbsoluteConicMethod(DEFAULT_IAC_METHOD);</span>

<span class="fc" id="L281">        internalSetSamples(samples);</span>
<span class="fc" id="L282">        samplesQualityScores = null;</span>

<span class="fc" id="L284">        progressDelta = DEFAULT_PROGRESS_DELTA;</span>
<span class="fc" id="L285">    }</span>

    /**
     * Constructor.
     *
     * @param pattern              2D pattern to use for calibration.
     * @param samples              samples of the pattern taken with the camera to calibrate.
     * @param samplesQualityScores quality scores for each sample.
     * @throws IllegalArgumentException if not enough samples are provided or if
     *                                  both samples and quality scores do not have the same size.
     */
    protected CameraCalibrator(final Pattern2D pattern, final List&lt;CameraCalibratorSample&gt; samples,
<span class="fc" id="L297">                               final double[] samplesQualityScores) {</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">        if (samples.size() != samplesQualityScores.length) {</span>
<span class="fc" id="L299">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L302">        this.pattern = pattern;</span>
<span class="fc" id="L303">        homographies = null;</span>
<span class="fc" id="L304">        homographyQualityScores = null;</span>
<span class="fc" id="L305">        iac = null;</span>
<span class="fc" id="L306">        intrinsic = null;</span>
<span class="fc" id="L307">        distortion = null;</span>
<span class="fc" id="L308">        estimateRadialDistortion = DEFAULT_ESTIMATE_RADIAL_DISTORTION;</span>

<span class="fc" id="L310">        internalSetHomographyMethod(DEFAULT_HOMOGRAPHY_METHOD);</span>
<span class="fc" id="L311">        internalSetImageOfAbsoluteConicMethod(DEFAULT_IAC_METHOD);</span>

<span class="fc" id="L313">        internalSetSamples(samples);</span>
<span class="fc" id="L314">        internalSetSamplesQualityScores(samplesQualityScores);</span>

<span class="fc" id="L316">        progressDelta = DEFAULT_PROGRESS_DELTA;</span>
<span class="fc" id="L317">    }</span>

    /**
     * Returns pattern used for camera calibration. Each pattern contain a
     * unique combination of 2D points that must be sampled using the camera to
     * be calibrated.
     *
     * @return pattern used for camera calibration.
     */
    public Pattern2D getPattern() {
<span class="fc" id="L327">        return pattern;</span>
    }

    /**
     * Sets pattern used for camera calibration. Each pattern contains a unique
     * combination of 2D points that must be sampled using the camera to be
     * calibrated.
     *
     * @param pattern pattern used for camera calibration.
     * @throws LockedException if this instance is locked.
     */
    public void setPattern(final Pattern2D pattern) throws LockedException {
<span class="fc bfc" id="L339" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L340">            throw new LockedException();</span>
        }

<span class="fc" id="L343">        this.pattern = pattern;</span>
<span class="fc" id="L344">    }</span>

    /**
     * Returns list of samples obtained from different pictures using the same
     * camera device (or same camera model). Several samples can be used to
     * calibrate the camera (a pinhole camera can be estimated for each sample).
     * The more samples are used, typically the better the results.
     *
     * @return list of samples.
     */
    public List&lt;CameraCalibratorSample&gt; getSamples() {
<span class="fc" id="L355">        return samples;</span>
    }

    /**
     * Sets list of samples obtained from different pictures using the same
     * camera device (or same camera model). Several samples can be used to
     * calibrate the camera (a pinhole camera can be estimated for each sample).
     * The more samples are used, typically the better the results.
     *
     * @param samples list of samples.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if not enough samples are provided to
     *                                  estimate the intrinsic parameters. By default, the minimum is 1,
     *                                  but depending on the settings at least 3 samples might be required.
     */
    public void setSamples(final List&lt;CameraCalibratorSample&gt; samples) throws LockedException {
<span class="fc bfc" id="L371" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L372">            throw new LockedException();</span>
        }
<span class="fc" id="L374">        internalSetSamples(samples);</span>
<span class="fc" id="L375">    }</span>

    /**
     * Returns quality scores assigned to each provided sample. This can be used
     * on certain robust estimation methods of the IAC such as PROSAC and
     * PROMedS. If not provided, homography quality scores will be estimated
     * based on re-projection error and this value will be ignored.
     * Typically, this will not be provided, but it can be used in case that it
     * can be assured by some means that one sample is better than another
     *
     * @return quality scores assigned to each provided sample.
     */
    public double[] getSamplesQualityScores() {
<span class="fc" id="L388">        return samplesQualityScores;</span>
    }

    /**
     * Sets quality scores assigned to each provided sample. This can be used on
     * certain robust estimation methods of the IAC such as PROSAC and PROMedS.
     * If not provided, homography quality scores will be estimated based on
     * re-projection error and this value will be ignored.
     *
     * @param samplesQualityScores quality scores assigned to each provided
     *                             sample.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if not enough quality scores are
     *                                  provided for the corresponding samples to estimate the intrinsic
     *                                  parameters. By default, the minimum is 1, but depending on the
     *                                  settings at least 3 samples might be required.
     */
    public void setSamplesQualityScores(final double[] samplesQualityScores) throws LockedException {
<span class="fc bfc" id="L406" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L407">            throw new LockedException();</span>
        }
<span class="fc" id="L409">        internalSetSamplesQualityScores(samplesQualityScores);</span>
<span class="fc" id="L410">    }</span>

    /**
     * Returns quality scores for estimated homographies.
     * If samples quality scores were provided, these will be equal
     * to those provided. If no samples quality scores were provided,
     * these scores will be related to the estimated homography
     * estimation error based on sampled data and ideal data.
     * This should rarely be used. It can be used for debugging purposes
     * teo determine whether homographies used for calibration are
     * reliable or not.
     *
     * @return estimated quality scores for homographies.
     */
    public double[] getHomographyQualityScores() {
<span class="fc" id="L425">        return homographyQualityScores;</span>
    }

    /**
     * Returns estimated image of absolute conic. This can be used to obtain
     * intrinsic pinhole camera intrinsic parameters.
     *
     * @return estimated image of absolute conic or null if estimation has not
     * been completed.
     */
    public ImageOfAbsoluteConic getEstimatedImageOfAbsoluteConic() {
<span class="fc" id="L436">        return iac;</span>
    }

    /**
     * Returns estimated pinhole camera intrinsic parameters.
     *
     * @return estimated pinhole camera intrinsic parameters or null if
     * estimation has not been completed.
     */
    public PinholeCameraIntrinsicParameters getEstimatedIntrinsicParameters() {
<span class="fc" id="L446">        return intrinsic;</span>
    }

    /**
     * Returns estimated radial distortion due to camera lens.
     *
     * @return estimated radial distortion or null if estimation has not
     * completed or radial distortion was not requested.
     */
    public RadialDistortion getDistortion() {
<span class="fc" id="L456">        return distortion;</span>
    }

    /**
     * Returns boolean indicating whether radial distortion must be estimated or
     * not during calibration.
     *
     * @return true if radial distortion must be estimated, false otherwise.
     */
    public boolean getEstimateRadialDistortion() {
<span class="fc" id="L466">        return estimateRadialDistortion;</span>
    }

    /**
     * Sets boolean indicating whether radial distortion must be estimated or
     * not during calibration.
     *
     * @param estimateRadialDistortion true if radial distortion must be
     *                                 estimated, false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setEstimateRadialDistortion(final boolean estimateRadialDistortion) throws LockedException {
<span class="fc bfc" id="L478" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L479">            throw new LockedException();</span>
        }

<span class="fc" id="L482">        this.estimateRadialDistortion = estimateRadialDistortion;</span>
<span class="fc" id="L483">    }</span>

    /**
     * Returns robust estimator method to be used during homography estimation.
     * This will only be taken into account if more than 4 markers are detected
     * on a single sample, otherwise no robust method is used and a single LMSE
     * solution for the homography is found.
     *
     * @return robust estimator method to be used during homography estimation.
     */
    public RobustEstimatorMethod getHomographyMethod() {
<span class="fc" id="L494">        return homographyMethod;</span>
    }

    /**
     * Sets robust estimator method to be used during homography estimation.
     * This will only be taken into account if more than 4 markers are detected
     * on a single sample, otherwise no robust method is used and a single LMSE
     * solution for the homography is found.
     *
     * @param homographyMethod robust estimator method to be used during
     *                         homography estimation.
     * @throws LockedException if this instance is locked.
     */
    public void setHomographyMethod(final RobustEstimatorMethod homographyMethod) throws LockedException {
<span class="fc bfc" id="L508" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L509">            throw new LockedException();</span>
        }
<span class="fc" id="L511">        internalSetHomographyMethod(homographyMethod);</span>
<span class="fc" id="L512">    }</span>

    /**
     * Returns robust estimator method to be used during IAC estimation.
     * This will only be taken into account if more than 1 sample is provided,
     * otherwise no robust method is used and a single LMSE solution for the
     * IAC is found
     *
     * @return robust estimator method to be used during IAC estimation
     */
    public RobustEstimatorMethod getImageOfAbsoluteConicMethod() {
<span class="fc" id="L523">        return imageOfAbsoluteConicMethod;</span>
    }

    /**
     * Sets robust estimator method to be used during IAC estimation.
     * This will only be taken into account if more than 1 sample is provided,
     * otherwise no robust method is used and a single LMSE solution for the
     * IAC is found.
     *
     * @param imageOfAbsoluteConicMethod robust estimator method to be used
     *                                   during IAC estimation.
     * @throws LockedException if this instance is locked.
     */
    public void setImageOfAbsoluteConicMethod(final RobustEstimatorMethod imageOfAbsoluteConicMethod)
            throws LockedException {
<span class="fc bfc" id="L538" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L539">            throw new LockedException();</span>
        }
<span class="fc" id="L541">        internalSetImageOfAbsoluteConicMethod(imageOfAbsoluteConicMethod);</span>
<span class="fc" id="L542">    }</span>

    /**
     * Returns homography estimator, which can be retrieved in case that some
     * additional parameter needed to be adjusted.
     * It is discouraged to directly access the homography estimator during
     * camera calibration, as it might interfere with the results.
     *
     * @return homography estimator.
     */
    public PointCorrespondenceProjectiveTransformation2DRobustEstimator getHomographyEstimator() {
<span class="fc" id="L553">        return homographyEstimator;</span>
    }

    /**
     * Returns IAC estimator, which can be retrieved in case that some
     * additional parameter needed to be adjusted.
     * It is discouraged to directly access the homography estimator during
     * camera calibration, as it might interfere with the results.
     *
     * @return IAC estimator.
     */
    public ImageOfAbsoluteConicRobustEstimator getIACEstimator() {
<span class="fc" id="L565">        return iacEstimator;</span>
    }

    /**
     * Returns boolean indicating whether camera skewness is assumed to be zero
     * or not.
     * Skewness determines whether LCD sensor cells are properly aligned or not,
     * where zero indicates perfect alignment.
     * Typically, skewness is a value equal or very close to zero.
     *
     * @return true if camera skewness is assumed to be zero, otherwise camera
     * skewness is estimated.
     */
    public boolean isZeroSkewness() {
<span class="fc" id="L579">        return iacEstimator.isZeroSkewness();</span>
    }

    /**
     * Sets boolean indicating whether camera skewness is assumed to be zero or
     * not.
     * Skewness determines whether LCD sensor cells are properly aligned or not,
     * where zero indicates perfect alignment.
     * Typically, skewness is a value equal or very close to zero.
     *
     * @param zeroSkewness true if camera skewness is assumed to be zero,
     *                     otherwise camera skewness is estimated.
     * @throws LockedException if this instance is locked.
     */
    public void setZeroSkewness(final boolean zeroSkewness) throws LockedException {
<span class="fc bfc" id="L594" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L595">            throw new LockedException();</span>
        }

<span class="fc" id="L598">        iacEstimator.setZeroSkewness(zeroSkewness);</span>
<span class="fc" id="L599">    }</span>

    /**
     * Returns boolean indicating whether principal point is assumed to be at
     * origin of coordinates or not.
     * Typically principal point is located at image center (origin of
     * coordinates), and usually matches the center of radial distortion if it
     * is taken into account.
     *
     * @return true if principal point is assumed to be at origin of
     * coordinates, false if principal point must be estimated.
     */
    public boolean isPrincipalPointAtOrigin() {
<span class="fc" id="L612">        return iacEstimator.isPrincipalPointAtOrigin();</span>
    }

    /**
     * Sets boolean indicating whether principal point is assumed to be at
     * origin of coordinates or not.
     * Typically principal point is located at image center (origin of
     * coordinates), and usually matches the center of radial distortion if it
     * is taken into account.
     *
     * @param principalPointAtOrigin true if principal point is assumed to bet
     *                               at origin of coordinates, false if principal point must be estimated.
     * @throws LockedException if estimator is locked.
     */
    public void setPrincipalPointAtOrigin(final boolean principalPointAtOrigin) throws LockedException {
<span class="fc bfc" id="L627" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L628">            throw new LockedException();</span>
        }

<span class="fc" id="L631">        iacEstimator.setPrincipalPointAtOrigin(principalPointAtOrigin);</span>
<span class="fc" id="L632">    }</span>

    /**
     * Returns boolean indicating whether aspect ratio of focal distances (i.e.
     * vertical focal distance divided by horizontal focal distance) is known or
     * not.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio. Typically, LCD sensor cells are square and hence aspect
     * ratio of focal distances is known and equal to 1.
     * This value is only taken into account if skewness is assumed to be zero,
     * otherwise it is ignored.
     *
     * @return true if focal distance aspect ratio is known, false otherwise.
     */
    public boolean isFocalDistanceAspectRatioKnown() {
<span class="fc" id="L647">        return iacEstimator.isFocalDistanceAspectRatioKnown();</span>
    }

    /**
     * Sets boolean indicating whether aspect ratio of focal distances (i.e.
     * vertical focal distance divided by horizontal focal distance) is known or
     * not.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio. Typically, LCD sensor cells are square and hence aspect
     * ratio of focal distances is known and equal to 1.
     * This value is only taken into account if skewness is assumed to be zero,
     * otherwise it is ignored.
     *
     * @param focalDistanceAspectRatioKnown true if focal distance aspect ratio
     *                                      is known, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFocalDistanceAspectRatioKnown(final boolean focalDistanceAspectRatioKnown) throws LockedException {
<span class="fc bfc" id="L665" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L666">            throw new LockedException();</span>
        }

<span class="fc" id="L669">        iacEstimator.setFocalDistanceAspectRatioKnown(focalDistanceAspectRatioKnown);</span>
<span class="fc" id="L670">    }</span>

    /**
     * Returns aspect ratio of focal distances (i.e. vertical focal distance
     * divided by horizontal focal distance).
     * This value is only taken into account if skewness is assumed to be zero
     * and focal distance aspect ratio is marked as known, otherwise it is
     * ignored.
     * By default, this is 1.0, since it is taken into account that typically
     * LCD sensor cells are square and hence aspect ratio focal distances is
     * known and equal to 1.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio.
     * Notice that a negative aspect ratio indicates that vertical axis is
     * reversed. This can be useful in some situations where image vertical
     * coordinates are reversed respect to the physical world (i.e. in computer
     * graphics typically image vertical coordinates go downwards, while in
     * physical world they go upwards).
     *
     * @return aspect ratio of focal distances.
     */
    public double getFocalDistanceAspectRatio() {
<span class="fc" id="L692">        return iacEstimator.getFocalDistanceAspectRatio();</span>
    }

    /**
     * Sets aspect ratio of focal distances (i.e. vertical focal distance
     * divided by horizontal focal distance).
     * This value is only taken into account if skewness is assumed to be zero
     * and focal distance aspect ratio is marked as known, otherwise it is
     * ignored.
     * By default, this is 1.0, since it is taken into account that typically
     * LCD sensor cells are square and hence aspect ratio focal distances is
     * known and equal to 1.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio.
     * Notice that a negative aspect ratio indicates that vertical axis is
     * reversed. This can be useful in some situations where image vertical
     * coordinates are reversed respect to the physical world (i.e. in computer
     * graphics typically image vertical coordinates go downwards, while in
     * physical world they go upwards).
     *
     * @param focalDistanceAspectRatio aspect ratio of focal distances to be set.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if focal distance aspect ratio is too
     *                                  close to zero, as it might produce numerical instabilities.
     */
    public void setFocalDistanceAspectRatio(final double focalDistanceAspectRatio) throws LockedException {
<span class="fc bfc" id="L718" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L719">            throw new LockedException();</span>
        }

<span class="fc" id="L722">        iacEstimator.setFocalDistanceAspectRatio(focalDistanceAspectRatio);</span>
<span class="fc" id="L723">    }</span>

    /**
     * Indicates whether this instance is locked because calibration is in
     * progress.
     *
     * @return true if this instance, false otherwise.
     */
    public boolean isLocked() {
<span class="fc" id="L732">        return locked;</span>
    }

    /**
     * Returns amount of progress variation before notifying a progress change
     * during estimation.
     *
     * @return amount of progress variation before notifying a progress change
     * during estimation.
     */
    public float getProgressDelta() {
<span class="fc" id="L743">        return progressDelta;</span>
    }

    /**
     * Sets amount of progress variation before notifying a progress change
     * during estimation.
     *
     * @param progressDelta amount of progress variation before notifying a
     *                      progress change during estimation.
     * @throws IllegalArgumentException if progress delta is less than zero or
     *                                  greater than 1.
     * @throws LockedException          if this estimator is locked because an estimation
     *                                  is being computed.
     */
    public void setProgressDelta(final float progressDelta) throws LockedException {
<span class="fc bfc" id="L758" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L759">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L761" title="2 of 4 branches missed.">        if (progressDelta &lt; MIN_PROGRESS_DELTA || progressDelta &gt; MAX_PROGRESS_DELTA) {</span>
<span class="nc" id="L762">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L764">        this.progressDelta = progressDelta;</span>
<span class="fc" id="L765">    }</span>

    /**
     * Indicates whether this instance is ready to start camera calibration
     *
     * @return true if this instance has enough data to start camera
     * calibration, false otherwise.
     */
    public boolean isReady() {
<span class="pc bpc" id="L774" title="1 of 4 branches missed.">        return pattern != null &amp;&amp; samples != null</span>
<span class="pc bpc" id="L775" title="1 of 2 branches missed.">                &amp;&amp; samples.size() &gt;= iacEstimator.getMinNumberOfRequiredHomographies();</span>
    }

    /**
     * Returns threshold to robustly estimate homographies between ideal pattern
     * markers and sampled pattern markers.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments
     *
     * @return threshold to robustly estimate homographies between ideal pattern
     * markers and sampled pattern markers.
     */
    public double getHomographyEstimatorThreshold() {
<span class="fc bfc" id="L788" title="All 5 branches covered.">        return switch (homographyEstimator.getMethod()) {</span>
<span class="fc" id="L789">            case LMEDS -&gt; ((LMedSPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator)</span>
<span class="fc" id="L790">                    .getStopThreshold();</span>
<span class="fc" id="L791">            case MSAC -&gt; ((MSACPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator)</span>
<span class="fc" id="L792">                    .getThreshold();</span>
<span class="fc" id="L793">            case PROSAC -&gt; ((PROSACPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator)</span>
<span class="fc" id="L794">                    .getThreshold();</span>
<span class="fc" id="L795">            case PROMEDS -&gt; ((PROMedSPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator)</span>
<span class="fc" id="L796">                    .getStopThreshold();</span>
<span class="fc" id="L797">            default -&gt; ((RANSACPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator)</span>
<span class="fc" id="L798">                    .getThreshold();</span>
        };
    }

    /**
     * Sets threshold to robustly estimate homographies between ideal pattern
     * markers and sampled pattern markers.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @param homographyEstimatorThreshold threshold to robustly estimate
     *                                     homographies between ideal pattern markers and sampled pattern markers.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setHomographyEstimatorThreshold(final double homographyEstimatorThreshold) throws LockedException {
<span class="fc bfc" id="L814" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L815">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L818" title="All 5 branches covered.">        switch (homographyEstimator.getMethod()) {</span>
            case LMEDS:
<span class="fc" id="L820">                ((LMedSPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator).</span>
<span class="fc" id="L821">                        setStopThreshold(homographyEstimatorThreshold);</span>
<span class="fc" id="L822">                break;</span>
            case MSAC:
<span class="fc" id="L824">                ((MSACPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator).</span>
<span class="fc" id="L825">                        setThreshold(homographyEstimatorThreshold);</span>
<span class="fc" id="L826">                break;</span>
            case PROSAC:
<span class="fc" id="L828">                ((PROSACPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator).</span>
<span class="fc" id="L829">                        setThreshold(homographyEstimatorThreshold);</span>
<span class="fc" id="L830">                break;</span>
            case PROMEDS:
<span class="fc" id="L832">                ((PROMedSPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator).</span>
<span class="fc" id="L833">                        setStopThreshold(homographyEstimatorThreshold);</span>
<span class="fc" id="L834">                break;</span>
            case RANSAC:
            default:
<span class="fc" id="L837">                ((RANSACPointCorrespondenceProjectiveTransformation2DRobustEstimator) homographyEstimator).</span>
<span class="fc" id="L838">                        setThreshold(homographyEstimatorThreshold);</span>
                break;
        }
<span class="fc" id="L841">    }</span>

    /**
     * Returns confidence to robustly estimate homographies between ideal
     * pattern markers and sampled pattern markers.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     * Confidence is expressed as a value between 0.0 (0%) and 1.0 (100%). The
     * amount of confidence indicates the probability that the estimated
     * homography is correct (i.e. no outliers were used for the estimation,
     * because they were successfully discarded).
     * Typically, this value will be close to 1.0, but not exactly 1.0, because
     * a 100% confidence would require an infinite number of iterations.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @return confidence to robustly estimate homographies.
     */
    public double getHomographyEstimatorConfidence() {
<span class="fc" id="L860">        return homographyEstimator.getConfidence();</span>
    }

    /**
     * Sets confidence to robustly estimate homographies between ideal pattern
     * markers and sampled pattern markers.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     * Confidence is expressed as a value between 0.0 (0%) and 1.0 (100%). The
     * amount of confidence indicates the probability that the estimated
     * homography is correct (i.e. no outliers were used for the estimation,
     * because they were successfully discarded).
     * Typically, this value will be close to 1.0, but not exactly 1.0, because
     * a 100% confidence would require an infinite number of iterations.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @param homographyEstimatorConfidence confidence to robustly estimate
     *                                      homographies.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided value is not between 0.0 and
     *                                  1.0.
     */
    public void setHomographyEstimatorConfidence(final double homographyEstimatorConfidence) throws LockedException {
<span class="fc bfc" id="L884" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L885">            throw new LockedException();</span>
        }

<span class="fc" id="L888">        homographyEstimator.setConfidence(homographyEstimatorConfidence);</span>
<span class="fc" id="L889">    }</span>

    /**
     * Returns the maximum number of iterations to be done when estimating
     * the homographies between ideal pattern markers and sampled pattern
     * markers.
     * If the maximum allowed number of iterations is reached, resulting
     * estimation might not have desired confidence.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @return maximum number of iterations to be done when estimating the
     * homographies.
     */
    public int getHomographyEstimatorMaxIterations() {
<span class="fc" id="L904">        return homographyEstimator.getMaxIterations();</span>
    }

    /**
     * Sets the maximum number of iterations to be done when estimating the
     * homographies between ideal pattern markers and sampled pattern markers.
     * If the maximum allowed number of iterations is reached, resulting
     * estimation might not have desired confidence.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @param homographyEstimatorMaxIterations maximum number of iterations to
     *                                         be done when estimating the homographies between ideal
     *                                         pattern markers and sampled pattern markers.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided value is negative or zero.
     */
    public void setHomographyEstimatorMaxIterations(final int homographyEstimatorMaxIterations) throws LockedException {
<span class="fc bfc" id="L922" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L923">            throw new LockedException();</span>
        }

<span class="fc" id="L926">        homographyEstimator.setMaxIterations(homographyEstimatorMaxIterations);</span>
<span class="fc" id="L927">    }</span>

    /**
     * Returns threshold to robustly estimate the image of absolute conic.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @return threshold to robustly estimate the image of absolute conic.
     */
    public double getIACEstimatorThreshold() {
<span class="fc bfc" id="L937" title="All 5 branches covered.">        return switch (iacEstimator.getMethod()) {</span>
<span class="fc" id="L938">            case LMEDS -&gt; ((LMedSImageOfAbsoluteConicRobustEstimator) iacEstimator).getStopThreshold();</span>
<span class="fc" id="L939">            case MSAC -&gt; ((MSACImageOfAbsoluteConicRobustEstimator) iacEstimator).getThreshold();</span>
<span class="fc" id="L940">            case PROSAC -&gt; ((PROSACImageOfAbsoluteConicRobustEstimator) iacEstimator).getThreshold();</span>
<span class="fc" id="L941">            case PROMEDS -&gt; ((PROMedSImageOfAbsoluteConicRobustEstimator) iacEstimator).getStopThreshold();</span>
<span class="fc" id="L942">            default -&gt; ((RANSACImageOfAbsoluteConicRobustEstimator) iacEstimator).getThreshold();</span>
        };
    }

    /**
     * Sets threshold to robustly estimate the image of absolute conic.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @param iacEstimatorThreshold threshold to robustly estimate the image of
     *                              absolute conic.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setIACEstimatorThreshold(final double iacEstimatorThreshold) throws LockedException {
<span class="fc bfc" id="L957" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L958">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L961" title="All 5 branches covered.">        switch (iacEstimator.getMethod()) {</span>
            case LMEDS:
<span class="fc" id="L963">                ((LMedSImageOfAbsoluteConicRobustEstimator) iacEstimator).setStopThreshold(iacEstimatorThreshold);</span>
<span class="fc" id="L964">                break;</span>
            case MSAC:
<span class="fc" id="L966">                ((MSACImageOfAbsoluteConicRobustEstimator) iacEstimator).setThreshold(iacEstimatorThreshold);</span>
<span class="fc" id="L967">                break;</span>
            case PROSAC:
<span class="fc" id="L969">                ((PROSACImageOfAbsoluteConicRobustEstimator) iacEstimator).setThreshold(iacEstimatorThreshold);</span>
<span class="fc" id="L970">                break;</span>
            case PROMEDS:
<span class="fc" id="L972">                ((PROMedSImageOfAbsoluteConicRobustEstimator) iacEstimator).setStopThreshold(iacEstimatorThreshold);</span>
<span class="fc" id="L973">                break;</span>
            case RANSAC:
            default:
<span class="fc" id="L976">                ((RANSACImageOfAbsoluteConicRobustEstimator) iacEstimator).setThreshold(iacEstimatorThreshold);</span>
                break;
        }
<span class="fc" id="L979">    }</span>

    /**
     * Returns confidence to robustly estimate image of absolute conic
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     * Confidence is expressed as a value between 0.0 (0%) and 1.0 (100%). The
     * amount of confidence indicates the probability that the estimated
     * homography is correct (i.e. no outliers were used for the estimation,
     * because they were successfully discarded).
     * Typically, this value will be close to 1.0, but not exactly 1.0, because
     * a 100% confidence would require an infinite number of iterations.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @return confidence to robustly estimate the IAC.
     */
    public double getIACEstimatorConfidence() {
<span class="fc" id="L997">        return iacEstimator.getConfidence();</span>
    }

    /**
     * Sets confidence to robustly estimate image of absolute conic.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     * Confidence is expressed as a value between 0.0 (0%) and 1.0 (100%). The
     * amount of confidence indicates the probability that the estimated
     * homography is correct (i.e. no outliers were used for the estimation,
     * because they were successfully discarded).
     * Typically, this value will be close to 1.0, but not exactly 1.0, because
     * a 100% confidence would require an infinite number of iterations.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @param iacEstimatorConfidence confidence to robustly estimate the IAC.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided value is not between 0.0 and
     *                                  1.0.
     */
    public void setIACEstimatorConfidence(final double iacEstimatorConfidence) throws LockedException {
<span class="fc bfc" id="L1019" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1020">            throw new LockedException();</span>
        }

<span class="fc" id="L1023">        iacEstimator.setConfidence(iacEstimatorConfidence);</span>
<span class="fc" id="L1024">    }</span>

    /**
     * Returns the maximum number of iterations to be done when estimating
     * the image of absolute conic.
     * If the maximum allowed number of iterations is reached, resulting
     * estimation might not have desired confidence.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @return maximum number of iterations to be done when estimating the
     * image of absolute conic.
     */
    public int getIACEstimatorMaxIterations() {
<span class="fc" id="L1038">        return iacEstimator.getMaxIterations();</span>
    }

    /**
     * Sets the maximum number of iterations to be done when estimating the
     * image of absolute conic.
     * If the maximum allowed number of iterations is reached, resulting
     * estimation might not have desired confidence.
     * Usually the default value is good enough for most situations, but this
     * setting can be changed for finer adjustments.
     *
     * @param iacEstimatorMaxIterations maximum number of iterations to be done
     *                                  when estimating the image of absolute conic.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided value is negative or zero.
     */
    public void setIACEstimatorMaxIterations(final int iacEstimatorMaxIterations) throws LockedException {
<span class="fc bfc" id="L1055" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1056">            throw new LockedException();</span>
        }

<span class="fc" id="L1059">        iacEstimator.setMaxIterations(iacEstimatorMaxIterations);</span>
<span class="fc" id="L1060">    }</span>

    /**
     * Returns listener to notify when calibration starts, finishes or its
     * progress significantly changes.
     *
     * @return listener to notify when calibration starts, finishes or its
     * progress significantly changes.
     */
    public CameraCalibratorListener getListener() {
<span class="fc" id="L1070">        return listener;</span>
    }

    /**
     * Sets listener to notify when calibration starts, finishes or its progress
     * significantly changes.
     *
     * @param listener listener to notify when calibration starts, finishes or
     *                 its progress significantly changes.
     * @throws LockedException if this instance is locked.
     */
    public void setListener(final CameraCalibratorListener listener) throws LockedException {
<span class="fc bfc" id="L1082" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L1083">            throw new LockedException();</span>
        }

<span class="fc" id="L1086">        this.listener = listener;</span>
<span class="fc" id="L1087">    }</span>

    /**
     * Creates a camera calibrator using provided method.
     *
     * @param method a camera calibrator method.
     * @return a camera calibrator.
     */
    public static CameraCalibrator create(final CameraCalibratorMethod method) {
<span class="fc bfc" id="L1096" title="All 2 branches covered.">        return method == CameraCalibratorMethod.ERROR_OPTIMIZATION</span>
<span class="fc" id="L1097">                ? new ErrorOptimizationCameraCalibrator() : new AlternatingCameraCalibrator();</span>
    }

    /**
     * Creates a camera calibrator using provided pattern, samples and
     * method.
     *
     * @param pattern a 2D pattern to use for calibration.
     * @param samples samples of the 2D pattern taken with the camera to be
     *                calibrated.
     * @param method  a camera calibrator method.
     * @return a camera calibrator.
     * @throws IllegalArgumentException if not enough samples are provided.
     */
    public static CameraCalibrator create(final Pattern2D pattern, final List&lt;CameraCalibratorSample&gt; samples,
                                          final CameraCalibratorMethod method) {
<span class="fc bfc" id="L1113" title="All 2 branches covered.">        return method == CameraCalibratorMethod.ERROR_OPTIMIZATION</span>
<span class="fc" id="L1114">                ? new ErrorOptimizationCameraCalibrator(pattern, samples)</span>
<span class="fc" id="L1115">                : new AlternatingCameraCalibrator(pattern, samples);</span>
    }

    /**
     * Creates a camera calibrator using provided pattern, samples and method.
     *
     * @param pattern              a 2D pattern to use for calibration.
     * @param samples              samples of the 2D pattern taken with the camera to be
     *                             calibrated.
     * @param samplesQualityScores quality scores for each sample.
     * @param method               a camera calibrator method.
     * @return a camera calibrator.
     * @throws IllegalArgumentException if not enough samples are provided.
     */
    public static CameraCalibrator create(
            final Pattern2D pattern, final List&lt;CameraCalibratorSample&gt; samples, final double[] samplesQualityScores,
            final CameraCalibratorMethod method) {
<span class="fc bfc" id="L1132" title="All 2 branches covered.">        return method == CameraCalibratorMethod.ERROR_OPTIMIZATION</span>
<span class="fc" id="L1133">                ? new ErrorOptimizationCameraCalibrator(pattern, samples, samplesQualityScores)</span>
<span class="fc" id="L1134">                : new AlternatingCameraCalibrator(pattern, samples, samplesQualityScores);</span>
    }

    /**
     * Creates a camera calibrator using default method.
     *
     * @return a camera calibrator.
     */
    public static CameraCalibrator create() {
<span class="fc" id="L1143">        return create(DEFAULT_METHOD);</span>
    }

    /**
     * Creates a camera calibrator using provided pattern, samples and
     * default method.
     *
     * @param pattern a 2D pattern to use for calibration.
     * @param samples samples of the 2D pattern taken with the camera to be
     *                calibrated.
     * @return a camera calibrator.
     * @throws IllegalArgumentException if not enough samples are provided.
     */
    public static CameraCalibrator create(final Pattern2D pattern, final List&lt;CameraCalibratorSample&gt; samples) {
<span class="fc" id="L1157">        return create(pattern, samples, DEFAULT_METHOD);</span>
    }

    /**
     * Creates a camera calibrator using provided pattern, samples and default
     * method.
     *
     * @param pattern              a 2D pattern to use for calibration.
     * @param samples              samples of the 2D pattern taken with the camera to be
     *                             calibrated.
     * @param samplesQualityScores quality scores for each sample.
     * @return a camera calibrator.
     * @throws IllegalArgumentException if not enough samples are provided.
     */
    public static CameraCalibrator create(
            final Pattern2D pattern, final List&lt;CameraCalibratorSample&gt; samples, final double[] samplesQualityScores) {
<span class="fc" id="L1173">        return create(pattern, samples, samplesQualityScores, DEFAULT_METHOD);</span>
    }

    /**
     * Starts the calibration process.
     * Depending on the settings the following will be estimated:
     * intrinsic pinhole camera parameters, radial distortion of lens,
     * camera pose (rotation and translation) for each sample, and the
     * associated homobraphy of sampled points respect to the ideal pattern
     * samples.
     *
     * @throws CalibrationException if calibration fails for some reason.
     * @throws LockedException      if this instance is locked because calibration is
     *                              already in progress.
     * @throws NotReadyException    if this instance does not have enough data to
     *                              start camera calibration.
     */
    public abstract void calibrate() throws CalibrationException, LockedException, NotReadyException;

    /**
     * Returns the camera calibrator method used by this instance.
     *
     * @return the camera calibrator method.
     */
    public abstract CameraCalibratorMethod getMethod();

    /**
     * Notifies progress to current listener, if needed.
     */
    protected abstract void notifyProgress();

    /**
     * Computes intrinsic estimation progress.
     */
    protected void computeIntrinsicProgress() {
<span class="fc" id="L1208">        final var lambda = 1.0f / samples.size();</span>
<span class="fc" id="L1209">        intrinsicProgress = 0.5f * (sampleProgress + lambda * homographyProgress) + 0.5f * iacProgress;</span>
<span class="fc" id="L1210">    }</span>

    /**
     * Resets estimated value to their initial values.
     */
    protected void reset() {
<span class="fc" id="L1216">        homographies = null;</span>
<span class="fc bfc" id="L1217" title="All 2 branches covered.">        for (final var sample : samples) {</span>
<span class="fc" id="L1218">            sample.setUndistortedMarkers(null);</span>
<span class="fc" id="L1219">            sample.setHomography(null);</span>
<span class="fc" id="L1220">            sample.setRotation(null);</span>
<span class="fc" id="L1221">            sample.setCameraCenter(null);</span>
<span class="fc" id="L1222">            sample.setCamera(null);</span>
<span class="fc" id="L1223">        }</span>
<span class="fc" id="L1224">        homographyQualityScores = null;</span>
<span class="fc" id="L1225">        iac = null;</span>
<span class="fc" id="L1226">        intrinsic = null;</span>
<span class="fc" id="L1227">        distortion = null;</span>
<span class="fc" id="L1228">    }</span>

    /**
     * Estimates pinhole camera intrinsic parameters without accounting for
     * lens radial distortion.
     *
     * @param idealFallbackPatternMarkers ideal pattern markers coordinates used
     *                                    as fallback if pattern is not provided for a given sample.
     * @throws CalibrationException if calibration fails for some reason.
     */
    protected void estimateIntrinsicParameters(final List&lt;Point2D&gt; idealFallbackPatternMarkers)
            throws CalibrationException {

<span class="fc" id="L1241">        homographyProgress = sampleProgress = iacProgress = intrinsicProgress = 0.0f;</span>

<span class="pc bpc" id="L1243" title="1 of 2 branches missed.">        if (listener != null) {</span>
<span class="fc" id="L1244">            listener.onIntrinsicParametersEstimationStarts(this);</span>
        }

        // for each sample estimate the homography between the ideal pattern
        // markers and the sampled ones
        List&lt;Point2D&gt; sampledPatternMarkers;
<span class="fc" id="L1250">        final var sampleSize = samples.size();</span>
<span class="fc" id="L1251">        homographies = new ArrayList&lt;&gt;(sampleSize);</span>
<span class="fc" id="L1252">        final var tmpHomographyQualityScores = new double[sampleSize];</span>
<span class="fc" id="L1253">        var index = 0;</span>
<span class="fc" id="L1254">        var counter = 0;</span>
        double error;
<span class="fc bfc" id="L1256" title="All 2 branches covered.">        for (final var sample : samples) {</span>
            try {
                // reset homography before estimation in case that estimation
                // fails on current iteration
<span class="fc" id="L1260">                sample.setHomography(null);</span>
                final List&lt;Point2D&gt; idealPatternMarkers;
<span class="fc bfc" id="L1262" title="All 2 branches covered.">                if (sample.getPattern() != null) {</span>
                    // use sample pattern for homography estimation
<span class="fc" id="L1264">                    idealPatternMarkers = sample.getPattern().getIdealPoints();</span>
                } else {
                    // use fallback pattern common to all samples
<span class="fc" id="L1267">                    idealPatternMarkers = idealFallbackPatternMarkers;</span>
                }
<span class="fc" id="L1269">                final var homography = sample.estimateHomography(homographyEstimator, idealPatternMarkers);</span>
<span class="fc bfc" id="L1270" title="All 2 branches covered.">                sampledPatternMarkers = sample.getUndistortedMarkers() != null</span>
<span class="fc" id="L1271">                        ? sample.getUndistortedMarkers() : sample.getSampledMarkers();</span>
<span class="fc" id="L1272">                sample.setHomography(homography);</span>
<span class="fc" id="L1273">                homographies.add(homography);</span>

<span class="fc bfc" id="L1275" title="All 2 branches covered.">                if (iacEstimator.getMethod() == RobustEstimatorMethod.PROSAC</span>
<span class="pc bpc" id="L1276" title="3 of 4 branches missed.">                        || iacEstimator.getMethod() == RobustEstimatorMethod.PROMEDS</span>
                        || homographyQualityScoresRequired) {
<span class="pc bpc" id="L1278" title="1 of 2 branches missed.">                    if (samplesQualityScores != null) {</span>
                        // pick corresponding quality score
<span class="nc" id="L1280">                        tmpHomographyQualityScores[counter] = samplesQualityScores[index];</span>
                    } else {
                        // compute re-projection error
<span class="fc" id="L1283">                        error = homographyTransformationError(homography, idealPatternMarkers, sampledPatternMarkers);</span>
<span class="fc" id="L1284">                        tmpHomographyQualityScores[counter] = 1.0 / (1.0 + error);</span>
                    }
                }
                // counter of homography estimation successes
<span class="fc" id="L1288">                counter++;</span>
<span class="fc" id="L1289">            } catch (final NumericalException | GeometryException ignore) {</span>
                // homographies are attempted to be estimated. It's ok if some fail
<span class="fc" id="L1291">            }</span>

            // position index (regardless of homography estimation success)
<span class="fc" id="L1294">            index++;</span>

<span class="fc" id="L1296">            homographyProgress = 0.0f;</span>
<span class="fc" id="L1297">            sampleProgress = (float) index / (float) sampleSize;</span>
<span class="fc" id="L1298">            computeIntrinsicProgress();</span>
<span class="fc" id="L1299">            notifyProgress();</span>
<span class="fc" id="L1300">        }</span>

<span class="fc bfc" id="L1302" title="All 2 branches covered.">        if (iacEstimator.getMethod() == RobustEstimatorMethod.PROSAC</span>
<span class="pc bpc" id="L1303" title="3 of 4 branches missed.">                || iacEstimator.getMethod() == RobustEstimatorMethod.PROMEDS || homographyQualityScoresRequired) {</span>

            // truncate tmpHomographyQualityScores to contain only actual number of
            // successfully estimated homographies
<span class="fc" id="L1307">            homographyQualityScores = Arrays.copyOf(tmpHomographyQualityScores, counter);</span>
        }

        // estimate IAC using estimated homographies
        try {
<span class="fc" id="L1312">            iacEstimator.setHomographies(homographies);</span>
<span class="fc" id="L1313">            iacEstimator.setQualityScores(homographyQualityScores);</span>
<span class="fc" id="L1314">            iac = iacEstimator.estimate();</span>

<span class="fc" id="L1316">            intrinsic = iac.getIntrinsicParameters();</span>
<span class="nc" id="L1317">        } catch (final GeometryException | NumericalException e) {</span>
<span class="nc" id="L1318">            throw new CalibrationException(e);</span>
<span class="fc" id="L1319">        }</span>

<span class="pc bpc" id="L1321" title="1 of 2 branches missed.">        if (listener != null) {</span>
<span class="fc" id="L1322">            listener.onIntrinsicParametersEstimationEnds(this, intrinsic);</span>
        }
<span class="fc" id="L1324">    }</span>

    /**
     * Computes average transformation error as a result of comparing sampled
     * pattern markers against the transformation of ideal pattern markers using
     * the estimated homography.
     *
     * @param homography            estimated homography.
     * @param idealPatternMarkers   ideal pattern markers.
     * @param sampledPatternMarkers sampled pattern markers.
     * @return average re-projection error.
     */
    protected static double homographyTransformationError(
            final Transformation2D homography, final List&lt;Point2D&gt; idealPatternMarkers,
            final List&lt;Point2D&gt; sampledPatternMarkers) {

<span class="fc" id="L1340">        final var transformedPoint = new HomogeneousPoint2D();</span>
        Point2D idealPatternMarker;
        Point2D sampledPatternMarker;
<span class="fc" id="L1343">        var avgError = 0.0;</span>
        double distance;
<span class="fc" id="L1345">        final var size = sampledPatternMarkers.size();</span>
<span class="fc bfc" id="L1346" title="All 2 branches covered.">        for (var i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1347">            idealPatternMarker = idealPatternMarkers.get(i);</span>
<span class="fc" id="L1348">            sampledPatternMarker = sampledPatternMarkers.get(i);</span>

<span class="fc" id="L1350">            homography.transform(idealPatternMarker, transformedPoint);</span>
<span class="fc" id="L1351">            distance = transformedPoint.distanceTo(sampledPatternMarker);</span>
<span class="fc" id="L1352">            avgError += distance;</span>
        }

<span class="fc" id="L1355">        avgError /= size;</span>

<span class="fc" id="L1357">        return avgError;</span>
    }

    /**
     * Refreshes listener of homography estimator.
     */
    protected void refreshHomographyEstimatorListener() {
<span class="fc bfc" id="L1364" title="All 2 branches covered.">        if (homographyEstimatorListener == null) {</span>
<span class="fc" id="L1365">            homographyEstimatorListener = new ProjectiveTransformation2DRobustEstimatorListener() {</span>

                @Override
                public void onEstimateStart(final ProjectiveTransformation2DRobustEstimator estimator) {
<span class="fc" id="L1369">                    homographyProgress = 0.0f;</span>
<span class="fc" id="L1370">                    computeIntrinsicProgress();</span>
<span class="fc" id="L1371">                    notifyProgress();</span>
<span class="fc" id="L1372">                }</span>

                @Override
                public void onEstimateEnd(final ProjectiveTransformation2DRobustEstimator estimator) {
<span class="fc" id="L1376">                    homographyProgress = 1.0f;</span>
<span class="fc" id="L1377">                    computeIntrinsicProgress();</span>
<span class="fc" id="L1378">                    notifyProgress();</span>
<span class="fc" id="L1379">                }</span>

                @Override
                public void onEstimateNextIteration(
                        final ProjectiveTransformation2DRobustEstimator estimator, int iteration) {
                    // not used
<span class="fc" id="L1385">                }</span>

                @Override
                public void onEstimateProgressChange(
                        final ProjectiveTransformation2DRobustEstimator estimator, final float progress) {
<span class="fc" id="L1390">                    homographyProgress = progress;</span>
<span class="fc" id="L1391">                    computeIntrinsicProgress();</span>
<span class="fc" id="L1392">                    notifyProgress();</span>
<span class="fc" id="L1393">                }</span>
            };
        }

        try {
<span class="fc" id="L1398">            homographyEstimator.setListener(homographyEstimatorListener);</span>
<span class="nc" id="L1399">        } catch (final LockedException e) {</span>
<span class="nc" id="L1400">            Logger.getLogger(CameraCalibrator.class.getName()).log(Level.WARNING,</span>
                    &quot;Could not set homography estimator listener&quot;, e);
<span class="fc" id="L1402">        }</span>
<span class="fc" id="L1403">    }</span>

    /**
     * Refreshes listener of IAC estimator.
     */
    protected void refreshIACEstimatorListener() {
<span class="fc bfc" id="L1409" title="All 2 branches covered.">        if (iacEstimatorListener == null) {</span>
<span class="fc" id="L1410">            iacEstimatorListener = new ImageOfAbsoluteConicRobustEstimatorListener() {</span>

                @Override
                public void onEstimateStart(final ImageOfAbsoluteConicRobustEstimator estimator) {
<span class="fc" id="L1414">                    iacProgress = 0.0f;</span>
<span class="fc" id="L1415">                    computeIntrinsicProgress();</span>
<span class="fc" id="L1416">                    notifyProgress();</span>
<span class="fc" id="L1417">                }</span>

                @Override
                public void onEstimateEnd(final ImageOfAbsoluteConicRobustEstimator estimator) {
<span class="fc" id="L1421">                    iacProgress = 1.0f;</span>
<span class="fc" id="L1422">                    computeIntrinsicProgress();</span>
<span class="fc" id="L1423">                    notifyProgress();</span>
<span class="fc" id="L1424">                }</span>

                @Override
                public void onEstimateNextIteration(
                        final ImageOfAbsoluteConicRobustEstimator estimator, final int iteration) {
                    // not used
<span class="fc" id="L1430">                }</span>

                @Override
                public void onEstimateProgressChange(
                        final ImageOfAbsoluteConicRobustEstimator estimator, final float progress) {
<span class="fc" id="L1435">                    iacProgress = progress;</span>
<span class="fc" id="L1436">                    computeIntrinsicProgress();</span>
<span class="fc" id="L1437">                    notifyProgress();</span>
<span class="fc" id="L1438">                }</span>
            };
        }

        try {
<span class="fc" id="L1443">            iacEstimator.setListener(iacEstimatorListener);</span>
<span class="nc" id="L1444">        } catch (final LockedException e) {</span>
<span class="nc" id="L1445">            Logger.getLogger(CameraCalibrator.class.getName()).log(Level.WARNING,</span>
                    &quot;Could not set IAC estimator listener&quot;, e);
<span class="fc" id="L1447">        }</span>
<span class="fc" id="L1448">    }</span>

    /**
     * Internal method to set list of samples obtained from different pictures
     * using the same camera device (or same camera model). Several samples can
     * be used to calibrate the camera (a pinhole camera can be estimated for
     * each sample). The more samples are used, typically the better the
     * results.
     * This method is for internal use only and does not check whether this
     * instance is locked or not.
     *
     * @param samples list of samples.
     * @throws IllegalArgumentException if not enough samples are provided to
     *                                  estimate the intrinsic parameters. By default, the minimum is 1,
     *                                  but depending on the settings at least 3 samples might be required.
     */
    private void internalSetSamples(final List&lt;CameraCalibratorSample&gt; samples) {
<span class="fc bfc" id="L1465" title="All 2 branches covered.">        if (samples.size() &lt; iacEstimator.getMinNumberOfRequiredHomographies()) {</span>
<span class="fc" id="L1466">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1469">        this.samples = samples;</span>
<span class="fc" id="L1470">    }</span>

    /**
     * Sets quality scores assigned to each provided sample. This can be used on
     * certain robust estimation methods of the IAC such as PROSAC and PROMedS.
     * If not provided, homography quality scores will be estimated based on
     * re-projection error and this value will be ignored.
     * This method is for internal use only and does not check whether this
     * instance is locked or not.
     *
     * @param samplesQualityScores quality scores assigned to each provided
     *                             sample.
     * @throws IllegalArgumentException if not enough quality scores are
     *                                  provided for the corresponding samples to estimate the intrinsic
     *                                  parameters. By default, the minimum is 1, but depending on the
     *                                  settings at least 3 samples might be required.
     */
    private void internalSetSamplesQualityScores(final double[] samplesQualityScores) {
<span class="fc bfc" id="L1488" title="All 2 branches covered.">        if (samplesQualityScores.length &lt; iacEstimator.getMinNumberOfRequiredHomographies()) {</span>
<span class="fc" id="L1489">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1492">        this.samplesQualityScores = samplesQualityScores;</span>
<span class="fc" id="L1493">    }</span>

    /**
     * Sets robust homography estimation method.
     * If method changes, then a new homography robust estimator is created and
     * configured.
     *
     * @param homographyMethod robust homography estimation method to be set.
     */
    private void internalSetHomographyMethod(final RobustEstimatorMethod homographyMethod) {
        // if method changes, homography estimator must be recreated
<span class="pc bpc" id="L1504" title="1 of 2 branches missed.">        if (homographyMethod != this.homographyMethod) {</span>
<span class="fc bfc" id="L1505" title="All 2 branches covered.">            final var previousAvailable = homographyEstimator != null;</span>
<span class="fc" id="L1506">            var threshold = 0.0;</span>
<span class="fc" id="L1507">            var confidence = 0.0;</span>
<span class="fc" id="L1508">            var maxIterations = 0;</span>
<span class="fc bfc" id="L1509" title="All 2 branches covered.">            if (previousAvailable) {</span>
<span class="fc" id="L1510">                threshold = getHomographyEstimatorThreshold();</span>
<span class="fc" id="L1511">                confidence = getHomographyEstimatorConfidence();</span>
<span class="fc" id="L1512">                maxIterations = getHomographyEstimatorMaxIterations();</span>
            }

<span class="fc" id="L1515">            homographyEstimator = PointCorrespondenceProjectiveTransformation2DRobustEstimator.create(homographyMethod);</span>

            // configure new estimator
<span class="fc" id="L1518">            refreshHomographyEstimatorListener();</span>
<span class="fc bfc" id="L1519" title="All 2 branches covered.">            if (previousAvailable) {</span>
                try {
<span class="fc" id="L1521">                    setHomographyEstimatorThreshold(threshold);</span>
<span class="fc" id="L1522">                    setHomographyEstimatorConfidence(confidence);</span>
<span class="fc" id="L1523">                    setHomographyEstimatorMaxIterations(maxIterations);</span>
<span class="nc" id="L1524">                } catch (final LockedException e) {</span>
<span class="nc" id="L1525">                    Logger.getLogger(CameraCalibrator.class.getName()).log(Level.WARNING,</span>
                            &quot;Could not reconfigure homography estimator&quot;, e);
<span class="fc" id="L1527">                }</span>
            }
        }
<span class="fc" id="L1530">        this.homographyMethod = homographyMethod;</span>
<span class="fc" id="L1531">    }</span>

    /**
     * Sets robust IAC estimation method.
     * IF method changes, then a new IAC robust estimator is created and
     * configured
     *
     * @param imageOfAbsoluteConicMethod robust IAC estimation method to be set
     */
    private void internalSetImageOfAbsoluteConicMethod(final RobustEstimatorMethod imageOfAbsoluteConicMethod) {
        // if method changes, iac estimator must be recreated
<span class="fc bfc" id="L1542" title="All 2 branches covered.">        if (imageOfAbsoluteConicMethod != this.imageOfAbsoluteConicMethod) {</span>
<span class="fc bfc" id="L1543" title="All 2 branches covered.">            final var previousAvailable = iacEstimator != null;</span>
<span class="fc" id="L1544">            var threshold = 0.0;</span>
<span class="fc" id="L1545">            var confidence = 0.0;</span>
<span class="fc" id="L1546">            var maxIterations = 0;</span>
<span class="fc" id="L1547">            var zeroSkewness = false;</span>
<span class="fc" id="L1548">            var principalPointAtOrigin = false;</span>
<span class="fc" id="L1549">            var focalDistanceAspectRatioKnown = false;</span>
<span class="fc" id="L1550">            var focalDistanceAspectRatio = 0.0;</span>
<span class="fc bfc" id="L1551" title="All 2 branches covered.">            if (previousAvailable) {</span>
<span class="fc" id="L1552">                threshold = getIACEstimatorThreshold();</span>
<span class="fc" id="L1553">                confidence = getIACEstimatorConfidence();</span>
<span class="fc" id="L1554">                maxIterations = getIACEstimatorMaxIterations();</span>
<span class="fc" id="L1555">                zeroSkewness = isZeroSkewness();</span>
<span class="fc" id="L1556">                principalPointAtOrigin = isPrincipalPointAtOrigin();</span>
<span class="fc" id="L1557">                focalDistanceAspectRatioKnown = isFocalDistanceAspectRatioKnown();</span>
<span class="fc" id="L1558">                focalDistanceAspectRatio = getFocalDistanceAspectRatio();</span>
            }

<span class="fc" id="L1561">            iacEstimator = ImageOfAbsoluteConicRobustEstimator.create(imageOfAbsoluteConicMethod);</span>

            // configure new estimator
<span class="fc" id="L1564">            refreshIACEstimatorListener();</span>
<span class="fc bfc" id="L1565" title="All 2 branches covered.">            if (previousAvailable) {</span>
                try {
<span class="fc" id="L1567">                    setIACEstimatorThreshold(threshold);</span>
<span class="fc" id="L1568">                    setIACEstimatorConfidence(confidence);</span>
<span class="fc" id="L1569">                    setIACEstimatorMaxIterations(maxIterations);</span>
<span class="fc" id="L1570">                    setZeroSkewness(zeroSkewness);</span>
<span class="fc" id="L1571">                    setPrincipalPointAtOrigin(principalPointAtOrigin);</span>
<span class="fc" id="L1572">                    setFocalDistanceAspectRatioKnown(focalDistanceAspectRatioKnown);</span>
<span class="fc" id="L1573">                    setFocalDistanceAspectRatio(focalDistanceAspectRatio);</span>
<span class="nc" id="L1574">                } catch (final LockedException e) {</span>
<span class="nc" id="L1575">                    Logger.getLogger(CameraCalibrator.class.getName()).log(Level.WARNING,</span>
                            &quot;Could not reconfigure IAC estimator&quot;, e);
<span class="fc" id="L1577">                }</span>
            }
        }
<span class="fc" id="L1580">        this.imageOfAbsoluteConicMethod = imageOfAbsoluteConicMethod;</span>
<span class="fc" id="L1581">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>