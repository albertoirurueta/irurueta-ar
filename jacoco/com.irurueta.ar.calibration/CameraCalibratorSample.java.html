<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CameraCalibratorSample.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.calibration</a> &gt; <span class="el_source">CameraCalibratorSample.java</span></div><h1>CameraCalibratorSample.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2015 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.calibration;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.ar.calibration.estimators.CameraPoseEstimator;
import com.irurueta.geometry.*;
import com.irurueta.geometry.estimators.LockedException;
import com.irurueta.geometry.estimators.NotReadyException;
import com.irurueta.geometry.estimators.PointCorrespondenceProjectiveTransformation2DRobustEstimator;
import com.irurueta.numerical.robust.RobustEstimatorException;
import com.irurueta.numerical.robust.RobustEstimatorMethod;

import java.util.List;

/**
 * Contains data obtained from a single picture using the camera.
 * Several samples can be used to calibrate the camera. The more samples are
 * used, typically the better the results.
 */
public class CameraCalibratorSample {
    /**
     * Minimum number of sampled markers that must be provided to estimate
     * an homography.
     */
    public static final int MIN_REQUIRED_SAMPLED_MARKERS = 4;

    /**
     * Pattern used for camera calibration. Each pattern contains a unique
     * combination of 2D points that must be sampled using the camera to be
     * calibrated.
     */
    private Pattern2D pattern;

    /**
     * Contains the sampled markers taken from a single picture using the
     * camera.
     */
    private List&lt;Point2D&gt; sampledMarkers;

    /**
     * Contains the sampled markers of the pattern but accounting for the
     * distortion effect introduced by the camera lens.
     */
    private List&lt;Point2D&gt; undistortedMarkers;

    /**
     * Quality scores of sampled markers. These can be used during
     * homography estimation if a robust estimation method such as PROSAC or
     * PROMedS is used.
     */
    private double[] sampledMarkersQualityScores;

    /**
     * 2D homography estimated from the sampled pattern points respect to
     * the ideal ones using a single picture.
     */
    private Transformation2D homography;

    /**
     * Estimated camera rotation. This contains the amount of rotation
     * respect to the plane formed by the pattern markers. This is obtained
     * once the IAC of the camera is estimated.
     */
    private Rotation3D rotation;

    /**
     * Estimated camera center. This determines the amount of translation
     * of the camera respect to the plane formed by the pattern markers. This
     * is obtained once the IAC of the camera is estimated.
     */
    private Point3D cameraCenter;

    /**
     * Estimated camera. Estimated pinhole camera taking into account
     * estimated intrinsic parameters and amount of rotation and translation
     * respect to the plane formed by the pattern markers, but without
     * taking into account any radial distortion introduced by the lens.
     */
    private PinholeCamera camera;

    /**
     * Constructor.
     */
<span class="fc" id="L98">    public CameraCalibratorSample() {</span>
<span class="fc" id="L99">    }</span>

    /**
     * Constructor.
     *
     * @param sampledMarkers sampled markers of the pattern taken from a
     *                       single picture using the camera.
     * @throws IllegalArgumentException if provided number of sampled
     *                                  markers is smaller than the required minimum (4) to estimate an
     *                                  homography.
     */
<span class="fc" id="L110">    public CameraCalibratorSample(final List&lt;Point2D&gt; sampledMarkers) {</span>
<span class="fc" id="L111">        setSampledMarkers(sampledMarkers);</span>
<span class="fc" id="L112">    }</span>

    /**
     * Constructor.
     *
     * @param sampledMarkers              sampled markers of the pattern taken from a
     *                                    single picture using the camera.
     * @param sampledMarkersQualityScores quality scores associated to
     *                                    each provided point for each sampled marker. The higher the value
     *                                    the better the quality assigned to that point.
     * @throws IllegalArgumentException if size of sampled markers or
     *                                  quality scores is smaller than the required minimum (4) to estimate
     *                                  an homography, or if their sizes do not match.
     */
<span class="fc" id="L126">    public CameraCalibratorSample(final List&lt;Point2D&gt; sampledMarkers, final double[] sampledMarkersQualityScores) {</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">        if (sampledMarkers.size() != sampledMarkersQualityScores.length) {</span>
<span class="fc" id="L128">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L131">        setSampledMarkers(sampledMarkers);</span>
<span class="fc" id="L132">        setSampledMarkersQualityScores(sampledMarkersQualityScores);</span>
<span class="fc" id="L133">    }</span>

    /**
     * Constructor.
     *
     * @param pattern        2D pattern to use for calibration.
     * @param sampledMarkers sampled markers of the pattern taken from a
     *                       single picture using the camera.
     * @throws IllegalArgumentException if provided number of sampled
     *                                  markers is smaller than the required minimum (4) to estimate an
     *                                  homography.
     */
<span class="fc" id="L145">    public CameraCalibratorSample(final Pattern2D pattern, final List&lt;Point2D&gt; sampledMarkers) {</span>
<span class="fc" id="L146">        this.pattern = pattern;</span>
<span class="fc" id="L147">        setSampledMarkers(sampledMarkers);</span>
<span class="fc" id="L148">    }</span>

    /**
     * Constructor.
     *
     * @param pattern                     2D pattern to use for calibration.
     * @param sampledMarkers              sampled markers of the pattern taken from a
     *                                    single picture using the camera.
     * @param sampledMarkersQualityScores quality scores associated to
     *                                    each provided point for each sampled marker. The higher the value
     *                                    the better the quality assigned to that point.
     * @throws IllegalArgumentException if size of sampled markers or
     *                                  quality scores is smaller than the required minimum (4) to estimate
     *                                  an homography, or if their sizes do not match.
     */
    public CameraCalibratorSample(final Pattern2D pattern, final List&lt;Point2D&gt; sampledMarkers,
<span class="fc" id="L164">                                  final double[] sampledMarkersQualityScores) {</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (sampledMarkers.size() != sampledMarkersQualityScores.length) {</span>
<span class="fc" id="L166">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L169">        this.pattern = pattern;</span>
<span class="fc" id="L170">        setSampledMarkers(sampledMarkers);</span>
<span class="fc" id="L171">        setSampledMarkersQualityScores(sampledMarkersQualityScores);</span>
<span class="fc" id="L172">    }</span>

    /**
     * Returns pattern used for camera calibration. Each pattern contain a
     * unique combination of 2D points that must be sampled using the camera to
     * be calibrated.
     *
     * @return pattern used for camera calibration.
     */
    public Pattern2D getPattern() {
<span class="fc" id="L182">        return pattern;</span>
    }

    /**
     * Sets pattern used for camera calibration. Each pattern contains a unique
     * combination of 2D points that must be sampled using the camera to be
     * calibrated.
     *
     * @param pattern pattern used for camera calibration.
     */
    public void setPattern(final Pattern2D pattern) {
<span class="fc" id="L193">        this.pattern = pattern;</span>
<span class="fc" id="L194">    }</span>

    /**
     * Obtains sampled markers of the pattern taken from a single picture
     * using the camera.
     *
     * @return sampled markers of the pattern.
     */
    public List&lt;Point2D&gt; getSampledMarkers() {
<span class="fc" id="L203">        return sampledMarkers;</span>
    }

    /**
     * Sets sampled markers of the pattern taken from a single picture
     * using the camera.
     *
     * @param sampledMarkers sampled markers of the pattern.
     * @throws IllegalArgumentException if provided number of sampled
     *                                  markers is smaller than the required minimum (4) to estimate an
     *                                  homography.
     */
    public final void setSampledMarkers(final List&lt;Point2D&gt; sampledMarkers) {
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (sampledMarkers.size() &lt; MIN_REQUIRED_SAMPLED_MARKERS) {</span>
<span class="fc" id="L217">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L220">        this.sampledMarkers = sampledMarkers;</span>
<span class="fc" id="L221">    }</span>

    /**
     * Returns quality scores of sampled markers. The higher the quality
     * score value the better the quality assigned to the associated 2D
     * point of a sampled marker.
     * Quality scores are only used if a robust estimation method such as
     * PROSAC or PROMedS is used for homography estimation
     *
     * @return quality scores of sampled markers.
     */
    public double[] getSampledMarkersQualityScores() {
<span class="fc" id="L233">        return sampledMarkersQualityScores;</span>
    }

    /**
     * Sets quality scores of sampled markers. The higher the quality score
     * value the better the quality assigned to the associated 2D point of
     * a sampled marker.
     * Quality scores are only used if a robust estimation method such as
     * PROSAC or PROMedS is used for homography estimation.
     *
     * @param sampledMarkersQualityScores quality scores of sampled markers.
     * @throws IllegalArgumentException if provided number of quality scores
     *                                  is smaller than the required minimum (4) to estimate an homography.
     */
    public final void setSampledMarkersQualityScores(final double[] sampledMarkersQualityScores) {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (sampledMarkersQualityScores.length &lt; MIN_REQUIRED_SAMPLED_MARKERS) {</span>
<span class="fc" id="L249">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L252">        this.sampledMarkersQualityScores = sampledMarkersQualityScores;</span>
<span class="fc" id="L253">    }</span>

    /**
     * Computes quality scores of sampled markers by taking into account
     * distance to radial distortion center.
     * Typically, the farther a sample is to the radial distortion, the more
     * likely it is to be distorted, and hence, the less reliable will be.
     *
     * @param sampledMarkers         sampled markers of the pattern.
     * @param radialDistortionCenter location where radial distortion center
     *                               is assumed to be. If null, it is assumed that center is at origin
     *                               of coordinates (i.e. center of image if principal point is also at
     *                               center of image).
     * @return quality scores of sampled markers.
     */
    public static double[] computeSampledMarkersQualityScores(
            final List&lt;Point2D&gt; sampledMarkers, final Point2D radialDistortionCenter) {

<span class="fc bfc" id="L271" title="All 2 branches covered.">        final Point2D center = radialDistortionCenter != null</span>
<span class="fc" id="L272">                ? radialDistortionCenter : new InhomogeneousPoint2D(0.0, 0.0);</span>

<span class="fc" id="L274">        final var qualityScores = new double[sampledMarkers.size()];</span>

<span class="fc" id="L276">        var counter = 0;</span>
        double distance;
        double qualityScore;
<span class="fc bfc" id="L279" title="All 2 branches covered.">        for (final var sampledMarker : sampledMarkers) {</span>
<span class="fc" id="L280">            distance = sampledMarker.distanceTo(center);</span>
<span class="fc" id="L281">            qualityScore = 1.0 / (1.0 + distance);</span>

<span class="fc" id="L283">            qualityScores[counter] = qualityScore;</span>
<span class="fc" id="L284">            counter++;</span>
<span class="fc" id="L285">        }</span>

<span class="fc" id="L287">        return qualityScores;</span>
    }

    /**
     * Computes quality scores of sampled markers by taking into account
     * distance to radial distortion center, which is assumed to be at
     * origin of coordinates (i.e. center of image if principal point is
     * also at center of image).
     *
     * @param sampledMarkers sampled markers of the pattern.
     * @return quality scores of sampled markers.
     */
    public static double[] computeSampledMarkersQualityScores(final List&lt;Point2D&gt; sampledMarkers) {
<span class="fc" id="L300">        return computeSampledMarkersQualityScores(sampledMarkers, null);</span>
    }

    /**
     * Contains the sampled markers of the pattern but accounting for the
     * distortion effect introduced by the camera lens, so that coordinates
     * are undistorted and follow a pure pinhole camera model.
     * Coordinates of undistorted markers might change during camera
     * calibration while the radial distortion parameters are refined.
     *
     * @return sampled markers of the pattern accounting for lens radial
     * distortion.
     */
    protected List&lt;Point2D&gt; getUndistortedMarkers() {
<span class="fc" id="L314">        return undistortedMarkers;</span>
    }

    /**
     * Sets sampled markers of the pattern but accounting for the distortion
     * effect introduced by the camera lens, so that coordinates are
     * undistorted and follow a pure pinhole camera model.
     * This method is for internal purposes only, and it is called while
     * the camera radial distortion parameters are being computed.
     *
     * @param undistortedMarkers sampled markers of the pattern accounting
     *                           for lens radial distortion.
     */
    protected void setUndistortedMarkers(final List&lt;Point2D&gt; undistortedMarkers) {
<span class="fc" id="L328">        this.undistortedMarkers = undistortedMarkers;</span>
<span class="fc" id="L329">    }</span>

    /**
     * Returns 2D homography estimated from the sampled pattern points
     * respect to the ideal ones using a single picture.
     *
     * @return homography of the sampled pattern points respect to the ideal
     * ones.
     */
    public Transformation2D getHomography() {
<span class="fc" id="L339">        return homography;</span>
    }

    /**
     * Sets 2D homography estimated from the sampled pattern points
     * respect to the ideal ones using a single picture.
     * This method is for internal purposes only, and it is called while
     * the IAC is being estimated.
     *
     * @param homography homography to be set.
     */
    protected void setHomography(final Transformation2D homography) {
<span class="fc" id="L351">        this.homography = homography;</span>
<span class="fc" id="L352">    }</span>

    /**
     * Returns estimated camera rotation for this sample. This contains
     * the amount of rotation respect to the plane formed by the pattern
     * markers for the picture associated to this sample. This is obtained
     * once the IAC of the camera is estimated.
     *
     * @return estimated camera rotation for this sample.
     */
    public Rotation3D getRotation() {
<span class="fc" id="L363">        return rotation;</span>
    }

    /**
     * Sets estimated camera rotation for this sample. This contains
     * the amount of rotation respect to the plane formed by the pattern
     * markers for the picture associated to this sample. This is obtained
     * once the IAC of the camera is estimated.
     * This method is for internal purposes only and might only be called
     * if camera rotation is required during radial distortion estimation,
     * or if rotation is requested for some other purpose.
     *
     * @param rotation camera rotation for this sample.
     */
    protected void setRotation(final Rotation3D rotation) {
<span class="fc" id="L378">        this.rotation = rotation;</span>
<span class="fc" id="L379">    }</span>

    /**
     * Returns estimated camera center. This determines the amount of
     * translation of the camera respect to the plane formed by the pattern
     * markers. This is obtained once the IAC of the camera is estimated.
     *
     * @return estimated camera center.
     */
    public Point3D getCameraCenter() {
<span class="fc" id="L389">        return cameraCenter;</span>
    }

    /**
     * Sets estimated camera center. This determines the amount of translation
     * of the camera respect to the plane formed by the pattern markers. This is
     * obtained once the IAC of the camera is estimated.
     *
     * @param cameraCenter estimated camera center.
     */
    protected void setCameraCenter(final Point3D cameraCenter) {
<span class="fc" id="L400">        this.cameraCenter = cameraCenter;</span>
<span class="fc" id="L401">    }</span>

    /**
     * Returns estimated camera. Estimated pinhole camera taking into
     * account estimated intrinsic parameters and amount of rotation and
     * translation respect to the plane formed by the pattern markers, but
     * without taking into account any radial distortion introduced by the
     * lens.
     *
     * @return estimated camera.
     */
    public PinholeCamera getCamera() {
<span class="fc" id="L413">        return camera;</span>
    }

    /**
     * Sets estimated camera taking into account estimated intrinsic
     * parameters, amount of rotation and translation respect to the plane
     * formed by the pattern markers, but without taking into account any
     * radial distortion introduced by the lens.
     * This method is for internal purposes only and might only be called if
     * camera is required during radial distortion estimation, or if camera
     * is requested for some other purpose.
     *
     * @param camera estimated camera.
     */
    protected void setCamera(final PinholeCamera camera) {
<span class="fc" id="L428">        this.camera = camera;</span>
<span class="fc" id="L429">    }</span>

    /**
     * Estimates homography of sampled points respect to the ideal pattern
     * points. Undistorted sampled taking into account radial distortion
     * will be taken into account whenever possible.
     *
     * @param estimator           a robust estimator for the homography. It will only
     *                            be used if more than 4 markers are provided.
     * @param idealPatternMarkers ideal marker coordinates of the pattern.
     *                            This contains measures expressed in meters so that camera can be
     *                            calibrated against real measures.
     * @return an homography.
     * @throws LockedException           if robust estimator is locked because
     *                                   computations are already in progress.
     * @throws NotReadyException         if provided data to compute homography is
     *                                   not enough, or it is invalid.
     * @throws RobustEstimatorException  if robust estimation of homography
     *                                   failed. This typically happens when not enough inliers are found or
     *                                   configuration of points to estimate homography is degenerate.
     * @throws CoincidentPointsException if configuration of points to
     *                                   estimate homography is degenerate.
     */
    protected Transformation2D estimateHomography(
            final PointCorrespondenceProjectiveTransformation2DRobustEstimator estimator,
            final List&lt;Point2D&gt; idealPatternMarkers) throws LockedException, NotReadyException,
            RobustEstimatorException, CoincidentPointsException {

<span class="fc bfc" id="L457" title="All 2 branches covered.">        final var markers = undistortedMarkers != null ? undistortedMarkers : sampledMarkers;</span>

<span class="pc bpc" id="L459" title="1 of 2 branches missed.">        if (markers.size() &lt; MIN_REQUIRED_SAMPLED_MARKERS) {</span>
<span class="nc" id="L460">            throw new NotReadyException();</span>
        }
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">        if (markers.size() != idealPatternMarkers.size()) {</span>
<span class="nc" id="L463">            throw new NotReadyException();</span>
        }

<span class="fc bfc" id="L466" title="All 2 branches covered.">        if (markers.size() == MIN_REQUIRED_SAMPLED_MARKERS) {</span>
            // use non-robust projective transformation estimation since it
            // is faster and will produce the same result as a robust
            // estimator
<span class="fc" id="L470">            return new ProjectiveTransformation2D(idealPatternMarkers.get(0), idealPatternMarkers.get(1),</span>
<span class="fc" id="L471">                    idealPatternMarkers.get(2), idealPatternMarkers.get(3), markers.get(0), markers.get(1),</span>
<span class="fc" id="L472">                    markers.get(2), markers.get(3));</span>
        } else {
            // use robust projective transformation estimation
<span class="fc" id="L475">            estimator.setPoints(idealPatternMarkers, markers);</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">            if (estimator.getMethod() == RobustEstimatorMethod.PROSAC</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">                    || estimator.getMethod() == RobustEstimatorMethod.PROMEDS) {</span>
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">                if (sampledMarkersQualityScores == null) {</span>
                    // attempt to estimate quality scores based on distance of
                    // samples to origin of coordinates (i.e. image center)
<span class="nc" id="L481">                    sampledMarkersQualityScores = computeSampledMarkersQualityScores(markers);</span>
                }
<span class="fc" id="L483">                estimator.setQualityScores(sampledMarkersQualityScores);</span>
            }

<span class="fc" id="L486">            return estimator.estimate();</span>
        }
    }

    /**
     * Computes camera pose using estimated homography and provided intrinsic
     * pinhole camera parameters that have been estimated so far.
     *
     * @param intrinsic intrinsic pinhole camera parameters.
     * @throws CalibrationException if something fails.
     */
    protected void computeCameraPose(final PinholeCameraIntrinsicParameters intrinsic) throws CalibrationException {
        try {
            // reset previous values
<span class="fc" id="L500">            rotation = null;</span>
<span class="fc" id="L501">            cameraCenter = null;</span>
<span class="fc" id="L502">            camera = null;</span>

<span class="fc" id="L504">            final var estimator = new CameraPoseEstimator();</span>
<span class="fc" id="L505">            estimator.estimate(intrinsic, homography);</span>

<span class="fc" id="L507">            rotation = estimator.getRotation();</span>
<span class="fc" id="L508">            cameraCenter = estimator.getCameraCenter();</span>
<span class="fc" id="L509">            camera = estimator.getCamera();</span>

<span class="nc" id="L511">        } catch (final AlgebraException | GeometryException e) {</span>
<span class="nc" id="L512">            throw new CalibrationException(e);</span>
<span class="fc" id="L513">        }</span>
<span class="fc" id="L514">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>