<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RadialDistortion.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.calibration</a> &gt; <span class="el_source">RadialDistortion.java</span></div><h1>RadialDistortion.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2015 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.calibration;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.Utils;
import com.irurueta.ar.calibration.estimators.LMSERadialDistortionEstimator;
import com.irurueta.ar.calibration.estimators.RadialDistortionEstimatorException;
import com.irurueta.geometry.GeometryException;
import com.irurueta.geometry.InhomogeneousPoint2D;
import com.irurueta.geometry.PinholeCameraIntrinsicParameters;
import com.irurueta.geometry.Point2D;

import java.io.Serializable;
import java.util.ArrayList;

/**
 * Class implementing Brown's radial distortion.
 * This kind of distortion is usually modelled after the distortion introduced
 * by lenses on cameras when taking short range pictures using wide angle
 * lenses.
 * Brown's radial distortion typically follow an expression such as:
 * xd = xu + (xu - xc)*(K1*r^2 + K2*r^4 + ...)
 * yd = yu + (yu - yc)*(K1*r^2 + K2*r^4 + ...),
 * where (xu, yu) stands for the undistorted point coordinates,
 * (xd, yd) stands for the distorted point coordinates,
 * (xc, yc) stands for the distortion center,
 * r^2 is typically (xu - xc)^2 + (yu - yc)^2 stands for the squared distance
 * of the distorted point respect to the distortion center. r^2 is computed
 * taking into account provided intrinsic parameters
 * And K1, K2 are the distortion parameters. Usually K1 dominates and K2 is
 * much smaller. Further terms are usually neglected as they are not meaningful
 * and typically produce numerical instabilities, but can also be provided in
 * array form.
 * &lt;p&gt;
 * NOTE: in order to be able to converge to correct values when computing
 * distortions, RadialDistortion should work with normalized point coordinates
 * between -1.0 and 1.0.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class RadialDistortion extends Distortion implements Serializable {

    /**
     * Defines default focal length if none is defined.
     */
    public static final double DEFAULT_FOCAL_LENGTH = 1.0;

    /**
     * Defines default skewness if none is defined.
     */
    public static final double DEFAULT_SKEW = 0.0;

    /**
     * Default maximum number of iterations to do when attempting to un-distort
     * a point if convergence is not reached.
     */
    public static final int DEFAULT_MAX_ITERS = 20;

    /**
     * Default tolerance to consider point convergence when un-distorting a point.
     */
    public static final double DEFAULT_TOLERANCE = 1e-5;

    /**
     * Radial distortion center.
     */
    private Point2D center;

    /**
     * Radial distortion parameters.
     */
    private double[] kParams;

    /**
     * Horizontal focal length expressed in pixels.
     */
    private double horizontalFocalLength;

    /**
     * Vertical focal length expressed in pixels.
     */
    private double verticalFocalLength;

    /**
     * Skew in pixels.
     */
    private double skew;

    /**
     * Inverse of intrinsic parameters' matrix.
     */
    private Matrix kInv;

    /**
     * Constructor.
     */
<span class="fc" id="L111">    public RadialDistortion() {</span>
        try {
<span class="fc" id="L113">            setIntrinsic(null, DEFAULT_FOCAL_LENGTH, DEFAULT_FOCAL_LENGTH, DEFAULT_SKEW);</span>
<span class="nc" id="L114">        } catch (final RadialDistortionException ignore) {</span>
            // never happens
<span class="fc" id="L116">        }</span>
<span class="fc" id="L117">    }</span>

    /**
     * Constructor with radial distortion parameters and center assumed to be
     * at the origin of coordinates (0, 0).
     *
     * @param k1 first degree distortion parameter.
     * @param k2 second degree distortion parameter.
     */
<span class="fc" id="L126">    public RadialDistortion(final double k1, final double k2) {</span>
<span class="fc" id="L127">        kParams = new double[]{k1, k2};</span>
        try {
<span class="fc" id="L129">            setIntrinsic(null, DEFAULT_FOCAL_LENGTH, DEFAULT_FOCAL_LENGTH, DEFAULT_SKEW);</span>
<span class="nc" id="L130">        } catch (final RadialDistortionException ignore) {</span>
            // never happens
<span class="fc" id="L132">        }</span>
<span class="fc" id="L133">    }</span>

    /**
     * Constructor with radial distortion parameters and center assumed to be
     * at the origin of coordinates (0, 0).
     *
     * @param kParams radial distortion parameters of any length.
     * @throws IllegalArgumentException if radial distortion parameters is null.
     */
<span class="fc" id="L142">    public RadialDistortion(final double[] kParams) {</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (kParams == null) {</span>
<span class="fc" id="L144">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L146">        this.kParams = kParams;</span>
        try {
<span class="fc" id="L148">            setIntrinsic(null, DEFAULT_FOCAL_LENGTH, DEFAULT_FOCAL_LENGTH, DEFAULT_SKEW);</span>
<span class="nc" id="L149">        } catch (final RadialDistortionException ignore) {</span>
            // never happens
<span class="fc" id="L151">        }</span>
<span class="fc" id="L152">    }</span>

    /**
     * Constructor with radial distortion parameters and center.
     *
     * @param k1     first degree distortion parameter.
     * @param k2     second degree distortion parameter.
     * @param center center of radial distortion. If null it is assumed to be
     *               at the origin of coordinates (0, 0), which is the typical value.
     */
    public RadialDistortion(final double k1, final double k2, final Point2D center) {
<span class="fc" id="L163">        this(k1, k2);</span>
        try {
<span class="fc" id="L165">            setIntrinsic(center, DEFAULT_FOCAL_LENGTH, DEFAULT_FOCAL_LENGTH, DEFAULT_SKEW);</span>
<span class="nc" id="L166">        } catch (final RadialDistortionException ignore) {</span>
            // never happens
<span class="fc" id="L168">        }</span>
<span class="fc" id="L169">    }</span>

    /**
     * Constructor with radial distortion parameters and center.
     *
     * @param kParams radial distortion parameters of any length.
     * @param center  center of radial distortion. If null it is assumed to be
     *                at the origin of coordinates (0, 0), which is the typical value.
     * @throws IllegalArgumentException if radial distortion parameters is null.
     */
    public RadialDistortion(final double[] kParams, final Point2D center) {
<span class="fc" id="L180">        this(kParams);</span>
        try {
<span class="fc" id="L182">            setIntrinsic(center, DEFAULT_FOCAL_LENGTH, DEFAULT_FOCAL_LENGTH, DEFAULT_SKEW);</span>
<span class="nc" id="L183">        } catch (final RadialDistortionException ignore) {</span>
            // never happens
<span class="fc" id="L185">        }</span>
<span class="fc" id="L186">    }</span>

    /**
     * Constructor with radial distortion parameters, center and other
     * camera intrinsic parameters.
     *
     * @param k1                    first degree distortion parameter.
     * @param k2                    second degree distortion parameter.
     * @param center                center of radial distortion. If null it is assumed to be at
     *                              the origin of coordinates (0, 0), which is the typical value.
     * @param horizontalFocalLength horizontal focal length expressed in pixels.
     * @param verticalFocalLength   vertical focal length expressed in pixels.
     * @param skew                  skew expressed in pixels.
     * @throws RadialDistortionException if provided focal lengths are
     *                                   degenerate (i.e. zero).
     */
    public RadialDistortion(
            final double k1, final double k2, final Point2D center, final double horizontalFocalLength,
            final double verticalFocalLength, final double skew) throws RadialDistortionException {
<span class="fc" id="L205">        this(k1, k2);</span>
<span class="fc" id="L206">        setIntrinsic(center, horizontalFocalLength, verticalFocalLength, skew);</span>
<span class="fc" id="L207">    }</span>

    /**
     * Constructor with radial distortion parameters, center and other camera
     * intrinsic parameters.
     *
     * @param kParams               radial distortion parameters of any length.
     * @param center                center of radial distortion. If null it is assumed to be at
     *                              the origin of coordinates (0, 0), which is the typical value.
     * @param horizontalFocalLength horizontal focal length expressed in pixels.
     * @param verticalFocalLength   vertical focal length expressed in pixels.
     * @param skew                  skew expressed in pixels.
     * @throws RadialDistortionException if provided focal lengths are
     *                                   degenerate (i.e. zero).
     * @throws IllegalArgumentException  if radial distortion parameters is null.
     */
    public RadialDistortion(final double[] kParams, final Point2D center, final double horizontalFocalLength,
                            final double verticalFocalLength, final double skew) throws RadialDistortionException {
<span class="fc" id="L225">        this(kParams);</span>
<span class="fc" id="L226">        setIntrinsic(center, horizontalFocalLength, verticalFocalLength, skew);</span>
<span class="fc" id="L227">    }</span>

    /**
     * Constructor with points and distortion center.
     *
     * @param distortedPoint1   1st distorted point (i.e. measured).
     * @param distortedPoint2   2nd distorted point (i.e. measured).
     * @param undistortedPoint1 1st undistorted point (i.e. ideal).
     * @param undistortedPoint2 2nd undistorted point (i.e. undistorted).
     * @param distortionCenter  distortion center or null if center is at origin
     *                          of coordinates (which is the typical value).
     * @throws RadialDistortionException if distortion could not be estimated.
     */
    public RadialDistortion(final Point2D distortedPoint1, final Point2D distortedPoint2,
                            final Point2D undistortedPoint1, final Point2D undistortedPoint2,
                            final Point2D distortionCenter) throws RadialDistortionException {
<span class="fc" id="L243">        super();</span>

<span class="fc" id="L245">        setFromPointsAndCenter(distortedPoint1, distortedPoint2, undistortedPoint1, undistortedPoint2,</span>
                distortionCenter);
<span class="fc" id="L247">    }</span>

    /**
     * Estimates this radial distortion from points and distortion center.
     *
     * @param distortedPoint1   1st distorted point (i.e. measured).
     * @param distortedPoint2   2nd distorted point (i.e. measured).
     * @param undistortedPoint1 1st undistorted point (i.e. ideal).
     * @param undistortedPoint2 2nd undistorted point (i.e. undistorted).
     * @param distortionCenter  distortion center or null if center is at origin
     *                          of coordinates (which is the typical value).
     * @throws RadialDistortionException if distortion could not be estimated.
     */
    public final void setFromPointsAndCenter(
            final Point2D distortedPoint1, final Point2D distortedPoint2,
            final Point2D undistortedPoint1, final Point2D undistortedPoint2, final Point2D distortionCenter)
            throws RadialDistortionException {

<span class="fc" id="L265">        final var distortedPoints = new ArrayList&lt;Point2D&gt;();</span>
<span class="fc" id="L266">        final var undistortedPoints = new ArrayList&lt;Point2D&gt;();</span>

<span class="fc" id="L268">        distortedPoints.add(distortedPoint1);</span>
<span class="fc" id="L269">        distortedPoints.add(distortedPoint2);</span>

<span class="fc" id="L271">        undistortedPoints.add(undistortedPoint1);</span>
<span class="fc" id="L272">        undistortedPoints.add(undistortedPoint2);</span>

        try {
<span class="fc" id="L275">            final var estimator = new LMSERadialDistortionEstimator(distortedPoints, undistortedPoints,</span>
                    distortionCenter);
<span class="fc" id="L277">            estimator.setLMSESolutionAllowed(false);</span>
<span class="fc" id="L278">            final var distortion = estimator.estimate();</span>

<span class="fc" id="L280">            kParams = distortion.kParams;</span>
<span class="fc" id="L281">            center = distortion.center;</span>
<span class="nc" id="L282">        } catch (final GeometryException | RadialDistortionEstimatorException e) {</span>
<span class="nc" id="L283">            throw new RadialDistortionException(e);</span>
<span class="fc" id="L284">        }</span>
<span class="fc" id="L285">    }</span>

    /**
     * Returns radial distortion center.
     *
     * @return radial distortion center.
     */
    public Point2D getCenter() {
<span class="fc" id="L293">        return center;</span>
    }

    /**
     * Sets radial distortion center.
     *
     * @param center radial distortion center to be set.
     */
    public void setCenter(final Point2D center) {
        try {
<span class="fc" id="L303">            setIntrinsic(center, horizontalFocalLength, verticalFocalLength, skew);</span>
<span class="nc" id="L304">        } catch (final RadialDistortionException ignore) {</span>
            // never happens
<span class="fc" id="L306">        }</span>
<span class="fc" id="L307">    }</span>

    /**
     * Returns horizontal focal length expressed in pixels.
     *
     * @return horizontal focal length expressed in pixels.
     */
    public double getHorizontalFocalLength() {
<span class="fc" id="L315">        return horizontalFocalLength;</span>
    }

    /**
     * Sets horizontal focal length expressed in pixels.
     *
     * @param horizontalFocalLength horizontal focal length expressed in pixels.
     * @throws RadialDistortionException if provided value is degenerate (i.e.
     *                                   zero).
     */
    public void setHorizontalFocalLength(final double horizontalFocalLength) throws RadialDistortionException {
<span class="fc" id="L326">        setIntrinsic(center, horizontalFocalLength, verticalFocalLength, skew);</span>
<span class="fc" id="L327">    }</span>

    /**
     * Returns vertical focal length expressed in pixels.
     *
     * @return vertical focal length expressed in pixels.
     */
    public double getVerticalFocalLength() {
<span class="fc" id="L335">        return verticalFocalLength;</span>
    }

    /**
     * Sets vertical focal length expressed in pixels.
     *
     * @param verticalFocalLength vertical focal length expressed in pixels.
     * @throws RadialDistortionException if provided value is degenerate (i.e.
     *                                   zero).
     */
    public void setVerticalFocalLength(final double verticalFocalLength) throws RadialDistortionException {
<span class="fc" id="L346">        setIntrinsic(center, horizontalFocalLength, verticalFocalLength, skew);</span>
<span class="fc" id="L347">    }</span>

    /**
     * Returns skew expressed in pixels.
     *
     * @return skew expressed in pixels.
     */
    public double getSkew() {
<span class="fc" id="L355">        return skew;</span>
    }

    /**
     * Sets skew expressed in pixels.
     *
     * @param skew skew expressed in pixels.
     */
    public void setSkew(final double skew) {
        try {
<span class="fc" id="L365">            setIntrinsic(center, horizontalFocalLength, verticalFocalLength, skew);</span>
<span class="nc" id="L366">        } catch (final RadialDistortionException ignore) {</span>
            // never happens
<span class="fc" id="L368">        }</span>
<span class="fc" id="L369">    }</span>

    /**
     * Returns pinhole camera intrinsic parameters associated to this distortion.
     *
     * @return pinhole camera intrinsic parameters associated to this distortion.
     */
    public PinholeCameraIntrinsicParameters getIntrinsic() {
<span class="fc" id="L377">        return new PinholeCameraIntrinsicParameters(horizontalFocalLength,</span>
                verticalFocalLength,
<span class="fc bfc" id="L379" title="All 2 branches covered.">                center != null ? center.getInhomX() : 0.0,</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">                center != null ? center.getInhomY() : 0.0,</span>
                skew);
    }

    /**
     * Sets intrinsic parameters from pinhole camera.
     *
     * @param intrinsic intrinsic parameters to be set.
     * @throws RadialDistortionException if focal length is degenerate (i.e.
     *                                   zero).
     */
    public void setIntrinsic(final PinholeCameraIntrinsicParameters intrinsic) throws RadialDistortionException {
<span class="fc" id="L392">        setIntrinsic(new InhomogeneousPoint2D(</span>
<span class="fc" id="L393">                intrinsic.getHorizontalPrincipalPoint(), intrinsic.getVerticalPrincipalPoint()),</span>
<span class="fc" id="L394">                intrinsic.getHorizontalFocalLength(),</span>
<span class="fc" id="L395">                intrinsic.getVerticalFocalLength(),</span>
<span class="fc" id="L396">                intrinsic.getSkewness());</span>
<span class="fc" id="L397">    }</span>

    /**
     * Sets intrinsic parameters.
     *
     * @param center                radial distortion center.
     * @param horizontalFocalLength horizontal focal length expressed in pixels.
     * @param verticalFocalLength   vertical focal length expressed in pixels.
     * @param skew                  skew expressed in pixels.
     * @throws RadialDistortionException if focal length is degenerate (i.e.
     *                                   zero).
     */
    public final void setIntrinsic(
            final Point2D center, final double horizontalFocalLength, final double verticalFocalLength,
            final double skew) throws RadialDistortionException {
<span class="fc" id="L412">        this.center = center;</span>
<span class="fc" id="L413">        this.horizontalFocalLength = horizontalFocalLength;</span>
<span class="fc" id="L414">        this.verticalFocalLength = verticalFocalLength;</span>
<span class="fc" id="L415">        this.skew = skew;</span>

        try {
<span class="fc bfc" id="L418" title="All 2 branches covered.">            if (kInv == null) {</span>
<span class="fc" id="L419">                kInv = new Matrix(3, 3);</span>
            }

            // initially matrix is zero
<span class="fc" id="L423">            final var k = new Matrix(3, 3);</span>

<span class="fc" id="L425">            k.setElementAt(0, 0, horizontalFocalLength);</span>
<span class="fc" id="L426">            k.setElementAt(1, 1, verticalFocalLength);</span>
<span class="fc" id="L427">            k.setElementAt(0, 1, skew);</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">            if (this.center != null) {</span>
                // if center is not provided, values are zero
<span class="fc" id="L430">                k.setElementAt(0, 2, this.center.getInhomX());</span>
<span class="fc" id="L431">                k.setElementAt(1, 2, this.center.getInhomY());</span>
            }
<span class="fc" id="L433">            k.setElementAt(2, 2, 1.0);</span>

<span class="fc" id="L435">            Utils.inverse(k, kInv);</span>
<span class="fc" id="L436">        } catch (final AlgebraException e) {</span>
<span class="fc" id="L437">            throw new RadialDistortionException(e);</span>
<span class="fc" id="L438">        }</span>
<span class="fc" id="L439">    }</span>

    /**
     * Returns first degree distortion parameter or zero if not available.
     *
     * @return first degree distortion parameter or zero if not available.
     */
    public double getK1() {
<span class="pc bpc" id="L447" title="1 of 4 branches missed.">        return kParams != null &amp;&amp; kParams.length &gt; 0 ? kParams[0] : 0.0;</span>
    }

    /**
     * Sets first degree distortion parameter.
     *
     * @param k1 first degree distortion parameter.
     */
    public void setK1(final double k1) {
<span class="pc bpc" id="L456" title="3 of 4 branches missed.">        if (kParams == null || kParams.length &lt; 1) {</span>
<span class="fc" id="L457">            kParams = new double[]{k1};</span>
        }
<span class="fc" id="L459">    }</span>

    /**
     * Returns second degree distortion parameter or zero if not available.
     *
     * @return second degree distortion parameter or zero if not available.
     */
    public double getK2() {
<span class="pc bpc" id="L467" title="1 of 4 branches missed.">        return kParams != null &amp;&amp; kParams.length &gt; 1 ? kParams[1] : 0.0;</span>
    }

    /**
     * Sets second degree distortion parameter.
     *
     * @param k2 second degree distortion parameter to be set.
     */
    public void setK2(final double k2) {
<span class="pc bpc" id="L476" title="1 of 4 branches missed.">        if (kParams == null || kParams.length &lt; 2) {</span>
<span class="fc" id="L477">            final var kp = new double[2];</span>
<span class="fc" id="L478">            kp[0] = getK1();</span>
<span class="fc" id="L479">            this.kParams = kp;</span>
        }
<span class="fc" id="L481">        kParams[1] = k2;</span>
<span class="fc" id="L482">    }</span>

    /**
     * Returns all radial distortion parameters. Typically only first and second
     * degree radial distortion parameters are used.
     *
     * @return all radial distortion parameters.
     */
    public double[] getKParams() {
<span class="fc" id="L491">        return kParams;</span>
    }

    /**
     * Sets all radial distortion parameters. With this method more than 2
     * radial distortion parameters can be set if needed.
     *
     * @param kParams radial distortion parameters to be set.
     */
    public void setKParams(final double[] kParams) {
<span class="fc" id="L501">        this.kParams = kParams;</span>
<span class="fc" id="L502">    }</span>

    /**
     * Distorts provided 2D point and stores result into provided distorted
     * point.
     *
     * @param undistortedPoint undistorted point to be undistorted.
     * @param distortedPoint   distorted point where result is stored.
     */
    @Override
    public void distort(final Point2D undistortedPoint, final Point2D distortedPoint) {

<span class="fc" id="L514">        undistortedPoint.normalize();</span>

<span class="fc" id="L516">        final var uHomX = undistortedPoint.getHomX();</span>
<span class="fc" id="L517">        final var uHomY = undistortedPoint.getHomY();</span>
<span class="fc" id="L518">        final var uHomW = undistortedPoint.getHomW();</span>

        // multiply mKinv with homogeneous undistorted point coordinates
        // to normalize them respect to principal point and image size
<span class="fc" id="L522">        final var uNormHomX = kInv.getElementAt(0, 0) * uHomX</span>
<span class="fc" id="L523">                + kInv.getElementAt(0, 1) * uHomY</span>
<span class="fc" id="L524">                + kInv.getElementAt(0, 2) * uHomW;</span>
<span class="fc" id="L525">        final double uNormHomY = kInv.getElementAt(1, 0) * uHomX</span>
<span class="fc" id="L526">                + kInv.getElementAt(1, 1) * uHomY</span>
<span class="fc" id="L527">                + kInv.getElementAt(1, 2) * uHomW;</span>
<span class="fc" id="L528">        final double uNormHomW = kInv.getElementAt(2, 0) * uHomX</span>
<span class="fc" id="L529">                + kInv.getElementAt(2, 1) * uHomY</span>
<span class="fc" id="L530">                + kInv.getElementAt(2, 2) * uHomW;</span>

<span class="fc" id="L532">        final var uNormInhomX = uNormHomX / uNormHomW;</span>
<span class="fc" id="L533">        final var uNormInhomY = uNormHomY / uNormHomW;</span>

<span class="fc" id="L535">        final var r2 = uNormInhomX * uNormInhomX + uNormInhomY * uNormInhomY;</span>
<span class="fc" id="L536">        var r = r2;</span>

<span class="fc" id="L538">        var sum = 0.0;</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">        if (kParams != null) {</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">            for (final var kParam : kParams) {</span>
<span class="fc" id="L541">                sum += kParam * r;</span>
<span class="fc" id="L542">                r *= r2;</span>
            }
        }

<span class="fc" id="L546">        final var uInhomX = uHomX / uHomW;</span>
<span class="fc" id="L547">        final var uInhomY = uHomY / uHomW;</span>

<span class="fc" id="L549">        var centerX = 0.0;</span>
<span class="fc" id="L550">        var centerY = 0.0;</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">        if (center != null) {</span>
<span class="fc" id="L552">            centerX = center.getInhomX();</span>
<span class="fc" id="L553">            centerY = center.getInhomY();</span>
        }

<span class="fc" id="L556">        final var dInhomX = uInhomX + (uInhomX - centerX) * sum;</span>
<span class="fc" id="L557">        final var dInhomY = uInhomY + (uInhomY - centerY) * sum;</span>

<span class="fc" id="L559">        distortedPoint.setInhomogeneousCoordinates(dInhomX, dInhomY);</span>
<span class="fc" id="L560">    }</span>

    /**
     * Un-distorts provided 2D point and stores result into provided undistorted
     * point
     *
     * @param distortedPoint   distorted point to be undistorted
     * @param undistortedPoint undistorted point where result is stored
     */
    @Override
    public void undistort(final Point2D distortedPoint, final Point2D undistortedPoint) {
<span class="fc" id="L571">        undistort(distortedPoint, undistortedPoint, DEFAULT_MAX_ITERS, DEFAULT_TOLERANCE);</span>
<span class="fc" id="L572">    }</span>

    /**
     * Un-distorts provided 2D point and stores result into provided undistorted
     * point.
     *
     * @param distortedPoint   distorted point to be undistorted.
     * @param undistortedPoint undistorted point where result is stored.
     * @param maxIters         maximum number of iterations to un-distort a point in case
     *                         that convergence is not reached.
     * @param tolerance        tolerance to indicate that convergence has been reached.
     */
    public void undistort(final Point2D distortedPoint, final Point2D undistortedPoint, final int maxIters,
                          final double tolerance) {
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">        if (maxIters &lt;= 0) {</span>
<span class="nc" id="L587">            throw new IllegalArgumentException();</span>
        }
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">        if (tolerance &lt;= 0.0) {</span>
<span class="nc" id="L590">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L593">        distortedPoint.normalize();</span>

<span class="fc" id="L595">        final var dHomX = distortedPoint.getHomX();</span>
<span class="fc" id="L596">        final var dHomY = distortedPoint.getHomY();</span>
<span class="fc" id="L597">        final var dHomW = distortedPoint.getHomW();</span>

        // initial estimate of undistorted point
<span class="fc" id="L600">        undistortedPoint.setHomogeneousCoordinates(dHomX, dHomY, dHomW);</span>

<span class="fc" id="L602">        final var uHomX = undistortedPoint.getHomX();</span>
<span class="fc" id="L603">        final var uHomY = undistortedPoint.getHomY();</span>
<span class="fc" id="L604">        final var uHomW = undistortedPoint.getHomW();</span>

        // multiply mKinv with homogeneous undistorted point coordinates
<span class="fc" id="L607">        final var uHomXDenorm = kInv.getElementAt(0, 0) * uHomX</span>
<span class="fc" id="L608">                + kInv.getElementAt(0, 1) * uHomY</span>
<span class="fc" id="L609">                + kInv.getElementAt(0, 2) * uHomW;</span>
<span class="fc" id="L610">        final double uHomYDenorm = kInv.getElementAt(1, 0) * uHomX</span>
<span class="fc" id="L611">                + kInv.getElementAt(1, 1) * uHomY</span>
<span class="fc" id="L612">                + kInv.getElementAt(1, 2) * uHomW;</span>
<span class="fc" id="L613">        final double uHomWDenorm = kInv.getElementAt(2, 0) * uHomX</span>
<span class="fc" id="L614">                + kInv.getElementAt(2, 1) * uHomY</span>
<span class="fc" id="L615">                + kInv.getElementAt(2, 2) * uHomW;</span>

<span class="fc" id="L617">        final var origX = uHomXDenorm / uHomWDenorm;</span>
<span class="fc" id="L618">        final var origY = uHomYDenorm / uHomWDenorm;</span>
<span class="fc" id="L619">        var uInhomX = origX;</span>
<span class="fc" id="L620">        var uInhomY = origY;</span>

        // radial distortion magnitude
<span class="fc" id="L623">        var sum = 0.0;</span>
<span class="fc" id="L624">        var prevSum = 0.0;</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">        for (var iter = 0; iter &lt; maxIters; iter++) {</span>
            // estimate the radial distance
<span class="fc" id="L627">            final var r2 = uInhomX * uInhomX + uInhomY * uInhomY;</span>
<span class="fc" id="L628">            var r = r2;</span>

<span class="fc" id="L630">            sum = 0.0;</span>
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">            if (kParams != null) {</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">                for (final var kParam : kParams) {</span>
<span class="fc" id="L633">                    sum += kParam * r;</span>
<span class="fc" id="L634">                    r *= r2;</span>
                }
            }

<span class="fc" id="L638">            uInhomX = origX / (1.0 + sum);</span>
<span class="fc" id="L639">            uInhomY = origY / (1.0 + sum);</span>

<span class="fc bfc" id="L641" title="All 2 branches covered.">            if (Math.abs(prevSum - sum) &lt;= tolerance) {</span>
<span class="fc" id="L642">                break;</span>
            } else {
<span class="fc" id="L644">                prevSum = sum;</span>
            }
        }

<span class="fc" id="L648">        final var dInhomX = dHomX / dHomW;</span>
<span class="fc" id="L649">        final var dInhomY = dHomY / dHomW;</span>

<span class="fc" id="L651">        var centerX = 0.0;</span>
<span class="fc" id="L652">        var centerY = 0.0;</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">        if (center != null) {</span>
<span class="fc" id="L654">            centerX = center.getInhomX();</span>
<span class="fc" id="L655">            centerY = center.getInhomY();</span>
        }

<span class="fc" id="L658">        uInhomX = (dInhomX + centerX * sum) / (1.0 + sum);</span>
<span class="fc" id="L659">        uInhomY = (dInhomY + centerY * sum) / (1.0 + sum);</span>

<span class="fc" id="L661">        undistortedPoint.setInhomogeneousCoordinates(uInhomX, uInhomY);</span>
<span class="fc" id="L662">    }</span>

    /**
     * Indicates whether this instance can distort points.
     * This implementation always returns false, hence attempting to distort
     * a point will result in a NotSupportedException being raised.
     *
     * @return true if points can be distorted, false otherwise.
     */
    @Override
    public boolean canDistort() {
<span class="fc" id="L673">        return true;</span>
    }

    /**
     * Indicates whether this instance can un-distort points.
     * This implementation always returns true.
     *
     * @return true if points can be undistorted, false otherwise.
     */
    @Override
    public boolean canUndistort() {
<span class="fc" id="L684">        return true;</span>
    }


    /**
     * Returns kind of distortion.
     *
     * @return kind of distortion.
     */
    @Override
    public DistortionKind getKind() {
<span class="fc" id="L695">        return DistortionKind.BROWN_RADIAL_DISTORTION;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>