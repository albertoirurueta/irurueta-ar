<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DualAbsoluteQuadric.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.calibration</a> &gt; <span class="el_source">DualAbsoluteQuadric.java</span></div><h1>DualAbsoluteQuadric.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2016 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.calibration;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.SingularValueDecomposer;
import com.irurueta.algebra.Utils;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.geometry.DualQuadric;
import com.irurueta.geometry.NonSymmetricMatrixException;
import com.irurueta.geometry.Plane;
import com.irurueta.geometry.ProjectiveTransformation3D;
import com.irurueta.numerical.NumericalException;
import com.irurueta.numerical.roots.FirstDegreePolynomialRootsEstimator;
import com.irurueta.numerical.roots.SecondDegreePolynomialRootsEstimator;

import java.io.Serializable;

/**
 * The dual absolute quadric is the dual quadric tangent to the plane at
 * infinity.
 * The absolute quadric (which is its inverse) contains all planes located
 * at infinity (x,y,z,0), hence the absolute quadric fulfills
 * (x,y,z,0)'*Q*(x,y,z,0).
 * Consequently, the dual absolute quadric fulfills P*Q^-1*P, where P is the
 * plane at infinity (0,0,0,1) in the metric stratum.
 * This means that in the metric stratus the dual absolute quadric is equal
 * (up to scale) to:
 * [1  0   0   0]
 * Q =  [0  1   0   0]
 * [0  0   1   0]
 * [0  0   0   0]
 */
public class DualAbsoluteQuadric extends DualQuadric implements Serializable {

    /**
     * Constructor.
     * Initializes the Dual Absolute Quadric assuming metric stratum, where it
     * is equal to the identity except for the last element which is zero.
     */
    public DualAbsoluteQuadric() {
<span class="fc" id="L56">        super(1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);</span>
<span class="fc" id="L57">    }</span>

    /**
     * Constructor of this class. This constructor accepts every parameter
     * describing a dual quadric (parameters a, b, c, d, e, f, g, h, i, j).
     *
     * @param a Parameter A of the quadric.
     * @param b Parameter B of the quadric.
     * @param c Parameter C of the quadric.
     * @param d Parameter D of the quadric.
     * @param e Parameter E of the quadric.
     * @param f Parameter F of the quadric.
     * @param g Parameter G of the quadric.
     * @param h Parameter H of the quadric.
     * @param i Parameter I of the quadric.
     * @param j Parameter J of the quadric.
     */
    public DualAbsoluteQuadric(
            final double a, final double b, final double c, final double d, final double e,
            final double f, final double g, final double h, final double i, final double j) {
<span class="fc" id="L77">        super(a, b, c, d, e, f, g, h, i, j);</span>
<span class="fc" id="L78">    }</span>

    /**
     * Constructor from provided dual image of absolute conic and plane at
     * infinity on an arbitrary projective stratum.
     *
     * @param diac            dual image of absolute conic in an arbitrary projective
     *                        stratum.
     * @param planeAtInfinity plane at infinity in an arbitrary projective
     *                        stratum.
     */
    public DualAbsoluteQuadric(final DualImageOfAbsoluteConic diac, final Plane planeAtInfinity) {
<span class="fc" id="L90">        super();</span>
<span class="fc" id="L91">        setDualImageOfAbsoluteConicAndPlaneAtInfinity(diac, planeAtInfinity);</span>
<span class="fc" id="L92">    }</span>

    /**
     * Constructor using provided dual image of absolute conic on an arbitrary
     * affine stratum while keeping the plane at infinity typically used in
     * a metric stratum (0,0,0,1).
     *
     * @param diac dual image of absolute conic.
     */
    public DualAbsoluteQuadric(final DualImageOfAbsoluteConic diac) {
<span class="fc" id="L102">        super();</span>

<span class="fc" id="L104">        diac.normalize();</span>

<span class="fc" id="L106">        final var a = diac.getA();</span>
<span class="fc" id="L107">        final var b = diac.getC();</span>
<span class="fc" id="L108">        final var c = diac.getF();</span>
<span class="fc" id="L109">        final var d = diac.getB();</span>
<span class="fc" id="L110">        final var e = diac.getE();</span>
<span class="fc" id="L111">        final var f = diac.getD();</span>
<span class="fc" id="L112">        setParameters(a, b, c, d, e, f, 0.0, 0.0, 0.0, 0.0);</span>
<span class="fc" id="L113">    }</span>

    /**
     * Constructor using provided plane at infinity while using the unitary
     * dual image of absolute conic (the identity).
     *
     * @param planeAtInfinity plane at infinity.
     */
    public DualAbsoluteQuadric(final Plane planeAtInfinity) {
<span class="fc" id="L122">        super();</span>

<span class="fc" id="L124">        var planeA = planeAtInfinity.getA();</span>
<span class="fc" id="L125">        var planeB = planeAtInfinity.getB();</span>
<span class="fc" id="L126">        var planeC = planeAtInfinity.getC();</span>
<span class="fc" id="L127">        final var planeD = planeAtInfinity.getD();</span>

        // normalize plane components so that last one is the unit
<span class="fc" id="L130">        planeA /= planeD;</span>
<span class="fc" id="L131">        planeB /= planeD;</span>
<span class="fc" id="L132">        planeC /= planeD;</span>

<span class="fc" id="L134">        final var g = -planeA;</span>
<span class="fc" id="L135">        final var h = -planeB;</span>
<span class="fc" id="L136">        final var i = -planeC;</span>
<span class="fc" id="L137">        final var j = planeA * planeA + planeB * planeB + planeC * planeC;</span>

<span class="fc" id="L139">        setParameters(1.0, 1.0, 1.0, 0.0, 0.0, 0.0, g, h, i, j);</span>
<span class="fc" id="L140">    }</span>

    /**
     * Constructor of the Dual Absolute Quadric in an arbitrary projective
     * stratum using a transformation from metric stratum to such projective
     * space.
     *
     * @param metricToProjectiveTransformation transformation from metric to
     *                                         a projective space.
     * @throws InvalidTransformationException if provided transformation is
     *                                        numerically unstable.
     */
    public DualAbsoluteQuadric(final ProjectiveTransformation3D metricToProjectiveTransformation)
<span class="fc" id="L153">            throws InvalidTransformationException {</span>
<span class="fc" id="L154">        setMetricToProjectiveTransformation(metricToProjectiveTransformation);</span>
<span class="fc" id="L155">    }</span>

    /**
     * Sets this dual absolute quadric from provided metric to projective space
     * transformation.
     *
     * @param metricToProjectiveTransformation transformation from metric to a
     *                                         projective space.
     * @throws InvalidTransformationException if provided transformation is
     *                                        numerically unstable.
     */
    public final void setMetricToProjectiveTransformation(
            final ProjectiveTransformation3D metricToProjectiveTransformation) throws InvalidTransformationException {
<span class="fc" id="L168">        metricToProjectiveTransformation.normalize();</span>

        try {
            // transformation
<span class="fc" id="L172">            final var t = metricToProjectiveTransformation.asMatrix();</span>

            // identity except for the last element. This is the DAQ in metric
            // stratum
<span class="fc" id="L176">            final var i = Matrix.identity(BASEQUADRIC_MATRIX_ROW_SIZE, BASEQUADRIC_MATRIX_COLUMN_SIZE);</span>
<span class="fc" id="L177">            i.setElementAt(3, 3, 0.0);</span>

            // transformation transposed
<span class="fc" id="L180">            final var tt = t.transposeAndReturnNew();</span>

            // make product t * i * tt
<span class="fc" id="L183">            t.multiply(i);</span>
<span class="fc" id="L184">            t.multiply(tt);</span>

<span class="fc" id="L186">            setParameters(t);</span>
<span class="nc" id="L187">        } catch (final NonSymmetricMatrixException e) {</span>
<span class="nc" id="L188">            throw new InvalidTransformationException(e);</span>
<span class="nc" id="L189">        } catch (final WrongSizeException ignore) {</span>
            // never thrown
<span class="fc" id="L191">        }</span>
<span class="fc" id="L192">    }</span>

    /**
     * Obtains the metric to projective stratum transformation defining this
     * Dual Absolute Quadric.
     *
     * @return a new metric to projective space transformation.
     * @throws InvalidTransformationException if transformation cannot be
     *                                        determined because dual absolute quadric is numerically
     *                                        unstable.
     */
    public ProjectiveTransformation3D getMetricToProjectiveTransformation() throws InvalidTransformationException {
<span class="fc" id="L204">        final var result = new ProjectiveTransformation3D();</span>
<span class="fc" id="L205">        getMetricToProjectiveTransformation(result);</span>
<span class="fc" id="L206">        return result;</span>
    }

    /**
     * Obtains the metric to projective stratum transformation defining this
     * Dual Absolute Quadric.
     *
     * @param result instance where metric to projective space transformation
     *               will be stored.
     * @throws InvalidTransformationException if transformation cannot be
     *                                        determined because dual absolute quadric is numerically
     *                                        unstable.
     */
    public void getMetricToProjectiveTransformation(final ProjectiveTransformation3D result)
            throws InvalidTransformationException {
        // DAQ can be decomposed as DAQ = H * I * H^t, where
        // I =   [1  0   0   0]
        //       [0  1   0   0]
        //       [0  0   1   0]
        //       [0  0   0   0]
        // Hence I can be seen as the eigen values of DAQ's eigen decomposition
        // and H are the eigenvectors.
        // From this decomposition, it can be seen that:
        // - DAQ is singular (has rank 3)
        // - DAQ is symmetric positive definite (or negative depending on scale
        // sign, but all eigen values have the same sign).
        // We know that symmetric positive definite matrices have square roots
        // such as:
        // DAQ = M*M^t
        // Hence the SVD of the square root is equal to:
        // M = U*S*V^t
        // And consequently DAQ is:
        // DAQ = (U*S*V^t)*(U*S*V^t)^t = U*S*V^t*V*S*U^t = U*S*S*U^t
        // where S is diagonal and contains the singular values of M
        // and U are the singular vectors of M
        // Since S is diagonal, then S*S contains the squared singular values on
        // its diagonal and matrix S*S can be seen as the eigen values of DAQ,
        // while &quot;U&quot; are the eigen vectors of DAQ
        // Since we don't care about scale, we can normalize the eigen values of
        // DAQ, and transformation H is equal to matrix U (up to scale)

        try {
<span class="fc" id="L248">            final var daqMatrix = asMatrix();</span>
<span class="fc" id="L249">            final var decomposer = new SingularValueDecomposer(daqMatrix);</span>
<span class="fc" id="L250">            decomposer.decompose();</span>
            // since daq matrix will always be symmetric U = V
<span class="fc" id="L252">            final var u = decomposer.getU();</span>
            // we need to undo the effect of possible different singular values
            // because we want H * I * H^t, so that middle matrix is the identity
            // except for the last element which is zero.
            // For that reason we multiply each column of U by the square root
            // of each singular value
<span class="fc" id="L258">            final var w = decomposer.getSingularValues();</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">            for (var i = 0; i &lt; BASEQUADRIC_MATRIX_COLUMN_SIZE - 1; i++) {</span>
<span class="fc" id="L260">                final var scalar = Math.sqrt(w[i]);</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">                for (var j = 0; j &lt; BASEQUADRIC_MATRIX_ROW_SIZE; j++) {</span>
<span class="fc" id="L262">                    u.setElementAt(j, i, scalar * u.getElementAt(j, i));</span>
                }
            }
<span class="fc" id="L265">            result.setT(u);</span>
<span class="nc" id="L266">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L267">            throw new InvalidTransformationException(e);</span>
<span class="fc" id="L268">        }</span>
<span class="fc" id="L269">    }</span>

    /**
     * Sets this dual absolute quadric from provided dual image of absolute
     * conic and plane at infinity on an arbitrary projective stratum.
     *
     * @param diac            dual image of absolute conic to be set.
     * @param planeAtInfinity plane at infinity to be set.
     */
    public final void setDualImageOfAbsoluteConicAndPlaneAtInfinity(
            final DualImageOfAbsoluteConic diac, final Plane planeAtInfinity) {

<span class="fc" id="L281">        var planeA = planeAtInfinity.getA();</span>
<span class="fc" id="L282">        var planeB = planeAtInfinity.getB();</span>
<span class="fc" id="L283">        var planeC = planeAtInfinity.getC();</span>
<span class="fc" id="L284">        final var planeD = planeAtInfinity.getD();</span>

        // normalize plane components so that last one is the unit
<span class="fc" id="L287">        planeA /= planeD;</span>
<span class="fc" id="L288">        planeB /= planeD;</span>
<span class="fc" id="L289">        planeC /= planeD;</span>

<span class="fc" id="L291">        final var a = diac.getA();</span>
<span class="fc" id="L292">        final var b = diac.getC();</span>
<span class="fc" id="L293">        final var c = diac.getF();</span>
<span class="fc" id="L294">        final var d = diac.getB();</span>
<span class="fc" id="L295">        final var e = diac.getE();</span>
<span class="fc" id="L296">        final var f = diac.getD();</span>

<span class="fc" id="L298">        final var g = -(diac.getA() * planeA + diac.getB() * planeB + diac.getD() * planeC);</span>
<span class="fc" id="L299">        final var h = -(diac.getB() * planeA + diac.getC() * planeB + diac.getE() * planeC);</span>
<span class="fc" id="L300">        final var i = -(diac.getD() * planeA + diac.getE() * planeB + diac.getF() * planeC);</span>
<span class="fc" id="L301">        final var j = -(planeA * g + planeB * h + planeC * i);</span>

<span class="fc" id="L303">        setParameters(a, b, c, d, e, f, g, h, i, j);</span>
<span class="fc" id="L304">    }</span>

    /**
     * Gets dual image of absolute conic associated to this dual absolute
     * quadric in an arbitrary projective stratum.
     *
     * @return dual image of absolute conic associated to this dual absolute
     * quadric.
     */
    public DualImageOfAbsoluteConic getDualImageOfAbsoluteConic() {
<span class="fc" id="L314">        final var result = new DualImageOfAbsoluteConic();</span>
<span class="fc" id="L315">        getDualImageOfAbsoluteConic(result);</span>
<span class="fc" id="L316">        return result;</span>
    }

    /**
     * Gets dual image of absolute conic associated to this dual absolute
     * quadric in an arbitrary projective stratum and stores the result into
     * provided instance.
     *
     * @param result instance where dual image of absolute conic will be stored.
     */
    public void getDualImageOfAbsoluteConic(final DualImageOfAbsoluteConic result) {
<span class="fc" id="L327">        final var a = getA();</span>
<span class="fc" id="L328">        final var b = getD();</span>
<span class="fc" id="L329">        final var c = getB();</span>
<span class="fc" id="L330">        final var d = getF();</span>
<span class="fc" id="L331">        final var e = getE();</span>
<span class="fc" id="L332">        final var f = getC();</span>
<span class="fc" id="L333">        result.setParameters(a, b, c, d, e, f);</span>
<span class="fc" id="L334">    }</span>

    /**
     * Sets dual image of absolute conic while keeping current plane at infinity
     * in an arbitrary projective stratum.
     *
     * @param diac dual image of absolute conic to be set.
     * @throws InvalidPlaneAtInfinityException if plane at infinity to be
     *                                         preserved when setting DIAC cannot be determined.
     */
    public final void setDualImageOfAbsoluteConic(final DualImageOfAbsoluteConic diac)
            throws InvalidPlaneAtInfinityException {
<span class="fc" id="L346">        final var planeAtInfinity = getPlaneAtInfinity();</span>
<span class="fc" id="L347">        setDualImageOfAbsoluteConicAndPlaneAtInfinity(diac, planeAtInfinity);</span>
<span class="fc" id="L348">    }</span>

    /**
     * Gets plane at infinity associated to this dual absolute quadric in an
     * arbitrary projective stratum.
     *
     * @return plane at infinity associated to this dual absolute quadric.
     * @throws InvalidPlaneAtInfinityException if plane at infinity cannot be
     *                                         determined.
     */
    public Plane getPlaneAtInfinity() throws InvalidPlaneAtInfinityException {
<span class="fc" id="L359">        final var result = new Plane();</span>
<span class="fc" id="L360">        getPlaneAtInfinity(result);</span>
<span class="fc" id="L361">        return result;</span>
    }

    /**
     * Gets plane at infinity associated to this dual absolute quadric in an
     * arbitrary projective stratum.
     *
     * @param result instance where plane at infinity will be stored.
     * @throws InvalidPlaneAtInfinityException if plane at infinity cannot be
     *                                         determined.
     */
    public void getPlaneAtInfinity(final Plane result) throws InvalidPlaneAtInfinityException {
        try {
<span class="fc" id="L374">            final var diac = getDualImageOfAbsoluteConic();</span>
<span class="fc" id="L375">            final var m = diac.asMatrix();</span>
<span class="fc" id="L376">            Utils.inverse(m, m);</span>

<span class="fc" id="L378">            final var g = getG();</span>
<span class="fc" id="L379">            final var h = getH();</span>
<span class="fc" id="L380">            final var i = getI();</span>

<span class="fc" id="L382">            final var planeA = -m.getElementAt(0, 0) * g</span>
<span class="fc" id="L383">                    - m.getElementAt(0, 1) * h</span>
<span class="fc" id="L384">                    - m.getElementAt(0, 2) * i;</span>

<span class="fc" id="L386">            final var planeB = -m.getElementAt(1, 0) * g</span>
<span class="fc" id="L387">                    - m.getElementAt(1, 1) * h</span>
<span class="fc" id="L388">                    - m.getElementAt(1, 2) * i;</span>

<span class="fc" id="L390">            final var planeC = -m.getElementAt(2, 0) * g</span>
<span class="fc" id="L391">                    - m.getElementAt(2, 1) * h</span>
<span class="fc" id="L392">                    - m.getElementAt(2, 2) * i;</span>

            // plane at infinity must be tangent to dual absolute quadric, hence
            // P^T*Q^-1*P = 0
            // [planeA planeB planeC planeD]*[a  d   f   g][planeA]
            //                               [d  b   e   h][planeB] = 0
            //                               [f  e   c   i][planeC]
            //                               [g  h   i   j][planeD]

            // [planeA planeB planeC planeD]*[a*planeA + d*planeB + f*planeC + g*planeD]
            //                               [d*planeA + b*planeB + e*planeC + h*planeD] = 0
            //                               [f*planeA + e*planeB + c*planeC + i*planeD]
            //                               [g*planeA + h*planeB + i*planeC + j*planeD]

            // planeA*(a*planeA + d*planeB + f*planeC) +
            // planeB*(d*planeA + b*planeB + e*planeC) +
            // planeC*(f*planeA + e*planeB + c*planeC) +
            // 2*planeD*(g*planeA + h*planeB + i*planeC) + j*planeD*planeD = 0

            // hence we create the 2nd degree polynomial shown above and solve
            // planeD value
<span class="fc" id="L413">            final var a = getA();</span>
<span class="fc" id="L414">            final var b = getB();</span>
<span class="fc" id="L415">            final var c = getC();</span>
<span class="fc" id="L416">            final var d = getD();</span>
<span class="fc" id="L417">            final var e = getE();</span>
<span class="fc" id="L418">            final var f = getF();</span>
<span class="fc" id="L419">            final var j = getJ();</span>
<span class="fc" id="L420">            final var polyParams = new double[]{</span>
                    planeA * (a * planeA + d * planeB + f * planeC)
                            + planeB * (d * planeA + b * planeB + e * planeC)
                            + planeC * (f * planeA + e * planeB + c * planeC),
                    2.0 * (g * planeA + h * planeB + i * planeC),
                    j
            };

            double planeD;
<span class="fc bfc" id="L429" title="All 2 branches covered.">            if (SecondDegreePolynomialRootsEstimator.isSecondDegree(polyParams)) {</span>
                // second degree
<span class="fc" id="L431">                final var estimator = new SecondDegreePolynomialRootsEstimator(polyParams);</span>


<span class="fc" id="L434">                final var hasDoubleRoot = estimator.hasDoubleRoot();</span>

                // a double REAL root (same root happening twice) must be present
                // because only one plane at infinity should be defined
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">                if (!hasDoubleRoot) {</span>
<span class="nc" id="L439">                    throw new InvalidPlaneAtInfinityException(&quot;more than one possible solution&quot;);</span>
                }

<span class="fc" id="L442">                estimator.estimate();</span>

<span class="fc" id="L444">                final var roots = estimator.getRoots();</span>
<span class="fc" id="L445">                planeD = roots[0].getReal();</span>
<span class="fc" id="L446">            } else {</span>
                // polynomial is not second degree, attempt to solve as 1 degree
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">                if (FirstDegreePolynomialRootsEstimator.isFirstDegree(polyParams)) {</span>
                    // first degree
<span class="nc" id="L450">                    final var estimatorFirst = new FirstDegreePolynomialRootsEstimator(</span>
                            new double[]{polyParams[0], polyParams[1]});

<span class="nc" id="L453">                    estimatorFirst.estimate();</span>

<span class="nc" id="L455">                    final var roots = estimatorFirst.getRoots();</span>
<span class="nc" id="L456">                    planeD = roots[0].getReal();</span>
<span class="nc" id="L457">                } else {</span>
                    // degenerate polynomial (i.e. metric stratum)
<span class="fc" id="L459">                    planeD = 1.0;</span>
                }
            }
<span class="fc" id="L462">            result.setParameters(planeA, planeB, planeC, planeD);</span>

<span class="nc" id="L464">        } catch (final AlgebraException | NumericalException e) {</span>
<span class="nc" id="L465">            throw new InvalidPlaneAtInfinityException(e);</span>
<span class="fc" id="L466">        }</span>
<span class="fc" id="L467">    }</span>

    /**
     * Sets provided plane at infinity at an arbitrary projective stratum while
     * keeping current dual image of absolute conic.
     *
     * @param planeAtInfinity plane at infinity to be set.
     */
    public final void setPlaneAtInfinity(final Plane planeAtInfinity) {
<span class="fc" id="L476">        final var diac = getDualImageOfAbsoluteConic();</span>
<span class="fc" id="L477">        setDualImageOfAbsoluteConicAndPlaneAtInfinity(diac, planeAtInfinity);</span>
<span class="fc" id="L478">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>