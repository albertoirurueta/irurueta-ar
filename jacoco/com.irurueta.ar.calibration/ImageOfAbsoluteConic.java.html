<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ImageOfAbsoluteConic.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.calibration</a> &gt; <span class="el_source">ImageOfAbsoluteConic.java</span></div><h1>ImageOfAbsoluteConic.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2015 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.calibration;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.CholeskyDecomposer;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.Utils;
import com.irurueta.geometry.Conic;
import com.irurueta.geometry.DualConic;
import com.irurueta.geometry.DualConicNotAvailableException;
import com.irurueta.geometry.InvalidPinholeCameraIntrinsicParametersException;
import com.irurueta.geometry.NonSymmetricMatrixException;
import com.irurueta.geometry.PinholeCameraIntrinsicParameters;

import java.io.Serializable;

/**
 * The image of the absolute conic, is the projection of the absolute
 * quadric using a given pinhole camera.
 * Because the absolute quadric cannot be computed from the dual absolute
 * quadric because the latter is degenerate, then this instance assumes
 * that we always work on an ideal metric stratum.
 * In such cases, the image of the absolute conic (IAC), is directly related
 * to the inverse of pinhole camera intrinsic parameters.
 */
public class ImageOfAbsoluteConic extends Conic implements Serializable {

    /**
     * Constructor.
     * When working on a metric stratum, the IAC is related by the pinhole
     * camera intrinsic parameters as C=(K^-1)'*(K^-1).
     *
     * @param k pinhole camera intrinsic parameters.
     * @throws InvalidPinholeCameraIntrinsicParametersException if intrinsic
     *                                                          parameters cannot be inverted (i.e. this
     *                                                          might happen when values are incorrectly set
     *                                                          such as when focal length is zero, etc.).
     *                                                          Typically, this will never be thrown.
     */
    public ImageOfAbsoluteConic(final PinholeCameraIntrinsicParameters k)
            throws InvalidPinholeCameraIntrinsicParametersException {
<span class="fc" id="L56">        super();</span>
<span class="fc" id="L57">        setFromPinholeCameraIntrinsicParameters(k);</span>
<span class="fc" id="L58">    }</span>

    /**
     * Constructor of this class. This constructor accepts every parameter
     * describing a conic (parameters a, b, c, d, e, f).
     *
     * @param a Parameter A of the conic.
     * @param b Parameter B of the conic.
     * @param c Parameter C of the conic.
     * @param d Parameter D of the conic.
     * @param e Parameter E of the conic.
     * @param f Parameter F of the conic.
     */
    public ImageOfAbsoluteConic(
            final double a, final double b, final double c, final double d, final double e, final double f) {
<span class="fc" id="L73">        super(a, b, c, d, e, f);</span>
<span class="fc" id="L74">    }</span>

    /**
     * This method sets the matrix used to describe a conic.
     * This matrix must be 3x3 and symmetric.
     *
     * @param m 3x3 Matrix describing the conic.
     * @throws IllegalArgumentException    Raised when the size of the matrix is
     *                                     not 3x3.
     * @throws NonSymmetricMatrixException Raised when the conic matrix is not
     *                                     symmetric.
     */
    public ImageOfAbsoluteConic(final Matrix m) throws NonSymmetricMatrixException {
<span class="fc" id="L87">        super(m);</span>
<span class="fc" id="L88">    }</span>

    /**
     * Constructor without arguments.
     */
    protected ImageOfAbsoluteConic() {
<span class="fc" id="L94">        super();</span>
<span class="fc" id="L95">    }</span>

    /**
     * Computes the dual conic of this conic.
     * The dual conic is equal to the inverse of the conic matrix.
     *
     * @return A new DualConic corresponding to the dual conic of this instance.
     * @throws DualConicNotAvailableException Raised if the dual conic does not
     *                                        exist because this conic instance is degenerate (its inverse
     *                                        cannot be computed).
     */
    @Override
    public DualConic getDualConic() throws DualConicNotAvailableException {
<span class="fc" id="L108">        final var dualConic = new DualImageOfAbsoluteConic();</span>
<span class="fc" id="L109">        dualConic(dualConic);</span>
<span class="fc" id="L110">        return dualConic;</span>
    }

    /**
     * Sets IAC parameters from pinhole camera intrinsic parameters when we
     * are working in a metric stratum, which is equal to C=(K^-1)'*(K^-1).
     *
     * @param k pinhole camera intrinsic parameters.
     * @throws InvalidPinholeCameraIntrinsicParametersException if intrinsic parameters cannot be inverted
     *                                                          (i.e. this might happen when values are
     *                                                          incorrectly set such as when focal length
     *                                                          is zero, etc.). Typically, this will never
     *                                                          be thrown.
     */
    public final void setFromPinholeCameraIntrinsicParameters(
            final PinholeCameraIntrinsicParameters k) throws InvalidPinholeCameraIntrinsicParametersException {
<span class="fc" id="L126">        final var kMatrix = k.getInternalMatrix();</span>
        try {
<span class="fc" id="L128">            final var invKMatrix = Utils.inverse(kMatrix);</span>
<span class="fc" id="L129">            setParameters(invKMatrix.transposeAndReturnNew().multiplyAndReturnNew(invKMatrix));</span>
<span class="nc" id="L130">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L131">            throw new InvalidPinholeCameraIntrinsicParametersException(e);</span>
<span class="nc" id="L132">        } catch (final NonSymmetricMatrixException ignore) {</span>
            // this will never happen
<span class="fc" id="L134">        }</span>
<span class="fc" id="L135">    }</span>

    /**
     * Assuming that we are working in a metric stratum this method obtains the
     * internal parameters of a pinhole camera analytically from IAC.
     * This method should be preferred over Cholesky decomposition as it is
     * more numerically stable.
     *
     * @return the internal parameters of a pinhole camera.
     * @throws InvalidPinholeCameraIntrinsicParametersException if pinhole camera intrinsic parameters
     *                                                          cannot be obtained from this conic instance.
     */
    public PinholeCameraIntrinsicParameters getIntrinsicParameters()
            throws InvalidPinholeCameraIntrinsicParametersException {
        try {
<span class="fc" id="L150">            normalize();</span>

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
<span class="fc" id="L155">            final var b11 = getA();</span>
<span class="fc" id="L156">            final var b12 = getB();</span>
<span class="fc" id="L157">            final var b22 = getC();</span>
<span class="fc" id="L158">            final var b13 = getD();</span>
<span class="fc" id="L159">            final var b23 = getE();</span>
<span class="fc" id="L160">            final var b33 = getF();</span>

            // alpha = horizontal focal distance
            // beta = vertical focal distance
            // gamma = skewness
            // u0 = horizontal principal point
            // v0 = vertical principal point
            // lambda = scale
<span class="fc" id="L168">            final var v0 = (b12 * b13 - b11 * b23) / (b11 * b22 - b12 * b12);</span>
<span class="pc bpc" id="L169" title="2 of 4 branches missed.">            if (Double.isNaN(v0) || Double.isInfinite(v0)) {</span>
<span class="nc" id="L170">                throw new InvalidPinholeCameraIntrinsicParametersException();</span>
            }

            // lambda is an arbitrary scale, because conics are defined up to
            // scale, and we are obtaining intrinsic parameters from IAC (Image
            // of Absolute Conic)
<span class="fc" id="L176">            var lambda = b33 - (b13 * b13 + v0 * (b12 * b13 - b11 * b23)) / b11;</span>
            // fix sign of lambda so that squared roots are always positive
<span class="fc" id="L178">            lambda *= Math.signum(lambda) * Math.signum(b11);</span>

<span class="pc bpc" id="L180" title="2 of 4 branches missed.">            if (Double.isNaN(lambda) || Double.isInfinite(lambda)) {</span>
<span class="nc" id="L181">                throw new InvalidPinholeCameraIntrinsicParametersException();</span>
            }

<span class="fc" id="L184">            final var alpha = Math.sqrt(lambda / b11);</span>
<span class="pc bpc" id="L185" title="2 of 4 branches missed.">            if (Double.isNaN(alpha) || Double.isInfinite(alpha)) {</span>
<span class="nc" id="L186">                throw new InvalidPinholeCameraIntrinsicParametersException();</span>
            }

<span class="fc" id="L189">            final var beta = Math.sqrt(lambda * b11 / (b11 * b22 - b12 * b12));</span>
<span class="pc bpc" id="L190" title="2 of 4 branches missed.">            if (Double.isNaN(beta) || Double.isInfinite(beta)) {</span>
<span class="nc" id="L191">                throw new InvalidPinholeCameraIntrinsicParametersException();</span>
            }

<span class="fc" id="L194">            final var gamma = -b12 * alpha * alpha * beta / lambda;</span>
<span class="pc bpc" id="L195" title="2 of 4 branches missed.">            if (Double.isNaN(gamma) || Double.isInfinite(gamma)) {</span>
<span class="nc" id="L196">                throw new InvalidPinholeCameraIntrinsicParametersException();</span>
            }

<span class="fc" id="L199">            final var u0 = gamma * v0 / beta - b13 * alpha * alpha / lambda;</span>
<span class="pc bpc" id="L200" title="2 of 4 branches missed.">            if (Double.isNaN(u0) || Double.isInfinite(u0)) {</span>
<span class="nc" id="L201">                throw new InvalidPinholeCameraIntrinsicParametersException();</span>
            }

<span class="fc" id="L204">            return new PinholeCameraIntrinsicParameters(alpha, beta, u0, v0, gamma);</span>
<span class="nc" id="L205">        } catch (final ArithmeticException e) {</span>
<span class="nc" id="L206">            throw new InvalidPinholeCameraIntrinsicParametersException(e);</span>
        }
    }

    /**
     * Assuming that we are working in a metric stratum this method obtains the
     * internal parameters of a pinhole camera by means of Cholesky
     * decomposition.
     *
     * @return the internal parameters of a pinhole camera.
     * @throws InvalidPinholeCameraIntrinsicParametersException if pinhole
     *                                                          camera intrinsic parameters cannot be
     *                                                          obtained from this conic instance.
     */
    public PinholeCameraIntrinsicParameters getIntrinsicParametersCholesky()
            throws InvalidPinholeCameraIntrinsicParametersException {
        try {
<span class="fc" id="L223">            normalize();</span>

<span class="fc" id="L225">            final var m = asMatrix();</span>
<span class="fc" id="L226">            final var decomposer = new CholeskyDecomposer(m);</span>
<span class="fc" id="L227">            decomposer.decompose();</span>
<span class="fc" id="L228">            final var inverseInternalParamsMatrix = decomposer.getR();</span>
<span class="fc" id="L229">            final var internalParamsMatrix = com.irurueta.algebra.Utils.inverse(inverseInternalParamsMatrix);</span>
<span class="fc" id="L230">            return new PinholeCameraIntrinsicParameters(internalParamsMatrix);</span>
<span class="nc" id="L231">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L232">            throw new InvalidPinholeCameraIntrinsicParametersException(e);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>