<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BaseAbsoluteOrientationSlamPairedViewsSparseReconstructor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.sfm</a> &gt; <span class="el_source">BaseAbsoluteOrientationSlamPairedViewsSparseReconstructor.java</span></div><h1>BaseAbsoluteOrientationSlamPairedViewsSparseReconstructor.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.irurueta.ar.sfm;

import com.irurueta.ar.slam.AbsoluteOrientationBaseSlamEstimator;
import com.irurueta.ar.slam.BaseCalibrationData;
import com.irurueta.geometry.Rotation3D;

/**
 * Base class in charge of estimating pairs of cameras and 3D reconstructed points from sparse
 * image point correspondences in multiple view pairs and also in charge of estimating overall
 * scene scale and absolute orientation by means of SLAM (Simultaneous Location And Mapping)
 * using data obtained from sensors like accelerometers or gyroscopes.
 * NOTE: absolute orientation slam estimators are not very accurate during estimation of
 * the orientation state, for that reason we take into account the initial orientation.
 *
 * @param &lt;D&gt; calibrator type associated to implementations of SLAM calibration
 *            data.
 * @param &lt;C&gt; type of configuration.
 * @param &lt;R&gt; type of re-constructor.
 * @param &lt;L&gt; type of listener.
 * @param &lt;S&gt; type of SLAM estimator.
 */
public abstract class BaseAbsoluteOrientationSlamPairedViewsSparseReconstructor&lt;
        D extends BaseCalibrationData,
        C extends BaseSlamPairedViewsSparseReconstructorConfiguration&lt;D, C&gt;,
        R extends BaseSlamPairedViewsSparseReconstructor&lt;D, C, R, L, S&gt;,
        L extends BaseSlamPairedViewsSparseReconstructorListener&lt;R&gt;,
        S extends AbsoluteOrientationBaseSlamEstimator&lt;D&gt;&gt; extends
        BaseSlamPairedViewsSparseReconstructor&lt;D, C, R, L, S&gt; {

    /**
     * First sample of orientation received.
     */
    private Rotation3D firstOrientation;

    /**
     * Constructor.
     *
     * @param configuration configuration for this re-constructor.
     * @param listener      listener in charge of handling events.
     * @throws NullPointerException if listener or configuration is not
     *                              provided.
     */
    protected BaseAbsoluteOrientationSlamPairedViewsSparseReconstructor(final C configuration, final L listener) {
<span class="fc" id="L60">        super(configuration, listener);</span>
<span class="fc" id="L61">    }</span>

    /**
     * Provides a new orientation sample to update SLAM estimator.
     * If re-constructor is not running, calling this method has no effect.
     *
     * @param timestamp   timestamp of accelerometer sample since epoch time and
     *                    expressed in nanoseconds.
     * @param orientation new orientation.
     */
    public void updateOrientationSample(final long timestamp, final Rotation3D orientation) {
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        if (slamEstimator != null) {</span>
<span class="fc" id="L73">            slamEstimator.updateOrientationSample(timestamp, orientation);</span>
        }
<span class="fc bfc" id="L75" title="All 2 branches covered.">        if (firstOrientation == null) {</span>
            // make a copy of orientation
<span class="fc" id="L77">            firstOrientation = orientation.toQuaternion();</span>
        }
<span class="fc" id="L79">    }</span>

    /**
     * Indicates whether implementations of a re-constructor uses absolute orientation or
     * not.
     *
     * @return true if absolute orientation is used, false, otherwise.
     */
    @Override
    protected boolean hasAbsoluteOrientation() {
<span class="fc" id="L89">        return true;</span>
    }

    /**
     * Transforms metric cameras on current pair of views so that they are referred to
     * last kept location and rotation and upgrades cameras from metric stratum to
     * Euclidean stratum.
     *
     * @param isInitialPairOfViews   true if initial pair of views is being processed, false otherwise.
     * @param hasAbsoluteOrientation true if absolute orientation is required, false otherwise.
     * @return true if cameras were successfully transformed.
     */
    @Override
    protected boolean transformPairOfCamerasAndPoints(
            final boolean isInitialPairOfViews, final boolean hasAbsoluteOrientation) {

        // R1' = R1*Rdiff
        // Rdiff = R1^T*R1'

        // where R1' is the desired orientation (obtained by sampling a
        // sensor)
        // and R1 is always the identity for the 1st camera.
        // Hence R1' = Rdiff

        // t1' is the desired translation which is zero for the 1st
        // camera.

        // We want: P1' = K*[R1' t1'] = K*[R1' 0]
        // And we have P1 = K[I 0]

        // We need a transformation T so that:
        // P1' = P1*T^-1 = K[I 0][R1' 0]
        //                       [0   1]

        // Hence: T^-1 = [R1' 0]
        //               [0   1]

        // or T = [R1'^T 0]
        //        [0     1]

        // because we are also applying a transformation of scale s,
        // the combination of both transformations is
        // T = [s*R1'^T 0]
        //     [0       1]

<span class="pc bpc" id="L134" title="1 of 4 branches missed.">        if (isInitialPairOfViews &amp;&amp; hasAbsoluteOrientation) {</span>
            // The first pair of views does not require setting translation and rotation
<span class="fc" id="L136">            lastEuclideanCameraRotation = firstOrientation;</span>
        }

<span class="fc" id="L139">        return super.transformPairOfCamerasAndPoints(isInitialPairOfViews, hasAbsoluteOrientation);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>