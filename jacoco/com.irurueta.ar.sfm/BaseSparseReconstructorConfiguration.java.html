<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BaseSparseReconstructorConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.sfm</a> &gt; <span class="el_source">BaseSparseReconstructorConfiguration.java</span></div><h1>BaseSparseReconstructorConfiguration.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.sfm;

import com.irurueta.ar.epipolar.CorrectorType;
import com.irurueta.ar.epipolar.estimators.FundamentalMatrixEstimatorMethod;
import com.irurueta.ar.epipolar.estimators.FundamentalMatrixRobustEstimator;
import com.irurueta.ar.epipolar.estimators.PROSACFundamentalMatrixRobustEstimator;
import com.irurueta.geometry.InhomogeneousPoint2D;
import com.irurueta.geometry.PinholeCameraIntrinsicParameters;
import com.irurueta.geometry.estimators.EPnPPointCorrespondencePinholeCameraEstimator;
import com.irurueta.geometry.estimators.PROSACEPnPPointCorrespondencePinholeCameraRobustEstimator;
import com.irurueta.geometry.estimators.PinholeCameraRobustEstimator;
import com.irurueta.geometry.estimators.ProjectiveTransformation2DRobustEstimator;
import com.irurueta.numerical.robust.RobustEstimatorMethod;

import java.io.Serializable;

/**
 * Base class containing configuration for a sparse re-constructor supporting multiple views.
 *
 * @param &lt;T&gt; an actual implementation of a configuration class.
 */
public abstract class BaseSparseReconstructorConfiguration&lt;T extends BaseSparseReconstructorConfiguration&lt;T&gt;&gt;
        implements Serializable {

    /**
     * Default robust fundamental matrix estimator method.
     * This is only used when general scenes are allowed.
     */
<span class="fc" id="L44">    public static final RobustEstimatorMethod DEFAULT_ROBUST_FUNDAMENTAL_MATRIX_ESTIMATOR_METHOD =</span>
            RobustEstimatorMethod.PROSAC;

    /**
     * Default non-robust fundamental matrix estimator method used internally within a robust estimator.
     * This is only used when general scenes are allowed.
     */
<span class="fc" id="L51">    public static final FundamentalMatrixEstimatorMethod DEFAULT_NON_ROBUST_FUNDAMENTAL_MATRIX_ESTIMATOR_METHOD =</span>
            FundamentalMatrixEstimatorMethod.SEVEN_POINTS_ALGORITHM;

    /**
     * Indicates that estimated fundamental matrix is refined by default using all found inliers.
     * This is only used when general scenes are allowed.
     */
    public static final boolean DEFAULT_REFINE_FUNDAMENTAL_MATRIX = true;

    /**
     * Indicates that fundamental matrix covariance is kept by default after the estimation.
     * This is only used when general scenes are allowed.
     */
    public static final boolean DEFAULT_KEEP_FUNDAMENTAL_MATRIX_COVARIANCE = false;

    /**
     * Default confidence of robustly estimated fundamental matrix. By default, this is 99%.
     * This is only used when general scenes are allowed.
     */
    public static final double DEFAULT_FUNDAMENTAL_MATRIX_CONFIDENCE =
            FundamentalMatrixRobustEstimator.DEFAULT_CONFIDENCE;

    /**
     * Default maximum number of iterations to make while robustly estimating fundamental matrix.
     * By default, this is 5000 iterations. This is only used when general scenes are allowed.
     */
    public static final int DEFAULT_FUNDAMENTAL_MATRIX_MAX_ITERATIONS =
            FundamentalMatrixRobustEstimator.DEFAULT_MAX_ITERATIONS;

    /**
     * Default threshold to determine whether samples for robust fundamental matrix estimation are
     * inliers or not.
     * This is only used when general scenes are allowed.
     */
    public static final double DEFAULT_FUNDAMENTAL_MATRIX_THRESHOLD =
            PROSACFundamentalMatrixRobustEstimator.DEFAULT_THRESHOLD;

    /**
     * Default value indicating that inlier data is kept after robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     */
    public static final boolean DEFAULT_FUNDAMENTAL_MATRIX_COMPUTE_AND_KEEP_INLIERS = true;

    /**
     * Default value indicating that residual data is kept after robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     */
    public static final boolean DEFAULT_FUNDAMENTAL_MATRIX_COMPUTE_AND_KEEP_RESIDUALS = true;

    /**
     * Default method to use for initial cameras' estimation.
     */
<span class="fc" id="L103">    public static final InitialCamerasEstimatorMethod DEFAULT_INITIAL_CAMERAS_ESTIMATOR_METHOD =</span>
            InitialCamerasEstimatorMethod.DUAL_ABSOLUTE_QUADRIC_AND_ESSENTIAL_MATRIX;

    /**
     * Indicates whether an homogeneous point triangulator is used for point triangulation when Dual
     * Absolute Quadric (DAQ) camera initialization is used.
     */
    public static final boolean DEFAULT_DAQ_USE_HOMOGENEOUS_POINT_TRIANGULATOR = true;

    /**
     * Default aspect ratio for initial cameras.
     */
    public static final double DEFAULT_INITIAL_CAMERAS_ASPECT_RATIO = 1.0;

    /**
     * Default horizontal principal point value to use for initial cameras estimation using
     * Dual Image of Absolute Conic (DIAC) or Dual Absolute Quadric (DAQ) methods.
     */
    public static final double DEFAULT_INITIAL_CAMERAS_PRINCIPAL_POINT_X = 0.0;

    /**
     * Default vertical principal point value to use for initial cameras estimation using
     * Dual Image of Absolute Conic (DIAC) or Dual Absolute Quadric (DAQ) methods.
     */
    public static final double DEFAULT_INITIAL_CAMERAS_PRINCIPAL_POINT_Y = 0.0;

    /**
     * Default corrector type to use for point triangulation when initial cameras are
     * being estimated using either Dual Image of Absolute Conic (DIAC), Dual Absolute Quadric
     * (DAQ) or essential matrix methods.
     */
<span class="fc" id="L134">    public static final CorrectorType DEFAULT_INITIAL_CAMERAS_CORRECTOR_TYPE = CorrectorType.SAMPSON_CORRECTOR;</span>

    /**
     * Default value indicating whether valid triangulated points are marked during initial
     * cameras estimation using either Dual Image of Absolute Conic (DIAC) or essential matrix
     * methods.
     */
    public static final boolean DEFAULT_INITIAL_CAMERAS_MARK_VALID_TRIANGULATED_POINTS = true;

    /**
     * Indicates whether a general (points are laying in a general 3D position) scene is
     * allowed.
     * When true, an initial geometry estimation is attempted for general points.
     */
    public static final boolean DEFAULT_ALLOW_GENERAL_SCENE = true;

    /**
     * Indicates whether a planar (points laying in a 3D plane) scene is allowed.
     * When true, an initial geometry estimation is attempted for planar points.
     */
    public static final boolean DEFAULT_ALLOW_PLANAR_SCENE = true;

    /**
     * Default robust planar homography estimator method.
     * This is only used when planar scenes are allowed.
     */
<span class="fc" id="L160">    public static final RobustEstimatorMethod DEFAULT_ROBUST_PLANAR_HOMOGRAPHY_ESTIMATOR_METHOD =</span>
            RobustEstimatorMethod.PROMEDS;

    /**
     * Indicates that planar homography is refined by default using all found inliers.
     * This is only used when planar scenes are allowed.
     */
    public static final boolean DEFAULT_REFINE_PLANAR_HOMOGRAPHY = true;

    /**
     * Indicates that planar homography covariance is kept by default after estimation.
     * This is only used when planar scenes are allowed.
     */
    public static final boolean DEFAULT_KEEP_PLANAR_HOMOGRAPHY_COVARIANCE = false;

    /**
     * Default confidence of robustly estimated planar homography. By default, this is 99%.
     * This is only used when planar scenes are allowed.
     */
    public static final double DEFAULT_PLANAR_HOMOGRAPHY_CONFIDENCE =
            ProjectiveTransformation2DRobustEstimator.DEFAULT_CONFIDENCE;

    /**
     * Default maximum number of iterations to make while robustly estimating planar
     * homography. By default, this is 5000 iterations.
     * This is only used when planar scenes are allowed.
     */
    public static final int DEFAULT_PLANAR_HOMOGRAPHY_MAX_ITERATIONS =
            ProjectiveTransformation2DRobustEstimator.DEFAULT_MAX_ITERATIONS;

    /**
     * Default threshold to determine whether samples for robust projective 2D transformation
     * estimation are inliers or not.
     * This is only used when planar scenes are allowed.
     */
    public static final double DEFAULT_PLANAR_HOMOGRAPHY_THRESHOLD = 1e-3;

    /**
     * Default value indicating that inlier data is kept after robust planar homography estimation.
     * This is only used when planar scenes are allowed.
     */
    public static final boolean DEFAULT_PLANAR_HOMOGRAPHY_COMPUTE_AND_KEEP_INLIERS = true;

    /**
     * Default value indicating that residual data is kept after robust planar homography
     * estimation.
     * This is only used when planar scenes are allowed.
     */
    public static final boolean DEFAULT_PLANAR_HOMOGRAPHY_COMPUTE_AND_KEEP_RESIDUALS = true;

    /**
     * Default value indicating that additional cameras intrinsics are estimated using the
     * Dual Absolute Quadric (DAQ).
     */
    public static final boolean DEFAULT_USE_DAQ_FOR_ADDITIONAL_CAMERAS_INTRINSICS = true;

    /**
     * Default value indicating that additional cameras intrinsics are estimated using
     * the Dual Image of Absolute Conic (DIAC).
     */
    public static final boolean DEFAULT_USE_DIAC_FOR_ADDITIONAL_CAMERAS_INTRINSICS = false;

    /**
     * Default skewness for additional cameras when UPnP (Uncalibrated Perspective-n-Point)
     * method is used for additional cameras estimation and neither Dual Image of Absolute
     * Conic (DIAC) or Dual Absolute Quadric (DAQ) are estimated to find intrinsic
     * parameters when adding new cameras.
     */
    public static final double DEFAULT_ADDITIONAL_CAMERAS_SKEWNESS = 0.0;

    /**
     * Default horizontal coordinate of principal point for additional cameras when
     * UPnP (Uncalibrated Perspective-n-Point) method is used for additional cameras
     * estimation and neither Dual Image of Absolute Conic (DIAC) or Dual Absolute
     * Quadric (DAQ) are estimated to find intrinsic parameters when adding new
     * cameras.
     */
    public static final double DEFAULT_ADDITIONAL_CAMERAS_HORIZONTAL_PRINCIPAL_POINT = 0.0;

    /**
     * Default vertical coordinate of principal point for additional cameras when
     * UPnP (Uncalibrated Perspective-n-Point) method is used for additional cameras
     * estimation and neither Dual Image of Absolute Conic (DIAC) or Dual Absolute
     * Quadric (DAQ) are estimated to find intrinsic parameters when adding new
     * cameras.
     */
    public static final double DEFAULT_ADDITIONAL_CAMERAS_VERTICAL_PRINCIPAL_POINT = 0.0;

    /**
     * Default aspect ratio for additional cameras.
     */
    public static final double DEFAULT_ADDITIONAL_CAMERAS_ASPECT_RATIO = 1.0;


    /**
     * Indicates that by default EPnP (Efficient Perspective-n-Point) method is NOT
     * used for additional cameras' estimation.
     */
    public static final boolean DEFAULT_USE_EPNP_FOR_ADDITIONAL_CAMERAS_ESTIMATION = false;

    /**
     * Indicates that by default UPnP (Uncalibrated Perspective-n-Point) method is
     * used for additional cameras' estimation.
     */
    public static final boolean DEFAULT_USE_UPNP_FOR_ADDITIONAL_CAMERAS_ESTIMATION = true;

    /**
     * Default robust method to estimate additional cameras.
     */
<span class="fc" id="L269">    public static final RobustEstimatorMethod DEFAULT_ADDITIONAL_CAMERAS_ROBUST_ESTIMATION_METHOD =</span>
            RobustEstimatorMethod.PROSAC;

    /**
     * Default value indicating that planar configuration is allowed for additional
     * cameras estimation using either EPnP or UPnP.
     */
    public static final boolean DEFAULT_ADDITIONAL_CAMERAS_ALLOW_PLANAR_CONFIGURATION =
            EPnPPointCorrespondencePinholeCameraEstimator.DEFAULT_PLANAR_CONFIGURATION_ALLOWED;

    /**
     * Default value indicating that dimension 2 null-space is allowed while estimating
     * additional cameras using either EPnP or UPnP.
     */
    public static final boolean DEFAULT_ADDITIONAL_CAMERAS_ALLOW_NULLSPACE_DIMENSION2 =
            EPnPPointCorrespondencePinholeCameraEstimator.DEFAULT_NULLSPACE_DIMENSION2_ALLOWED;

    /**
     * Default value indicating that dimension 3 null-space is allowed while estimating
     * additional cameras using EPnP.
     */
    public static final boolean DEFAULT_ADDITIONAL_CAMERAS_ALLOW_NULLSPACE_DIMENSION3 =
            EPnPPointCorrespondencePinholeCameraEstimator.DEFAULT_NULLSPACE_DIMENSION3_ALLOWED;

    /**
     * Default threshold to determine whether 3D matched points to estimate additional
     * cameras are in a planar configuration.
     */
    public static final double DEFAULT_ADDITIONAL_CAMERAS_PLANAR_THRESHOLD =
            EPnPPointCorrespondencePinholeCameraEstimator.DEFAULT_PLANAR_THRESHOLD;

    /**
     * Default value indicating that additional cameras are refined to minimize overall
     * projection error among all found inliers.
     */
    public static final boolean DEFAULT_REFINE_ADDITIONAL_CAMERAS = PinholeCameraRobustEstimator.DEFAULT_REFINE_RESULT;

    /**
     * Default value indicating that covariance is kept after refining results of
     * additional cameras estimation.
     */
    public static final boolean DEFAULT_KEEP_COVARIANCE_ADDITIONAL_CAMERAS = true;

    /**
     * Default value indicating that fast refinement is used for additional cameras'
     * estimation.
     */
    public static final boolean DEFAULT_ADDITIONAL_CAMERAS_USE_FAST_REFINEMENT = true;

    /**
     * Default confidence of estimated additional cameras, which is 99%. This means
     * that with a probability of 99% estimation will be accurate because chosen
     * sub-samples will be inliers.
     */
    public static final double DEFAULT_ADDITIONAL_CAMERAS_CONFIDENCE = PinholeCameraRobustEstimator.DEFAULT_CONFIDENCE;

    /**
     * Default maximum allowed number of iterations for additional cameras estimation.
     */
    public static final int DEFAULT_ADDITIONAL_CAMERAS_MAX_ITERATIONS =
            PinholeCameraRobustEstimator.DEFAULT_MAX_ITERATIONS;

    /**
     * Default threshold to determine whether samples for robust pinhole camera estimation are
     * inliers or not.
     */
    public static final double DEFAULT_ADDITIONAL_CAMERAS_THRESHOLD =
            PROSACEPnPPointCorrespondencePinholeCameraRobustEstimator.DEFAULT_THRESHOLD;

    /**
     * Default value indicating that inlier data is kept after additional camera estimation.
     */
    public static final boolean DEFAULT_ADDITIONAL_CAMERAS_COMPUTE_AND_KEEP_INLIERS = true;

    /**
     * Default value indicating that residual data is kept after additional camera estimation.
     */
    public static final boolean DEFAULT_ADDITIONAL_CAMERAS_COMPUTE_AND_KEEP_RESIDUALS = true;

    /**
     * Default value indicating that skewness is not suggested during additional cameras'
     * estimation.
     */
    public static final boolean DEFAULT_ADDITIONAL_CAMERAS_SUGGEST_SKEWNESS_VALUE_ENABLED =
            PinholeCameraRobustEstimator.DEFAULT_SUGGEST_SKEWNESS_VALUE_ENABLED;

    /**
     * Default value of skewness to be suggested when suggestion is enabled during
     * additional cameras' estimation.
     * By default, suggested skewness is zero.
     */
    public static final double DEFAULT_ADDITIONAL_CAMERAS_SUGGESTED_SKEWNESS_VALUE =
            PinholeCameraRobustEstimator.DEFAULT_SUGGESTED_SKEWNESS_VALUE;

    /**
     * Default value indicating whether horizontal focal length value is suggested or not
     * during additional cameras' estimation. By default, this is disabled.
     */
    public static final boolean DEFAULT_ADDITIONAL_CAMERAS_SUGGEST_HORIZONTAL_FOCAL_LENGTH_ENABLED =
            PinholeCameraRobustEstimator.DEFAULT_SUGGEST_HORIZONTAL_FOCAL_LENGTH_ENABLED;

    /**
     * Default value indicating whether vertical focal length value is suggested or not
     * during additional cameras' estimation. By default, this is disabled.
     */
    public static final boolean DEFAULT_ADDITIONAL_CAMERAS_SUGGEST_VERTICAL_FOCAL_LENGTH_ENABLED =
            PinholeCameraRobustEstimator.DEFAULT_SUGGEST_VERTICAL_FOCAL_LENGTH_ENABLED;

    /**
     * Default value indicating whether aspect ratio is suggested or not. By default, this is
     * disabled.
     */
    public static final boolean DEFAULT_ADDITIONAL_CAMERAS_SUGGEST_ASPECT_RATIO_ENABLED =
            PinholeCameraRobustEstimator.DEFAULT_SUGGEST_ASPECT_RATIO_ENABLED;

    /**
     * Default value of aspect ratio to be suggested when suggestion is enabled.
     * By default, suggested aspect ratio is 1.0, although also -1.0 is a typical value
     * when vertical coordinates increase downwards.
     */
    public static final double DEFAULT_ADDITIONAL_CAMERAS_SUGGESTED_ASPECT_RATIO_VALUE =
            PinholeCameraRobustEstimator.DEFAULT_SUGGESTED_ASPECT_RATIO_VALUE;

    /**
     * Default value indicating whether principal point is suggested or not. By default,
     * this is disabled.
     */
    public static final boolean DEFAULT_ADDITIONAL_CAMERAS_SUGGEST_PRINCIPAL_POINT_ENABLED =
            PinholeCameraRobustEstimator.DEFAULT_SUGGEST_PRINCIPAL_POINT_ENABLED;

    /**
     * Indicates that an homogeneous point triangulator will be used by default.
     */
    public static final boolean DEFAULT_USE_HOMOGENEOUS_POINT_TRIANGULATOR =
            RobustSinglePoint3DTriangulator.DEFAULT_USE_HOMOGENEOUS_SOLUTION;

    /**
     * Default robust point triangulator method.
     */
<span class="fc" id="L408">    public static final RobustEstimatorMethod DEFAULT_ROBUST_POINT_TRIANGULATOR_METHOD =</span>
            RobustSinglePoint3DTriangulator.DEFAULT_ROBUST_METHOD;

    /**
     * Default confidence of robustly triangulated points. By default, this is 99%.
     */
    public static final double DEFAULT_POINT_TRIANGULATOR_CONFIDENCE =
            RobustSinglePoint3DTriangulator.DEFAULT_CONFIDENCE;

    /**
     * Default maximum number of iterations to make while robustly estimating
     * triangulated points. By default, this is 5000 iterations.
     */
    public static final int DEFAULT_POINT_TRIANGULATOR_MAX_ITERATIONS =
            RobustSinglePoint3DTriangulator.DEFAULT_MAX_ITERATIONS;

    /**
     * Default threshold to determine whether samples for robust point triangulator are
     * inliers or not.
     */
    public static final double DEFAULT_POINT_TRIANGULATOR_THRESHOLD =
            PROSACRobustSinglePoint3DTriangulator.DEFAULT_THRESHOLD;

    /**
     * Method to use for non-robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     */
<span class="fc" id="L435">    private FundamentalMatrixEstimatorMethod mNonRobustFundamentalMatrixEstimatorMethod =</span>
            DEFAULT_NON_ROBUST_FUNDAMENTAL_MATRIX_ESTIMATOR_METHOD;

    /**
     * Method to use for robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     */
<span class="fc" id="L442">    private RobustEstimatorMethod mRobustFundamentalMatrixEstimatorMethod =</span>
            DEFAULT_ROBUST_FUNDAMENTAL_MATRIX_ESTIMATOR_METHOD;

    /**
     * Indicates whether estimated fundamental matrix is refined among all found inliers.
     * This is only used when general scenes are allowed.
     */
<span class="fc" id="L449">    private boolean refineFundamentalMatrix = DEFAULT_REFINE_FUNDAMENTAL_MATRIX;</span>

    /**
     * Indicates whether covariance of estimated fundamental matrix is kept after the
     * estimation.
     * This is only used when general scenes are allowed.
     */
<span class="fc" id="L456">    private boolean keepFundamentalMatrixCovariance = DEFAULT_KEEP_FUNDAMENTAL_MATRIX_COVARIANCE;</span>

    /**
     * Confidence of robustly estimated fundamental matrix.
     * This is only used when general scenes are allowed.
     */
<span class="fc" id="L462">    private double fundamentalMatrixConfidence = DEFAULT_FUNDAMENTAL_MATRIX_CONFIDENCE;</span>

    /**
     * Maximum number of iterations to robustly estimate fundamental matrix.
     * This is only used when general scenes are allowed.
     */
<span class="fc" id="L468">    private int fundamentalMatrixMaxIterations = DEFAULT_FUNDAMENTAL_MATRIX_MAX_ITERATIONS;</span>

    /**
     * Threshold to determine whether samples for robust fundamental matrix estimation are
     * inliers or not.
     * This is only used when general scenes are allowed.
     */
<span class="fc" id="L475">    private double fundamentalMatrixThreshold = DEFAULT_FUNDAMENTAL_MATRIX_THRESHOLD;</span>

    /**
     * Indicates whether inliers must be kept during robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     */
<span class="fc" id="L481">    private boolean fundamentalMatrixComputeAndKeepInliers = DEFAULT_FUNDAMENTAL_MATRIX_COMPUTE_AND_KEEP_INLIERS;</span>

    /**
     * Indicates whether residuals must be computed and kept during robust fundamental matrix
     * estimation.
     * This is only used when general scenes are allowed.
     */
<span class="fc" id="L488">    private boolean fundamentalMatrixComputeAndKeepResiduals = DEFAULT_FUNDAMENTAL_MATRIX_COMPUTE_AND_KEEP_RESIDUALS;</span>

    /**
     * Method to use for initial cameras' estimation.
     */
<span class="fc" id="L493">    private InitialCamerasEstimatorMethod initialCamerasEstimatorMethod = DEFAULT_INITIAL_CAMERAS_ESTIMATOR_METHOD;</span>

    /**
     * Indicates whether an homogeneous point triangulator is used for point triangulation
     * when Dual Absolute Quadric (DAQ) camera initialization is used.
     */
<span class="fc" id="L499">    private boolean daqUseHomogeneousPointTriangulator = DEFAULT_DAQ_USE_HOMOGENEOUS_POINT_TRIANGULATOR;</span>

    /**
     * Aspect ratio for initial cameras.
     */
<span class="fc" id="L504">    private double initialCamerasAspectRatio = DEFAULT_INITIAL_CAMERAS_ASPECT_RATIO;</span>

    /**
     * Horizontal principal point value to use for initial cameras estimation using
     * Dual Image of Absolute Conic (DIAC) or Dual Absolute Quadric (DAQ) methods.
     */
<span class="fc" id="L510">    private double principalPointX = DEFAULT_INITIAL_CAMERAS_PRINCIPAL_POINT_X;</span>

    /**
     * Vertical principal point value to use for initial cameras estimation using
     * Dual Image of Absolute Conic (DIAC) or Dual Absolute Quadric (DAC) methods.
     */
<span class="fc" id="L516">    private double principalPointY = DEFAULT_INITIAL_CAMERAS_PRINCIPAL_POINT_Y;</span>

    /**
     * Corrector type to use for point triangulation when initial cameras are being estimated
     * using either Dual Image of Absolute Conic (DIAC) or essential matrix methods or null
     * if no corrector is used.
     */
<span class="fc" id="L523">    private CorrectorType initialCamerasCorrectorType = DEFAULT_INITIAL_CAMERAS_CORRECTOR_TYPE;</span>

    /**
     * Value indicating whether valid triangulated points are marked during initial
     * cameras estimation using either Dual Image of Absolute Conic (DIAC) or essential
     * matrix methods.
     */
<span class="fc" id="L530">    private boolean initialCamerasMarkValidTriangulatedPoints = DEFAULT_INITIAL_CAMERAS_MARK_VALID_TRIANGULATED_POINTS;</span>

    /**
     * Intrinsic parameters of first camera estimated using the essential matrix
     * method.
     */
    private PinholeCameraIntrinsicParameters initialIntrinsic1;

    /**
     * Intrinsic parameters of second camera estimated using the essential matrix
     * method.
     */
    private PinholeCameraIntrinsicParameters initialIntrinsic2;

    /**
     * Indicates whether a general scene (points laying in a general 3D position) is
     * allowed.
     * When true, an initial geometry estimation is attempted for general points.
     */
<span class="fc" id="L549">    private boolean allowGeneralScene = DEFAULT_ALLOW_GENERAL_SCENE;</span>

    /**
     * Indicates whether a planar scene (points laying in a 3D plane) is allowed.
     * When true, an initial geometry estimation is attempted for planar points.
     */
<span class="fc" id="L555">    private boolean allowPlanarScene = DEFAULT_ALLOW_PLANAR_SCENE;</span>

    /**
     * Robust method to use for planar homography estimation.
     * This is only used when planar scenes are allowed.
     */
<span class="fc" id="L561">    private RobustEstimatorMethod robustPlanarHomographyEstimatorMethod =</span>
            DEFAULT_ROBUST_PLANAR_HOMOGRAPHY_ESTIMATOR_METHOD;

    /**
     * Indicates whether planar homography is refined using all found inliers or not.
     * This is only used when planar scenes are allowed.
     */
<span class="fc" id="L568">    private boolean refinePlanarHomography = DEFAULT_REFINE_PLANAR_HOMOGRAPHY;</span>

    /**
     * Indicates whether planar homography covariance is kept after estimation.
     * This is only used when planar scenes are allowed.
     */
<span class="fc" id="L574">    private boolean keepPlanarHomographyCovariance = DEFAULT_KEEP_PLANAR_HOMOGRAPHY_COVARIANCE;</span>

    /**
     * Confidence of robustly estimated planar homography. By default, this is 99%.
     * This is only used when planar scenes are allowed.
     */
<span class="fc" id="L580">    private double planarHomographyConfidence = DEFAULT_PLANAR_HOMOGRAPHY_CONFIDENCE;</span>

    /**
     * Maximum number of iterations to make while robustly estimating planar homography.
     * By default, this is 5000.
     * This is only used when planar scenes are allowed.
     */
<span class="fc" id="L587">    private int planarHomographyMaxIterations = DEFAULT_PLANAR_HOMOGRAPHY_MAX_ITERATIONS;</span>

    /**
     * Threshold to determine whether samples for robust projective 2D transformation estimation
     * are inliers or not.
     */
<span class="fc" id="L593">    private double planarHomographyThreshold = DEFAULT_PLANAR_HOMOGRAPHY_THRESHOLD;</span>

    /**
     * Value indicating that inlier data is kept after robust planar homography estimation.
     * This is only used when planar scenes are allowed.
     */
<span class="fc" id="L599">    private boolean planarHomographyComputeAndKeepInliers = DEFAULT_PLANAR_HOMOGRAPHY_COMPUTE_AND_KEEP_INLIERS;</span>

    /**
     * Value indicating that residual data is kept after robust planar homography estimation.
     * This is only used when planar scenes are allowed.
     */
<span class="fc" id="L605">    private boolean planarHomographyComputeAndKeepResiduals = DEFAULT_PLANAR_HOMOGRAPHY_COMPUTE_AND_KEEP_RESIDUALS;</span>

    /**
     * Indicates that additional cameras intrinsics are estimated using the Dual Absolute
     * Quadric (DAQ).
     */
<span class="fc" id="L611">    private boolean useDAQForAdditionalCamerasIntrinsics = DEFAULT_USE_DAQ_FOR_ADDITIONAL_CAMERAS_INTRINSICS;</span>

    /**
     * Indicates that additional cameras intrinsics are estimated using the Dual Image of Absolute
     * Conic (DIAC).
     */
<span class="fc" id="L617">    private boolean useDIACForAdditionalCamerasIntrinsics = DEFAULT_USE_DIAC_FOR_ADDITIONAL_CAMERAS_INTRINSICS;</span>

    /**
     * Intrinsic parameters to use for additional cameras estimation when neither
     * Dual Image of Absolute Conic (DIAC) nor Dual Absolute Quadric (DAQ) are used
     * for intrinsic parameters' estimation.
     */
    private PinholeCameraIntrinsicParameters additionalCamerasIntrinsics;

    /**
     * Skewness for additional cameras when UPnP (Uncalibrated Perspective-n-Point) method
     * is used for additional cameras' estimation.
     */
<span class="fc" id="L630">    private double additionalCamerasSkewness = DEFAULT_ADDITIONAL_CAMERAS_SKEWNESS;</span>

    /**
     * Horizontal coordinate of principal point for additional cameras when UPnP
     * (Uncalibrated Perspective-n-Point) method is used for additional cameras estimation
     * and neither Dual Image of Absolute Conic (DIAC) or Dual Absolute Quadric (DAQ) are
     * estimated to find intrinsic parameters when adding new cameras.
     */
<span class="fc" id="L638">    private double additionalCamerasHorizontalPrincipalPoint = DEFAULT_ADDITIONAL_CAMERAS_HORIZONTAL_PRINCIPAL_POINT;</span>

    /**
     * Vertical coordinate of principal point for additional cameras when UPnP (Uncalibrated
     * Perspective-n-Point) method is used for additional cameras estimation and neither Dual
     * Image of Absolute Conic (DIAC) nor Dual Absolute Quadric (DAQ) are estimated to find
     * intrinsic parameters when adding new cameras.
     */
<span class="fc" id="L646">    private double additionalCamerasVerticalPrincipalPoint = DEFAULT_ADDITIONAL_CAMERAS_VERTICAL_PRINCIPAL_POINT;</span>

    /**
     * Aspect ratio for additional cameras.
     */
<span class="fc" id="L651">    private double additionalCamerasAspectRatio = DEFAULT_ADDITIONAL_CAMERAS_ASPECT_RATIO;</span>

    /**
     * Indicates whether EPnP (Efficient Perspective-n-Point) method is used for additional
     * cameras' estimation. Either EPnP or UPnP must be used for additional cameras'
     * estimation.
     */
<span class="fc" id="L658">    private boolean useEPnPForAdditionalCamerasEstimation = DEFAULT_USE_EPNP_FOR_ADDITIONAL_CAMERAS_ESTIMATION;</span>

    /**
     * Indicates whether UPnP (Uncalibrated Perspective-n-Point) method is used for
     * additional cameras' estimation. Either EPnP or UPnP must be used for additional
     * cameras' estimation.
     */
<span class="fc" id="L665">    private boolean useUPnPForAdditionalCamerasEstimation = DEFAULT_USE_UPNP_FOR_ADDITIONAL_CAMERAS_ESTIMATION;</span>

    /**
     * Robust method to estimate additional cameras.
     */
<span class="fc" id="L670">    private RobustEstimatorMethod additionalCamerasRobustEstimationMethod =</span>
            DEFAULT_ADDITIONAL_CAMERAS_ROBUST_ESTIMATION_METHOD;

    /**
     * Indicates whether planar configuration is allowed for additional cameras
     * estimation using either EPnP or UPnP.
     */
<span class="fc" id="L677">    private boolean additionalCamerasAllowPlanarConfiguration = DEFAULT_ADDITIONAL_CAMERAS_ALLOW_PLANAR_CONFIGURATION;</span>

    /**
     * Indicates whether dimension 2 null-space is allowed while estimating additional
     * cameras using either EPnP or UPnP.
     */
<span class="fc" id="L683">    private boolean additionalCamerasAllowNullspaceDimension2 = DEFAULT_ADDITIONAL_CAMERAS_ALLOW_NULLSPACE_DIMENSION2;</span>

    /**
     * Indicates whether dimension 3 null-space is allowed while estimating additional
     * cameras using EPnP.
     */
<span class="fc" id="L689">    private boolean additionalCamerasAllowNullspaceDimension3 = DEFAULT_ADDITIONAL_CAMERAS_ALLOW_NULLSPACE_DIMENSION3;</span>

    /**
     * Threshold to determine whether 3D matched points to estimate additional cameras
     * are in a planar configuration.
     */
<span class="fc" id="L695">    private double additionalCamerasPlanarThreshold = DEFAULT_ADDITIONAL_CAMERAS_PLANAR_THRESHOLD;</span>

    /**
     * Indicates whether additional cameras are refined to minimize overall projection
     * error among all found inliers.
     */
<span class="fc" id="L701">    private boolean refineAdditionalCameras = DEFAULT_REFINE_ADDITIONAL_CAMERAS;</span>

    /**
     * Indicates whether covariance is kept after refining result of additional
     * cameras' estimation.
     */
<span class="fc" id="L707">    private boolean keepCovarianceAdditionalCameras = DEFAULT_KEEP_COVARIANCE_ADDITIONAL_CAMERAS;</span>

    /**
     * Value indicating whether fast refinement is used for additional cameras' estimation.
     */
<span class="fc" id="L712">    private boolean additionalCamerasUseFastRefinement = DEFAULT_ADDITIONAL_CAMERAS_USE_FAST_REFINEMENT;</span>

    /**
     * Confidence of estimated additional cameras.
     */
<span class="fc" id="L717">    private double additionalCamerasConfidence = DEFAULT_ADDITIONAL_CAMERAS_CONFIDENCE;</span>

    /**
     * Maximum allowed number of iterations for additional cameras estimation.
     */
<span class="fc" id="L722">    private int additionalCamerasMaxIterations = DEFAULT_ADDITIONAL_CAMERAS_MAX_ITERATIONS;</span>

    /**
     * Threshold to determine whether samples for robust pinhole camera estimation are inliers or not.
     */
<span class="fc" id="L727">    private double additionalCamerasThreshold = DEFAULT_ADDITIONAL_CAMERAS_THRESHOLD;</span>

    /**
     * Indicates whether inliers must be kept during additional camera estimation.
     */
<span class="fc" id="L732">    private boolean additionalCamerasComputeAndKeepInliers = DEFAULT_ADDITIONAL_CAMERAS_COMPUTE_AND_KEEP_INLIERS;</span>

    /**
     * Indicates whether residuals must be computed and kept during additional camera estimation.
     */
<span class="fc" id="L737">    private boolean additionalCamerasComputeAndKeepResiduals = DEFAULT_ADDITIONAL_CAMERAS_COMPUTE_AND_KEEP_RESIDUALS;</span>

    /**
     * Value indicating whether skewness is not suggested during additional cameras'
     * estimation.
     */
<span class="fc" id="L743">    private boolean additionalCamerasSuggestSkewnessValueEnabled =</span>
            DEFAULT_ADDITIONAL_CAMERAS_SUGGEST_SKEWNESS_VALUE_ENABLED;

    /**
     * Value of skewness to be suggested when suggestion is enabled during additional
     * cameras' estimation.
     */
<span class="fc" id="L750">    private double additionalCamerasSuggestedSkewnessValue = DEFAULT_ADDITIONAL_CAMERAS_SUGGESTED_SKEWNESS_VALUE;</span>

    /**
     * Value indicating whether horizontal focal length value is suggested or not
     * during additional cameras' estimation.
     */
<span class="fc" id="L756">    private boolean additionalCamerasSuggestHorizontalFocalLengthEnabled =</span>
            DEFAULT_ADDITIONAL_CAMERAS_SUGGEST_HORIZONTAL_FOCAL_LENGTH_ENABLED;

    /**
     * Value of suggested horizontal focal length during additional cameras' estimation.
     */
    private double additionalCamerasSuggestedHorizontalFocalLengthValue;

    /**
     * Value indicating whether vertical focal length value is suggested or not
     * during additional cameras' estimation.
     */
<span class="fc" id="L768">    private boolean additionalCamerasSuggestVerticalFocalLengthEnabled =</span>
            DEFAULT_ADDITIONAL_CAMERAS_SUGGEST_VERTICAL_FOCAL_LENGTH_ENABLED;

    /**
     * Value of suggested vertical focal length during additional cameras' estimation.
     */
    private double additionalCamerasSuggestedVerticalFocalLengthValue;

    /**
     * Value indicating whether aspect ratio is suggested or not during
     * additional cameras' estimation.
     */
<span class="fc" id="L780">    private boolean additionalCamerasSuggestAspectRatioEnabled =</span>
            DEFAULT_ADDITIONAL_CAMERAS_SUGGEST_ASPECT_RATIO_ENABLED;

    /**
     * Value of aspect ratio to be suggested when suggestion is enabled during
     * additional cameras' estimation.
     */
<span class="fc" id="L787">    private double additionalCamerasSuggestedAspectRatioValue =</span>
            DEFAULT_ADDITIONAL_CAMERAS_SUGGESTED_ASPECT_RATIO_VALUE;

    /**
     * Value indicating whether principal point is suggested or not during
     * additional cameras' estimation.
     */
<span class="fc" id="L794">    private boolean additionalCamerasSuggestPrincipalPointEnabled =</span>
            DEFAULT_ADDITIONAL_CAMERAS_SUGGEST_PRINCIPAL_POINT_ENABLED;

    /**
     * Value of principal point to be suggested when suggestion is enabled
     * during additional cameras' estimation.
     */
    private InhomogeneousPoint2D additionalCamerasSuggestedPrincipalPointValue;

    /**
     * Indicates whether homogeneous point triangulator must be used or not to
     * estimate 3D points when only two matches are available.
     */
<span class="fc" id="L807">    private boolean useHomogeneousPointTriangulator = DEFAULT_USE_HOMOGENEOUS_POINT_TRIANGULATOR;</span>

    /**
     * Robust method for point triangulation when points are matched in more
     * than two views.
     */
<span class="fc" id="L813">    private RobustEstimatorMethod robustPointTriangulatorMethod = DEFAULT_ROBUST_POINT_TRIANGULATOR_METHOD;</span>

    /**
     * Confidence of robustly triangulated points. By default, this is 99%.
     */
<span class="fc" id="L818">    private double pointTriangulatorConfidence = DEFAULT_POINT_TRIANGULATOR_CONFIDENCE;</span>

    /**
     * Maximum number of iterations to make while robustly estimating
     * triangulated points. By default, this is 5000 iterations.
     */
<span class="fc" id="L824">    private int pointTriangulatorMaxIterations = DEFAULT_POINT_TRIANGULATOR_MAX_ITERATIONS;</span>

    /**
     * Threshold to determine whether samples for robust point triangulator are
     * inliers or not.
     */
<span class="fc" id="L830">    private double pointTriangulatorThreshold = DEFAULT_POINT_TRIANGULATOR_THRESHOLD;</span>

    /**
     * Constructor.
     */
<span class="fc" id="L835">    protected BaseSparseReconstructorConfiguration() {</span>
<span class="fc" id="L836">    }</span>

    /**
     * Gets method to use for non-robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @return method to use for non-robust fundamental matrix estimation.
     */
    public FundamentalMatrixEstimatorMethod getNonRobustFundamentalMatrixEstimatorMethod() {
<span class="fc" id="L845">        return mNonRobustFundamentalMatrixEstimatorMethod;</span>
    }

    /**
     * Sets method to use for non-robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @param method method to use for non-robust fundamental matrix estimation.
     * @return this instance so that method can be easily chained.
     */
    public T setNonRobustFundamentalMatrixEstimatorMethod(final FundamentalMatrixEstimatorMethod method) {
<span class="fc" id="L856">        mNonRobustFundamentalMatrixEstimatorMethod = method;</span>
        //noinspection unchecked
<span class="fc" id="L858">        return (T) this;</span>
    }

    /**
     * Gets method to use for robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @return method to use for robust fundamental matrix estimation.
     */
    public RobustEstimatorMethod getRobustFundamentalMatrixEstimatorMethod() {
<span class="fc" id="L868">        return mRobustFundamentalMatrixEstimatorMethod;</span>
    }

    /**
     * Sets method to use for robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @param method method to use for robust fundamental matrix estimation.
     * @return this instance so that method can be easily chained.
     */
    public T setRobustFundamentalMatrixEstimatorMethod(final RobustEstimatorMethod method) {
<span class="fc" id="L879">        mRobustFundamentalMatrixEstimatorMethod = method;</span>
        //noinspection unchecked
<span class="fc" id="L881">        return (T) this;</span>
    }

    /**
     * Indicates whether estimated fundamental matrix is refined among all found inliers.
     * This is only used when general scenes are allowed.
     *
     * @return true if fundamental matrix is refined, false otherwise.
     */
    public boolean isFundamentalMatrixRefined() {
<span class="fc" id="L891">        return refineFundamentalMatrix;</span>
    }

    /**
     * Specifies whether estimated fundamental matrix is refined among all found inliers.
     * This is only used when general scenes are allowed.
     *
     * @param refineFundamentalMatrix true if fundamental matrix is refined, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixRefined(final boolean refineFundamentalMatrix) {
<span class="fc" id="L902">        this.refineFundamentalMatrix = refineFundamentalMatrix;</span>
        //noinspection unchecked
<span class="fc" id="L904">        return (T) this;</span>
    }

    /**
     * Indicates whether covariance of estimated fundamental matrix is kept after the estimation.
     * This is only used when general scenes are allowed.
     *
     * @return true if covariance is kept, false otherwise.
     */
    public boolean isFundamentalMatrixCovarianceKept() {
<span class="fc" id="L914">        return keepFundamentalMatrixCovariance;</span>
    }

    /**
     * Specifies whether covariance of estimated fundamental matrix is kept after the
     * estimation.
     * This is only used when general scenes are allowed.
     *
     * @param keepFundamentalMatrixCovariance true if covariance is kept, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixCovarianceKept(final boolean keepFundamentalMatrixCovariance) {
<span class="fc" id="L926">        this.keepFundamentalMatrixCovariance = keepFundamentalMatrixCovariance;</span>
        //noinspection unchecked
<span class="fc" id="L928">        return (T) this;</span>
    }

    /**
     * Gets confidence of robustly estimated fundamental matrix.
     * This is only used when general scenes are allowed.
     *
     * @return confidence of robustly estimated fundamental matrix.
     */
    public double getFundamentalMatrixConfidence() {
<span class="fc" id="L938">        return fundamentalMatrixConfidence;</span>
    }

    /**
     * Sets confidence of robustly estimated fundamental matrix.
     * This is only used when general scenes are allowed.
     *
     * @param fundamentalMatrixConfidence confidence of robustly estimated fundamental matrix.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixConfidence(final double fundamentalMatrixConfidence) {
<span class="fc" id="L949">        this.fundamentalMatrixConfidence = fundamentalMatrixConfidence;</span>
        //noinspection unchecked
<span class="fc" id="L951">        return (T) this;</span>
    }

    /**
     * Gets maximum number of iterations to robustly estimate fundamental matrix.
     * This is only used when general scenes are allowed.
     *
     * @return maximum number of iterations to robustly estimate fundamental matrix.
     */
    public int getFundamentalMatrixMaxIterations() {
<span class="fc" id="L961">        return fundamentalMatrixMaxIterations;</span>
    }

    /**
     * Sets maximum number of iterations to robustly estimate fundamental matrix.
     * This is only used when general scenes are allowed.
     *
     * @param fundamentalMatrixMaxIterations maximum number of iterations to robustly estimate
     *                                       fundamental matrix.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixMaxIterations(final int fundamentalMatrixMaxIterations) {
<span class="fc" id="L973">        this.fundamentalMatrixMaxIterations = fundamentalMatrixMaxIterations;</span>
        //noinspection unchecked
<span class="fc" id="L975">        return (T) this;</span>
    }

    /**
     * Gets threshold to determine whether samples for robust fundamental matrix estimation
     * are inliers or not.
     * This is only used when general scenes are allowed.
     *
     * @return threshold to determine whether samples for robust fundamental matrix
     * estimation are inliers or not.
     */
    public double getFundamentalMatrixThreshold() {
<span class="fc" id="L987">        return fundamentalMatrixThreshold;</span>
    }

    /**
     * Sets threshold to determine whether samples for robust fundamental matrix
     * estimation are inliers or not.
     * This is only used when general scenes are allowed.
     *
     * @param fundamentalMatrixThreshold threshold to determine whether samples for
     *                                   robust fundamental matrix estimation are inliers
     *                                   or not.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixThreshold(final double fundamentalMatrixThreshold) {
<span class="fc" id="L1001">        this.fundamentalMatrixThreshold = fundamentalMatrixThreshold;</span>
        //noinspection unchecked
<span class="fc" id="L1003">        return (T) this;</span>
    }

    /**
     * Indicates whether inliers must be kept during robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @return true if inliers must be kept during robust fundamental matrix estimation,
     * false otherwise.
     */
    public boolean getFundamentalMatrixComputeAndKeepInliers() {
<span class="fc" id="L1014">        return fundamentalMatrixComputeAndKeepInliers;</span>
    }

    /**
     * Specifies whether inliers must be kept during robust fundamental matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @param fundamentalMatrixComputeAndKeepInliers true if inliers must be kept during
     *                                               robust fundamental matrix estimation, false
     *                                               otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixComputeAndKeepInliers(final boolean fundamentalMatrixComputeAndKeepInliers) {
<span class="fc" id="L1027">        this.fundamentalMatrixComputeAndKeepInliers = fundamentalMatrixComputeAndKeepInliers;</span>
        //noinspection unchecked
<span class="fc" id="L1029">        return (T) this;</span>
    }

    /**
     * Indicates whether residuals must be computed and kept during robust fundamental
     * matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @return true if residuals must be computed and kept, false otherwise.
     */
    public boolean getFundamentalMatrixComputeAndKeepResiduals() {
<span class="fc" id="L1040">        return fundamentalMatrixComputeAndKeepResiduals;</span>
    }

    /**
     * Specifies whether residuals must be computed and kept during robust fundamental
     * matrix estimation.
     * This is only used when general scenes are allowed.
     *
     * @param fundamentalMatrixComputeAndKeepResiduals true if residuals must be
     *                                                 computed and kept, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setFundamentalMatrixComputeAndKeepResiduals(final boolean fundamentalMatrixComputeAndKeepResiduals) {
<span class="fc" id="L1053">        this.fundamentalMatrixComputeAndKeepResiduals = fundamentalMatrixComputeAndKeepResiduals;</span>
        //noinspection unchecked
<span class="fc" id="L1055">        return (T) this;</span>
    }

    /**
     * Gets method to use for initial cameras' estimation.
     *
     * @return method to use for initial cameras' estimation.
     */
    public InitialCamerasEstimatorMethod getInitialCamerasEstimatorMethod() {
<span class="fc" id="L1064">        return initialCamerasEstimatorMethod;</span>
    }

    /**
     * Sets method to use for initial cameras' estimation.
     *
     * @param method method to use for initial cameras' estimation.
     * @return this instance so that method can be easily chained.
     */
    public T setInitialCamerasEstimatorMethod(final InitialCamerasEstimatorMethod method) {
<span class="fc" id="L1074">        initialCamerasEstimatorMethod = method;</span>
        //noinspection unchecked
<span class="fc" id="L1076">        return (T) this;</span>
    }

    /**
     * Indicates whether an homogeneous point triangulator is used for point triangulation
     * when Dual Absolute Quadric (DAQ) camera initialization is used.
     *
     * @return true if homogeneous point triangulator is used, false if an inhomogeneous
     * point triangulator is used instead.
     */
    public boolean getDaqUseHomogeneousPointTriangulator() {
<span class="fc" id="L1087">        return daqUseHomogeneousPointTriangulator;</span>
    }

    /**
     * Specifies whether an homogeneous point triangulator is used for point
     * triangulation when Dual Absolute Quadric (DAQ) camera initialization is used.
     *
     * @param daqUseHomogeneousPointTriangulator true if homogeneous point triangulator
     *                                           is used, false if inhomogeneous point
     *                                           triangulator is used instead.
     * @return this instance so that method can be easily chained.
     */
    public T setDaqUseHomogeneousPointTriangulator(final boolean daqUseHomogeneousPointTriangulator) {
<span class="fc" id="L1100">        this.daqUseHomogeneousPointTriangulator = daqUseHomogeneousPointTriangulator;</span>
        //noinspection unchecked
<span class="fc" id="L1102">        return (T) this;</span>
    }

    /**
     * Gets aspect ratio for initial cameras estimation using DAQ or DIAC methods.
     *
     * @return aspect ratio for initial cameras using DAQ or DIAC methods.
     */
    public double getInitialCamerasAspectRatio() {
<span class="fc" id="L1111">        return initialCamerasAspectRatio;</span>
    }

    /**
     * Sets aspect ratio for initial cameras using DAQ or DIAC methods.
     *
     * @param initialCamerasAspectRatio aspect ratio for initial cameras using DAQ or DIAC
     *                                  methods.
     * @return this instance so that method can be easily chained.
     */
    public T setInitialCamerasAspectRatio(final double initialCamerasAspectRatio) {
<span class="fc" id="L1122">        this.initialCamerasAspectRatio = initialCamerasAspectRatio;</span>
        //noinspection unchecked
<span class="fc" id="L1124">        return (T) this;</span>
    }

    /**
     * Gets horizontal principal point value to use for initial cameras estimation
     * using DIAC or DAQ methods.
     *
     * @return horizontal principal point value to use for initial cameras estimation
     * using DIAC or DAQ methods.
     */
    public double getPrincipalPointX() {
<span class="fc" id="L1135">        return principalPointX;</span>
    }

    /**
     * Sets horizontal principal point value to use for initial cameras estimation
     * using DIAC or DAQ methods.
     *
     * @param principalPointX horizontal principal point value to use for initial
     *                        cameras estimation using DIAC or DAQ methods.
     * @return this instance so that method can be easily chained.
     */
    public T setPrincipalPointX(final double principalPointX) {
<span class="fc" id="L1147">        this.principalPointX = principalPointX;</span>
        //noinspection unchecked
<span class="fc" id="L1149">        return (T) this;</span>
    }

    /**
     * Gets vertical principal point value to use for initial cameras estimation
     * using DIAC or DAQ methods.
     *
     * @return vertical principal point value to use for initial cameras
     * estimation using DIAC or DAQ methods.
     */
    public double getPrincipalPointY() {
<span class="fc" id="L1160">        return principalPointY;</span>
    }

    /**
     * Sets vertical principal point value to use for initial cameras estimation using
     * DIAC or DAQ methods.
     *
     * @param principalPointY vertical principal point value to use for initial cameras
     *                        estimation using DIAC or DAQ methods.
     * @return this instance so that method can be easily chained.
     */
    public T setPrincipalPointY(final double principalPointY) {
<span class="fc" id="L1172">        this.principalPointY = principalPointY;</span>
        //noinspection unchecked
<span class="fc" id="L1174">        return (T) this;</span>
    }

    /**
     * Gets corrector type to use for point triangulation when initial cameras are being
     * estimated using either DIAC or essential matrix methods or null if no corrector is
     * used.
     *
     * @return corrector type to use for point triangulation when initial cameras are
     * being estimated using either DIAC or essential matrix methods or null if no
     * corrector is used.
     */
    public CorrectorType getInitialCamerasCorrectorType() {
<span class="fc" id="L1187">        return initialCamerasCorrectorType;</span>
    }

    /**
     * Sets corrector type to use for point triangulation when initial cameras are being
     * estimated using either DIAC or essential matrix methods or null if no corrector
     * is used.
     *
     * @param type corrector type to use for point triangulation when initial cameras
     *             are being estimated using either DIAC or essential matrix methods
     *             or null if no corrector is used.
     * @return this instance so that method can be easily chained.
     */
    public T setInitialCamerasCorrectorType(final CorrectorType type) {
<span class="fc" id="L1201">        initialCamerasCorrectorType = type;</span>
        //noinspection unchecked
<span class="fc" id="L1203">        return (T) this;</span>
    }

    /**
     * Gets value indicating whether valid triangulated points are marked during initial
     * cameras estimation using either DIAC or essential matrix methods.
     *
     * @return value indicating whether valid triangulated points are marked during
     * initial cameras estimation using either DIAC or essential matrix methods.
     */
    public boolean getInitialCamerasMarkValidTriangulatedPoints() {
<span class="fc" id="L1214">        return initialCamerasMarkValidTriangulatedPoints;</span>
    }

    /**
     * Sets value indicating whether valid triangulated points are marked during initial
     * cameras estimation using either DIAC or essential matrix methods.
     *
     * @param initialCamerasMarkValidTriangulatedPoints value indicating whether valid
     *                                                  triangulated points are marked during
     *                                                  initial cameras estimation using
     *                                                  either DIAC or essential matrix
     *                                                  methods.
     * @return this instance so that method can be easily chained.
     */
    public T setInitialCamerasMarkValidTriangulatedPoints(final boolean initialCamerasMarkValidTriangulatedPoints) {
<span class="fc" id="L1229">        this.initialCamerasMarkValidTriangulatedPoints = initialCamerasMarkValidTriangulatedPoints;</span>
        //noinspection unchecked
<span class="fc" id="L1231">        return (T) this;</span>
    }

    /**
     * Intrinsic parameters of first camera estimated using the essential matrix method.
     *
     * @return parameters of first camera estimated using the essential matrix method.
     */
    public PinholeCameraIntrinsicParameters getInitialIntrinsic1() {
<span class="fc" id="L1240">        return initialIntrinsic1;</span>
    }

    /**
     * Sets intrinsic parameters of first camera estimated using the essential matrix
     * method.
     *
     * @param initialIntrinsic1 parameters of first camera estimated using the essential
     *                          matrix method.
     * @return this instance so that method can be easily chained.
     */
    public T setInitialIntrinsic1(final PinholeCameraIntrinsicParameters initialIntrinsic1) {
<span class="fc" id="L1252">        this.initialIntrinsic1 = initialIntrinsic1;</span>
        //noinspection unchecked
<span class="fc" id="L1254">        return (T) this;</span>
    }

    /**
     * Intrinsic parameters of second camera estimated using the essential matrix method.
     *
     * @return parameters of second camera estimated using the essential matrix method.
     */
    public PinholeCameraIntrinsicParameters getInitialIntrinsic2() {
<span class="fc" id="L1263">        return initialIntrinsic2;</span>
    }

    /**
     * Sets intrinsic parameters of second camera estimated using the essential matrix
     * method.
     *
     * @param initialIntrinsic2 parameters of second camera estimated using the essential
     *                          matrix method.
     * @return this instance so that method can be easily chained.
     */
    public T setInitialIntrinsic2(final PinholeCameraIntrinsicParameters initialIntrinsic2) {
<span class="fc" id="L1275">        this.initialIntrinsic2 = initialIntrinsic2;</span>
        //noinspection unchecked
<span class="fc" id="L1277">        return (T) this;</span>
    }

    /**
     * Indicates whether a general scene (points laying in a general 3D position) is
     * allowed.
     * When true, an initial geometry estimation is attempted for general points.
     *
     * @return true if general scene is allowed, false otherwise.
     */
    public boolean isGeneralSceneAllowed() {
<span class="fc" id="L1288">        return allowGeneralScene;</span>
    }

    /**
     * Specifies whether a general scene (points laying in a general 3D position) is
     * allowed.
     * When true, an initial geometry estimation is attempted for general points.
     *
     * @param allowGeneralScene true if general scene is allowed, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setGeneralSceneAllowed(final boolean allowGeneralScene) {
<span class="fc" id="L1300">        this.allowGeneralScene = allowGeneralScene;</span>
        //noinspection unchecked
<span class="fc" id="L1302">        return (T) this;</span>
    }

    /**
     * Indicates whether a planar scene (points laying in a 3D plane) is allowed or not.
     * When true, an initial geometry estimation is attempted for planar points.
     *
     * @return true if planar scene is allowed, false otherwise.
     */
    public boolean isPlanarSceneAllowed() {
<span class="fc" id="L1312">        return allowPlanarScene;</span>
    }

    /**
     * Specifies whether a planar scene (points laying in a 3D plane) is allowed or not.
     * When true, an initial geometry estimation is attempted for planar points.
     *
     * @param allowPlanarScene true if planar scene is allowed, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarSceneAllowed(final boolean allowPlanarScene) {
<span class="fc" id="L1323">        this.allowPlanarScene = allowPlanarScene;</span>
        //noinspection unchecked
<span class="fc" id="L1325">        return (T) this;</span>
    }

    /**
     * Gets robust method to use for planar homography estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return robust method to use for planar homography estimation.
     */
    public RobustEstimatorMethod getRobustPlanarHomographyEstimatorMethod() {
<span class="fc" id="L1335">        return robustPlanarHomographyEstimatorMethod;</span>
    }

    /**
     * Sets robust method to use for planar homography estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param robustPlanarHomographyEstimatorMethod robust method to use for planar
     *                                              homography estimation.
     * @return this instance so that method can be easily chained.
     */
    public T setRobustPlanarHomographyEstimatorMethod(
            final RobustEstimatorMethod robustPlanarHomographyEstimatorMethod) {
<span class="fc" id="L1348">        this.robustPlanarHomographyEstimatorMethod = robustPlanarHomographyEstimatorMethod;</span>
        //noinspection unchecked
<span class="fc" id="L1350">        return (T) this;</span>
    }

    /**
     * Indicates whether planar homography is refined using all found inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @return true if planar homography is refined, false otherwise.
     */
    public boolean isPlanarHomographyRefined() {
<span class="fc" id="L1360">        return refinePlanarHomography;</span>
    }

    /**
     * Specifies whether planar homography is refined using all found inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @param refinePlanarHomography true if planar homography must be refined, false
     *                               otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyRefined(final boolean refinePlanarHomography) {
<span class="fc" id="L1372">        this.refinePlanarHomography = refinePlanarHomography;</span>
        //noinspection unchecked
<span class="fc" id="L1374">        return (T) this;</span>
    }

    /**
     * Indicates whether planar homography covariance is kept after estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return true if planar homography covariance is kept, false otherwise.
     */
    public boolean isPlanarHomographyCovarianceKept() {
<span class="fc" id="L1384">        return keepPlanarHomographyCovariance;</span>
    }

    /**
     * Specifies whether planar homography covariance is kept after estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param keepPlanarHomographyCovariance true if planar homography covariance is
     *                                       kept, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyCovarianceKept(final boolean keepPlanarHomographyCovariance) {
<span class="fc" id="L1396">        this.keepPlanarHomographyCovariance = keepPlanarHomographyCovariance;</span>
        //noinspection unchecked
<span class="fc" id="L1398">        return (T) this;</span>
    }

    /**
     * Gets confidence of robustly estimated planar homography. By default, this is 99%.
     * This is only used when planar scenes are allowed.
     *
     * @return confidence of robustly estimated planar homography.
     */
    public double getPlanarHomographyConfidence() {
<span class="fc" id="L1408">        return planarHomographyConfidence;</span>
    }

    /**
     * Sets confidence of robustly estimated planar homography. By default, this is 99%.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyConfidence confidence of robustly estimated planar
     *                                   homography.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyConfidence(final double planarHomographyConfidence) {
<span class="fc" id="L1420">        this.planarHomographyConfidence = planarHomographyConfidence;</span>
        //noinspection unchecked
<span class="fc" id="L1422">        return (T) this;</span>
    }

    /**
     * Gets maximum number of iterations to make while robustly estimating planar
     * homography. By default, this is 5000.
     * This is only used when planar scenes are allowed.
     *
     * @return maximum number of iterations to make while robustly estimating planar
     * homography.
     */
    public int getPlanarHomographyMaxIterations() {
<span class="fc" id="L1434">        return planarHomographyMaxIterations;</span>
    }

    /**
     * Sets maximum number of iterations to make while robustly estimating planar
     * homography. By default, this is 5000.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyMaxIterations maximum number of iterations to make while
     *                                      robustly estimating planar homography.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyMaxIterations(final int planarHomographyMaxIterations) {
<span class="fc" id="L1447">        this.planarHomographyMaxIterations = planarHomographyMaxIterations;</span>
        //noinspection unchecked
<span class="fc" id="L1449">        return (T) this;</span>
    }

    /**
     * Gets threshold to determine whether samples for robust projective 2D
     * transformation estimation are inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @return threshold to robustly estimate projective 2D transformation.
     */
    public double getPlanarHomographyThreshold() {
<span class="fc" id="L1460">        return planarHomographyThreshold;</span>
    }

    /**
     * Sets threshold to determine whether samples for robust projective 2D
     * transformation estimation are inliers or not.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyThreshold threshold to robustly estimate projective 2D
     *                                  transformation.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyThreshold(final double planarHomographyThreshold) {
<span class="fc" id="L1473">        this.planarHomographyThreshold = planarHomographyThreshold;</span>
        //noinspection unchecked
<span class="fc" id="L1475">        return (T) this;</span>
    }

    /**
     * Gets value indicating that inlier data is kept after robust planar homography
     * estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return true if inlier data is kept, false otherwise.
     */
    public boolean getPlanarHomographyComputeAndKeepInliers() {
<span class="fc" id="L1486">        return planarHomographyComputeAndKeepInliers;</span>
    }

    /**
     * Specifies whether inlier data is kept after robust planar homography estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyComputeAndKeepInliers true if inlier data is kept, false
     *                                              otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyComputeAndKeepInliers(final boolean planarHomographyComputeAndKeepInliers) {
<span class="fc" id="L1498">        this.planarHomographyComputeAndKeepInliers = planarHomographyComputeAndKeepInliers;</span>
        //noinspection unchecked
<span class="fc" id="L1500">        return (T) this;</span>
    }

    /**
     * Gets value indicating that residual data is kept after robust planar homography
     * estimation.
     * This is only used when planar scenes are allowed.
     *
     * @return true if residual data is kept, false otherwise.
     */
    public boolean getPlanarHomographyComputeAndKeepResiduals() {
<span class="fc" id="L1511">        return planarHomographyComputeAndKeepResiduals;</span>
    }

    /**
     * Sets value indicating that residual data is kept after robust planar homography
     * estimation.
     * This is only used when planar scenes are allowed.
     *
     * @param planarHomographyComputeAndKeepResiduals true if residual data is kept,
     *                                                false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setPlanarHomographyComputeAndKeepResiduals(final boolean planarHomographyComputeAndKeepResiduals) {
<span class="fc" id="L1524">        this.planarHomographyComputeAndKeepResiduals = planarHomographyComputeAndKeepResiduals;</span>
        //noinspection unchecked
<span class="fc" id="L1526">        return (T) this;</span>
    }

    /**
     * Indicates that additional cameras intrinsics are estimated using the Dual Absolute
     * Quadric (DAQ).
     *
     * @return true if additional cameras intrinsics are estimated using the Dual Absolute
     * Quadric (DAQ), false otherwise.
     */
    public boolean getUseDAQForAdditionalCamerasIntrinsics() {
<span class="fc" id="L1537">        return useDAQForAdditionalCamerasIntrinsics;</span>
    }

    /**
     * Specifies whether additional cameras intrinsics are estimated using the Dual Absolute
     * Quadric (DAQ).
     *
     * @param useDAQForAdditionalCamerasIntrinics true if additional cameras intrinsics
     *                                            are estimated using the Dual Absolute
     *                                            Quadric (DAQ), false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setUseDAQForAdditionalCamerasIntrinics(final boolean useDAQForAdditionalCamerasIntrinics) {
<span class="fc" id="L1550">        useDAQForAdditionalCamerasIntrinsics = useDAQForAdditionalCamerasIntrinics;</span>
        //noinspection unchecked
<span class="fc" id="L1552">        return (T) this;</span>
    }

    /**
     * Indicates that additional cameras intrinsics are estimated using the Dual Image of Absolute
     * Conic (DIAC).
     *
     * @return true if additional cameras intrinsics are estimated using the Dual Image of Absolute Conic
     * (DIAC), false otherwise.
     */
    public boolean getUseDIACForAdditionalCamerasIntrinsics() {
<span class="fc" id="L1563">        return useDIACForAdditionalCamerasIntrinsics;</span>
    }

    /**
     * Specifies whether additional cameras intrinsics are estimated using the Dual Image of
     * Absolute Conic (DIAC).
     * It is not recommended to enable this setting as it has low accuracy.
     *
     * @param useDIACForAdditionalCamerasIntrinsics true if additional cameras intrinsics are
     *                                              estimated using the Dual Image of Absolute
     *                                              Conic (DIAC), false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setUseDIACForAdditionalCamerasIntrinsics(final boolean useDIACForAdditionalCamerasIntrinsics) {
<span class="fc" id="L1577">        this.useDIACForAdditionalCamerasIntrinsics = useDIACForAdditionalCamerasIntrinsics;</span>
        //noinspection unchecked
<span class="fc" id="L1579">        return (T) this;</span>
    }

    /**
     * Gets intrinsic parameters to use for additional cameras estimation when neither
     * Dual Image of Absolute Conic (DIAC) nor Dual Absolute Quadric (DAQ) are used for
     * estimation of intrinsic parameters.
     *
     * @return intrinsic parameters to use for additional estimation of cameras.
     */
    public PinholeCameraIntrinsicParameters getAdditionalCamerasIntrinsics() {
<span class="fc" id="L1590">        return additionalCamerasIntrinsics;</span>
    }

    /**
     * Sets intrinsic parameters to use for additional cameras estimation when neither
     * Dual Image of Absolute Conic (DIAC) nor Dual Absolute Quadric (DAQ) are used for
     * estimation of intrinsic parameters.
     *
     * @param additionalCamerasIntrinsics intrinsic parameters to use for additional
     *                                    estimation of cameras.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasIntrinsics(final PinholeCameraIntrinsicParameters additionalCamerasIntrinsics) {
<span class="fc" id="L1603">        this.additionalCamerasIntrinsics = additionalCamerasIntrinsics;</span>
        //noinspection unchecked
<span class="fc" id="L1605">        return (T) this;</span>
    }

    /**
     * Gets skewness for additional cameras when UPnP (Uncalibrated Perspective-n-Point)
     * method is used for additional estimation of cameras.
     *
     * @return skewness for additional cameras when UPnP method is used for additional
     * estimation of cameras.
     */
    public double getAdditionalCamerasSkewness() {
<span class="fc" id="L1616">        return additionalCamerasSkewness;</span>
    }

    /**
     * Sets skewness for additional cameras when UPnP (Uncalibrated Perspective-n-Point)
     * method is used for additional estimation of cameras.
     *
     * @param additionalCamerasSkewness skewness for additional cameras when UPnP method is
     *                                  used for additional estimation of cameras.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasSkewness(final double additionalCamerasSkewness) {
<span class="fc" id="L1628">        this.additionalCamerasSkewness = additionalCamerasSkewness;</span>
        //noinspection unchecked
<span class="fc" id="L1630">        return (T) this;</span>
    }

    /**
     * Gets horizontal coordinate of principal point for additional cameras when UPnP
     * (Uncalibrated Perspective-n-Point) method is used for additional cameras
     * estimation and neither Dual Image of Absolute Conic (DIAC) or Dual Absolute
     * Quadric (DAQ) are estimated to find intrinsic parameters when adding new cameras.
     *
     * @return horizontal coordinate of principal point for additional cameras when
     * UPnP method is used for additional cameras estimation and neither DIAC nor DAQ
     * are estimated to find intrinsic parameters when adding new cameras.
     */
    public double getAdditionalCamerasHorizontalPrincipalPoint() {
<span class="fc" id="L1644">        return additionalCamerasHorizontalPrincipalPoint;</span>
    }

    /**
     * Sets horizontal coordinate of principal point for additional cameras when UPnP
     * (Uncalibrated Perspective-n-Point) method is used for additional cameras estimation
     * and neither Dual Image of Absolute Conic (DIAC) or Dual Absolute Quadric (DAQ) are
     * estimated to find intrinsic parameters when adding new cameras.
     *
     * @param additionalCamerasHorizontalPrincipalPoint horizontal coordinate of principal point
     *                                                  for additional cameras when UPnP method is
     *                                                  used for additional cameras estimation and
     *                                                  neither DIAC nor DAQ are estimated to find
     *                                                  intrinsic parameters when adding new cameras.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasHorizontalPrincipalPoint(final double additionalCamerasHorizontalPrincipalPoint) {
<span class="fc" id="L1661">        this.additionalCamerasHorizontalPrincipalPoint = additionalCamerasHorizontalPrincipalPoint;</span>
        //noinspection unchecked
<span class="fc" id="L1663">        return (T) this;</span>
    }

    /**
     * Gets vertical coordinate of principal point for additional cameras when UPnP
     * (Uncalibrated Perspective-n-Point) method is used for additional cameras estimation
     * and neither Dual Image of Absolute Conic (DIAC) or Dual Absolute Quadric (DAQ) are
     * estimated to find intrinsic parameters when adding new cameras.
     *
     * @return vertical coordinate of principal point for additional cameras when UPnP
     * method is used for additional cameras estimation and neither DIAC nor DAQ are
     * estimated to find intrinsic parameters when adding new cameras.
     */
    public double getAdditionalCamerasVerticalPrincipalPoint() {
<span class="fc" id="L1677">        return additionalCamerasVerticalPrincipalPoint;</span>
    }

    /**
     * Sets vertical coordinate of principal point for additional cameras when UPnP
     * (Uncalibrated Perspective-n-Point) method is used for additional cameras
     * estimation and neither Dual Image of Absolute Conic (DIAC) or Dual Absolute Quadric
     * (DAQ) are estimated to find intrinsic parameters when adding new cameras.
     *
     * @param additionalCamerasVerticalPrincipalPoint vertical coordinate of principal
     *                                                point for additional cameras when UPnP
     *                                                method is used for additional cameras
     *                                                estimation and neither DIAC nor DAQ
     *                                                are estimated to find intrinsic
     *                                                parameters when adding new cameras.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasVerticalPrincipalPoint(final double additionalCamerasVerticalPrincipalPoint) {
<span class="fc" id="L1695">        this.additionalCamerasVerticalPrincipalPoint = additionalCamerasVerticalPrincipalPoint;</span>
        //noinspection unchecked
<span class="fc" id="L1697">        return (T) this;</span>
    }

    /**
     * Gets aspect ratio for additional cameras estimation using DAQ or DIAC methods.
     *
     * @return aspect ratio for additional cameras using DAQ or DIAC methods.
     */
    public double getAdditionalCamerasAspectRatio() {
<span class="fc" id="L1706">        return additionalCamerasAspectRatio;</span>
    }

    /**
     * Sets aspect ratio for additional cameras using DAQ or DIAC methods.
     *
     * @param additionalCamerasAspectRatio aspect ratio for additional cameras using DAQ or DIAC
     *                                     methods.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasAspectRatio(final double additionalCamerasAspectRatio) {
<span class="fc" id="L1717">        this.additionalCamerasAspectRatio = additionalCamerasAspectRatio;</span>
        //noinspection unchecked
<span class="fc" id="L1719">        return (T) this;</span>
    }

    /**
     * Indicates whether EPnP (Efficient Perspective-n-Point) method is used for additional
     * estimation of cameras. Either EPnP or UPnP must be used for additional estimation
     * of cameras.
     *
     * @return true if EPnP method is used for additional cameras estimation, false
     * otherwise.
     */
    public boolean getUseEPnPForAdditionalCamerasEstimation() {
<span class="fc" id="L1731">        return useEPnPForAdditionalCamerasEstimation;</span>
    }

    /**
     * Specifies whether EPnP (Efficient Perspective-n-Point) method is used for additional
     * estimation of cameras. Either EPnP or UPnP must be used for additional estimation of cameras.
     *
     * @param useEPnPForAdditionalCamerasEstimation true if EPnP method is used for additional
     *                                              cameras estimation, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setUseEPnPForAdditionalCamerasEstimation(final boolean useEPnPForAdditionalCamerasEstimation) {
<span class="fc" id="L1743">        this.useEPnPForAdditionalCamerasEstimation = useEPnPForAdditionalCamerasEstimation;</span>
        //noinspection unchecked
<span class="fc" id="L1745">        return (T) this;</span>
    }

    /**
     * Indicates whether UPnP (Uncalibrated Perspective-n-Point) method is used for
     * additional estimation of cameras. Either EPnP or UPnP must be used for additional
     * estimation of cameras.
     *
     * @return true if UPnP method is used for additional cameras estimation, false
     * otherwise.
     */
    public boolean getUseUPnPForAdditionalCamerasEstimation() {
<span class="fc" id="L1757">        return useUPnPForAdditionalCamerasEstimation;</span>
    }

    /**
     * Specifies whether UPnP (Uncalibrated Perspective-n-Point) method is used for
     * additional estimation of cameras. Either EPnP or UPnP must be used for additional
     * estimation of cameras.
     *
     * @param useUPnPForAdditionalCamerasEstimation true if UPnP method is used for
     *                                              additional cameras estimation, false
     *                                              otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setUseUPnPForAdditionalCamerasEstimation(final boolean useUPnPForAdditionalCamerasEstimation) {
<span class="fc" id="L1771">        this.useUPnPForAdditionalCamerasEstimation = useUPnPForAdditionalCamerasEstimation;</span>
        //noinspection unchecked
<span class="fc" id="L1773">        return (T) this;</span>
    }

    /**
     * Gets robust method to estimate additional cameras.
     *
     * @return robust method to estimate additional cameras.
     */
    public RobustEstimatorMethod getAdditionalCamerasRobustEstimationMethod() {
<span class="fc" id="L1782">        return additionalCamerasRobustEstimationMethod;</span>
    }

    /**
     * Sets robust method to estimate additional cameras.
     *
     * @param method robust method to estimate additional cameras.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasRobustEstimationMethod(final RobustEstimatorMethod method) {
<span class="fc" id="L1792">        additionalCamerasRobustEstimationMethod = method;</span>
        //noinspection unchecked
<span class="fc" id="L1794">        return (T) this;</span>
    }

    /**
     * Indicates whether planar configuration is allowed for additional cameras
     * estimation using either EPnP or UPnP.
     *
     * @return true if planar configuration is allowed, false otherwise.
     */
    public boolean getAdditionalCamerasAllowPlanarConfiguration() {
<span class="fc" id="L1804">        return additionalCamerasAllowPlanarConfiguration;</span>
    }

    /**
     * Specifies whether planar configuration is allowed for additional cameras
     * estimation using either EPnP or UPnP.
     *
     * @param allowPlanarConfiguration true if planar configuration is allowed, false
     *                                 otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasAllowPlanarConfiguration(final boolean allowPlanarConfiguration) {
<span class="fc" id="L1816">        additionalCamerasAllowPlanarConfiguration = allowPlanarConfiguration;</span>
        //noinspection unchecked
<span class="fc" id="L1818">        return (T) this;</span>
    }

    /**
     * Indicates whether dimension 2 null-space is allowed while estimating additional
     * cameras using either EPnP or UPnP.
     *
     * @return true if dimension 2 null-space is allowed while estimating additional
     * cameras, false otherwise.
     */
    public boolean getAdditionalCamerasAllowNullspaceDimension2() {
<span class="fc" id="L1829">        return additionalCamerasAllowNullspaceDimension2;</span>
    }

    /**
     * Specifies whether dimension 2 null-space is allowed while estimating additional
     * cameras using either EPnP or UPnP.
     *
     * @param allowNullspaceDimension2 true if dimension 2 null-space is allowed while
     *                                 estimating additional cameras, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasAllowNullspaceDimension2(final boolean allowNullspaceDimension2) {
<span class="fc" id="L1841">        additionalCamerasAllowNullspaceDimension2 = allowNullspaceDimension2;</span>
        //noinspection unchecked
<span class="fc" id="L1843">        return (T) this;</span>
    }

    /**
     * Indicates whether dimension 3 null-space is allowed while estimating additional
     * cameras using EPnP.
     *
     * @return true if dimension 3 null-space is allowed while estimating additional
     * cameras, false otherwise.
     */
    public boolean getAdditionalCamerasAllowNullspaceDimension3() {
<span class="fc" id="L1854">        return additionalCamerasAllowNullspaceDimension3;</span>
    }

    /**
     * Specifies whether dimension 3 null-space is allowed while estimating additional
     * cameras using either EPnP or UPnP.
     *
     * @param allowNullspaceDimension3 true if dimension 3 null-space is allowed while
     *                                 estimating additional cameras, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasAllowNullspaceDimension3(final boolean allowNullspaceDimension3) {
<span class="fc" id="L1866">        additionalCamerasAllowNullspaceDimension3 = allowNullspaceDimension3;</span>
        //noinspection unchecked
<span class="fc" id="L1868">        return (T) this;</span>
    }

    /**
     * Gets threshold to determine whether 3D matched points to estimate additional
     * cameras are in a planar configuration.
     *
     * @return threshold to determine whether 3D matched points to estimate additional
     * cameras are in a planar configuration.
     */
    public double getAdditionalCamerasPlanarThreshold() {
<span class="fc" id="L1879">        return additionalCamerasPlanarThreshold;</span>
    }

    /**
     * Specifies threshold to determine whether 3D matched points to estimate additional
     * cameras are in a planar configuration.
     *
     * @param additionalCamerasPlanarThreshold threshold to determine whether 3D matched
     *                                         points to estimate additional cameras are
     *                                         in a planar configuration.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasPlanarThreshold(final double additionalCamerasPlanarThreshold) {
<span class="fc" id="L1892">        this.additionalCamerasPlanarThreshold = additionalCamerasPlanarThreshold;</span>
        //noinspection unchecked
<span class="fc" id="L1894">        return (T) this;</span>
    }

    /**
     * Indicates whether additional cameras are refined to minimize overall projection
     * error among all found inliers.
     *
     * @return true if additional cameras are refined, false otherwise.
     */
    public boolean areAdditionalCamerasRefined() {
<span class="fc" id="L1904">        return refineAdditionalCameras;</span>
    }

    /**
     * Specifies whether additional cameras are refined to minimize overall projection
     * error among all found inliers.
     *
     * @param refineAdditionalCameras true if additional cameras are refined, false
     *                                otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasRefined(final boolean refineAdditionalCameras) {
<span class="fc" id="L1916">        this.refineAdditionalCameras = refineAdditionalCameras;</span>
        //noinspection unchecked
<span class="fc" id="L1918">        return (T) this;</span>
    }

    /**
     * Indicates whether covariance is kept after refining result of additional
     * estimation of cameras.
     *
     * @return true if covariance is kept, false otherwise.
     */
    public boolean isAdditionalCamerasCovarianceKept() {
<span class="fc" id="L1928">        return keepCovarianceAdditionalCameras;</span>
    }

    /**
     * Specifies whether covariance is kept after refining result of additional estimation
     * of cameras.
     *
     * @param keepCovarianceAdditionalCameras true if covariance is kept, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasCovarianceKept(final boolean keepCovarianceAdditionalCameras) {
<span class="fc" id="L1939">        this.keepCovarianceAdditionalCameras = keepCovarianceAdditionalCameras;</span>
        //noinspection unchecked
<span class="fc" id="L1941">        return (T) this;</span>
    }

    /**
     * Gets value indicating whether fast refinement is used for additional estimation
     * of cameras.
     *
     * @return true if fast refinement is used for additional cameras estimation,
     * false otherwise.
     */
    public boolean getAdditionalCamerasUseFastRefinement() {
<span class="fc" id="L1952">        return additionalCamerasUseFastRefinement;</span>
    }

    /**
     * Sets value indicating whether fast refinement is used for additional estimation
     * of cameras.
     *
     * @param additionalCamerasUseFastRefinement true if fast refinement is used for
     *                                           additional cameras estimation, false
     *                                           otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasUseFastRefinement(final boolean additionalCamerasUseFastRefinement) {
<span class="fc" id="L1965">        this.additionalCamerasUseFastRefinement = additionalCamerasUseFastRefinement;</span>
        //noinspection unchecked
<span class="fc" id="L1967">        return (T) this;</span>
    }

    /**
     * Gets confidence of estimated additional cameras.
     *
     * @return confidence of estimated additional cameras.
     */
    public double getAdditionalCamerasConfidence() {
<span class="fc" id="L1976">        return additionalCamerasConfidence;</span>
    }

    /**
     * Sets confidence of estimated additional cameras.
     *
     * @param additionalCamerasConfidence confidence of estimated additional cameras.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasConfidence(final double additionalCamerasConfidence) {
<span class="fc" id="L1986">        this.additionalCamerasConfidence = additionalCamerasConfidence;</span>
        //noinspection unchecked
<span class="fc" id="L1988">        return (T) this;</span>
    }

    /**
     * Gets maximum allowed number of iterations for additional cameras estimation.
     *
     * @return maximum allowed number of iterations for additional cameras estimation.
     */
    public int getAdditionalCamerasMaxIterations() {
<span class="fc" id="L1997">        return additionalCamerasMaxIterations;</span>
    }

    /**
     * Sets maximum allowed number of iterations for additional cameras estimation.
     *
     * @param additionalCamerasMaxIterations maximum allowed number of iterations for
     *                                       additional cameras estimation.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasMaxIterations(final int additionalCamerasMaxIterations) {
<span class="fc" id="L2008">        this.additionalCamerasMaxIterations = additionalCamerasMaxIterations;</span>
        //noinspection unchecked
<span class="fc" id="L2010">        return (T) this;</span>
    }

    /**
     * Gets threshold to determine whether samples for robust pinhole camera estimation are inliers or not.
     *
     * @return threshold to determine whether samples for robust pinhole camera estimation are inliers or
     * not.
     */
    public double getAdditionalCamerasThreshold() {
<span class="fc" id="L2020">        return additionalCamerasThreshold;</span>
    }

    /**
     * Sets threshold to determine whether samples for robust pinhole camera estimation are inliers or not.
     *
     * @param additionalCamerasThreshold threshold to determine whether samples for robust pinhole camera
     *                                   estimation are inliers or not.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasThreshold(final double additionalCamerasThreshold) {
<span class="fc" id="L2031">        this.additionalCamerasThreshold = additionalCamerasThreshold;</span>
        //noinspection unchecked
<span class="fc" id="L2033">        return (T) this;</span>
    }

    /**
     * Indicates whether inliers must be kept during additional camera estimation.
     *
     * @return true if inliers must be kept during additional camera estimation, false
     * otherwise.
     */
    public boolean getAdditionalCamerasComputeAndKeepInliers() {
<span class="fc" id="L2043">        return additionalCamerasComputeAndKeepInliers;</span>
    }

    /**
     * Specifies whether inliers must be kept during additional camera estimation.
     *
     * @param additionalCamerasComputeAndKeepInliers true if inliers must be kept during additional camera
     *                                               estimation, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasComputeAndKeepInliers(final boolean additionalCamerasComputeAndKeepInliers) {
<span class="fc" id="L2054">        this.additionalCamerasComputeAndKeepInliers = additionalCamerasComputeAndKeepInliers;</span>
        //noinspection unchecked
<span class="fc" id="L2056">        return (T) this;</span>
    }

    /**
     * Indicates whether residuals must be computed and kept during additional camera estimation.
     *
     * @return true if residuals must be computed and kept, false otherwise.
     */
    public boolean getAdditionalCamerasComputeAndKeepResiduals() {
<span class="fc" id="L2065">        return additionalCamerasComputeAndKeepResiduals;</span>
    }

    /**
     * Specifies whether residuals must be computed and kept during additional camera estimation.
     *
     * @param additionalCamerasComputeAndKeepResiduals true if residuals must be computed and kept, false
     *                                                 otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasComputeAndKeepResiduals(final boolean additionalCamerasComputeAndKeepResiduals) {
<span class="fc" id="L2076">        this.additionalCamerasComputeAndKeepResiduals = additionalCamerasComputeAndKeepResiduals;</span>
        //noinspection unchecked
<span class="fc" id="L2078">        return (T) this;</span>
    }

    /**
     * Gets value indicating whether skewness is not suggested during additional
     * estimation of cameras.
     *
     * @return true if skewness is suggested, false otherwise.
     */
    public boolean isAdditionalCamerasSuggestSkewnessValueEnabled() {
<span class="fc" id="L2088">        return additionalCamerasSuggestSkewnessValueEnabled;</span>
    }

    /**
     * Sets value indicating whether skewness is not suggested during additional
     * estimation of cameras.
     *
     * @param additionalCamerasSuggestSkewnessValueEnabled true if skewness is suggested,
     *                                                     false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasSuggestSkewnessValueEnabled(
            final boolean additionalCamerasSuggestSkewnessValueEnabled) {
<span class="fc" id="L2101">        this.additionalCamerasSuggestSkewnessValueEnabled = additionalCamerasSuggestSkewnessValueEnabled;</span>
        //noinspection unchecked
<span class="fc" id="L2103">        return (T) this;</span>
    }

    /**
     * Gets value of skewness to be suggested when suggestion is enabled during
     * additional estimation of cameras.
     *
     * @return value of skewness to be suggested when suggestion is enabled during
     * additional estimation of cameras.
     */
    public double getAdditionalCamerasSuggestedSkewnessValue() {
<span class="fc" id="L2114">        return additionalCamerasSuggestedSkewnessValue;</span>
    }

    /**
     * Sets value of skewness to be suggested when suggestion is enabled during additional
     * estimation of cameras.
     *
     * @param additionalCamerasSuggestedSkewnessValue value of skewness to be suggested
     *                                                when suggestion is enabled during
     *                                                additional estimation of cameras.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasSuggestedSkewnessValue(final double additionalCamerasSuggestedSkewnessValue) {
<span class="fc" id="L2127">        this.additionalCamerasSuggestedSkewnessValue = additionalCamerasSuggestedSkewnessValue;</span>
        //noinspection unchecked
<span class="fc" id="L2129">        return (T) this;</span>
    }

    /**
     * Indicates whether horizontal focal length value is suggested or not during
     * additional estimation of cameras.
     *
     * @return true if horizontal focal length value is suggested, false otherwise.
     */
    public boolean isAdditionalCamerasSuggestHorizontalFocalLengthEnabled() {
<span class="fc" id="L2139">        return additionalCamerasSuggestHorizontalFocalLengthEnabled;</span>
    }

    /**
     * Specifies whether horizontal focal length value is suggested or not during additional
     * estimation of cameras.
     *
     * @param additionalCamerasSuggestHorizontalFocalLengthEnabled true if horizontal focal
     *                                                             length value is suggested, false
     *                                                             otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasSuggestHorizontalFocalLengthEnabled(
            final boolean additionalCamerasSuggestHorizontalFocalLengthEnabled) {
<span class="fc" id="L2153">        this.additionalCamerasSuggestHorizontalFocalLengthEnabled =</span>
                additionalCamerasSuggestHorizontalFocalLengthEnabled;
        //noinspection unchecked
<span class="fc" id="L2156">        return (T) this;</span>
    }

    /**
     * Gets value of suggested horizontal focal length during additional estimation
     * of cameras.
     *
     * @return value of suggested horizontal focal length during additional estimation
     * of cameras.
     */
    public double getAdditionalCamerasSuggestedHorizontalFocalLengthValue() {
<span class="fc" id="L2167">        return additionalCamerasSuggestedHorizontalFocalLengthValue;</span>
    }

    /**
     * Sets value of suggested horizontal focal length during additional estimation
     * of cameras.
     *
     * @param additionalCamerasSuggestedHorizontalFocalLengthValue value of suggested
     *                                                             horizontal focal length during
     *                                                             additional estimation of cameras.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasSuggestedHorizontalFocalLengthValue(
            final double additionalCamerasSuggestedHorizontalFocalLengthValue) {
<span class="fc" id="L2181">        this.additionalCamerasSuggestedHorizontalFocalLengthValue =</span>
                additionalCamerasSuggestedHorizontalFocalLengthValue;
        //noinspection unchecked
<span class="fc" id="L2184">        return (T) this;</span>
    }

    /**
     * Gets value indicating whether vertical focal length value is suggested or not
     * during additional estimation of cameras.
     *
     * @return true if vertical focal length value is suggested, false otherwise.
     */
    public boolean isAdditionalCamerasSuggestVerticalFocalLengthEnabled() {
<span class="fc" id="L2194">        return additionalCamerasSuggestVerticalFocalLengthEnabled;</span>
    }

    /**
     * Sets value indicating whether vertical focal length value is suggested or not
     * during additional estimation of cameras.
     *
     * @param additionalCamerasSuggestVerticalFocalLengthEnabled true if vertical focal
     *                                                           length is suggested, false
     *                                                           otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasSuggestVerticalFocalLengthEnabled(
            final boolean additionalCamerasSuggestVerticalFocalLengthEnabled) {
<span class="fc" id="L2208">        this.additionalCamerasSuggestVerticalFocalLengthEnabled = additionalCamerasSuggestVerticalFocalLengthEnabled;</span>
        //noinspection unchecked
<span class="fc" id="L2210">        return (T) this;</span>
    }

    /**
     * Gets value of suggested vertical focal length during additional estimation of cameras.
     *
     * @return value of suggested vertical focal length during additional estimation of cameras.
     */
    public double getAdditionalCamerasSuggestedVerticalFocalLengthValue() {
<span class="fc" id="L2219">        return additionalCamerasSuggestedVerticalFocalLengthValue;</span>
    }

    /**
     * Sets value of suggested vertical focal length during additional estimation of cameras.
     *
     * @param additionalCamerasSuggestedVerticalFocalLengthValue value of suggested vertical
     *                                                           focal length during additional
     *                                                           estimation of cameras.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasSuggestedVerticalFocalLengthValue(
            final double additionalCamerasSuggestedVerticalFocalLengthValue) {
<span class="fc" id="L2232">        this.additionalCamerasSuggestedVerticalFocalLengthValue = additionalCamerasSuggestedVerticalFocalLengthValue;</span>
        //noinspection unchecked
<span class="fc" id="L2234">        return (T) this;</span>
    }

    /**
     * Gets value indicating whether aspect ratio is suggested or not during additional
     * estimation of cameras.
     *
     * @return true if aspect ratio is suggested, false otherwise.
     */
    public boolean isAdditionalCamerasSuggestAspectRatioEnabled() {
<span class="fc" id="L2244">        return additionalCamerasSuggestAspectRatioEnabled;</span>
    }

    /**
     * Sets value indicating whether aspect ratio is suggested or not during additional
     * estimation of cameras.
     *
     * @param additionalCamerasSuggestAspectRatioEnabled true if aspect ratio is suggested,
     *                                                   false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasSuggestAspectRatioEnabled(final boolean additionalCamerasSuggestAspectRatioEnabled) {
<span class="fc" id="L2256">        this.additionalCamerasSuggestAspectRatioEnabled = additionalCamerasSuggestAspectRatioEnabled;</span>
        //noinspection unchecked
<span class="fc" id="L2258">        return (T) this;</span>
    }

    /**
     * Gets value of aspect ratio to be suggested when suggestion is enabled during
     * additional estimation of cameras.
     *
     * @return value of aspect ratio to be suggested.
     */
    public double getAdditionalCamerasSuggestedAspectRatioValue() {
<span class="fc" id="L2268">        return additionalCamerasSuggestedAspectRatioValue;</span>
    }

    /**
     * Sets value of aspect ratio to be suggested when suggestion is enabled during
     * additional estimation of cameras.
     *
     * @param additionalCamerasSuggestedAspectRatioValue value of aspect ratio to be
     *                                                   suggested.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasSuggestedAspectRatioValue(final double additionalCamerasSuggestedAspectRatioValue) {
<span class="fc" id="L2280">        this.additionalCamerasSuggestedAspectRatioValue = additionalCamerasSuggestedAspectRatioValue;</span>
        //noinspection unchecked
<span class="fc" id="L2282">        return (T) this;</span>
    }

    /**
     * Gets value indicating whether principal point is suggested or not during
     * additional estimation of cameras.
     *
     * @return true if principal point is suggested, false otherwise.
     */
    public boolean isAdditionalCamerasSuggestPrincipalPointEnabled() {
<span class="fc" id="L2292">        return additionalCamerasSuggestPrincipalPointEnabled;</span>
    }

    /**
     * Sets value indicating whether principal point is suggested or not during additional
     * estimation of cameras.
     *
     * @param additionalCamerasSuggestPrincipalPointEnabled true if principal point is
     *                                                      suggested, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasSuggestPrincipalPointEnabled(
            final boolean additionalCamerasSuggestPrincipalPointEnabled) {
<span class="fc" id="L2305">        this.additionalCamerasSuggestPrincipalPointEnabled = additionalCamerasSuggestPrincipalPointEnabled;</span>
        //noinspection unchecked
<span class="fc" id="L2307">        return (T) this;</span>
    }

    /**
     * Gets value of principal point to be suggested when suggestion is enabled during
     * additional estimation of cameras.
     *
     * @return principal point to be suggested.
     */
    public InhomogeneousPoint2D getAdditionalCamerasSuggestedPrincipalPointValue() {
<span class="fc" id="L2317">        return additionalCamerasSuggestedPrincipalPointValue;</span>
    }

    /**
     * Sets value of principal point to be suggested when suggestion is enabled during
     * additional estimation of cameras.
     *
     * @param additionalCamerasSuggestedPrincipalPointValue principal point to be
     *                                                      suggested.
     * @return this instance so that method can be easily chained.
     */
    public T setAdditionalCamerasSuggestedPrincipalPointValue(
            final InhomogeneousPoint2D additionalCamerasSuggestedPrincipalPointValue) {
<span class="fc" id="L2330">        this.additionalCamerasSuggestedPrincipalPointValue = additionalCamerasSuggestedPrincipalPointValue;</span>
        //noinspection unchecked
<span class="fc" id="L2332">        return (T) this;</span>
    }

    /**
     * Indicates whether homogeneous point triangulator must be used or not to estimate
     * 3D points when only two matches are available.
     *
     * @return true if homogeneous point triangulator must be used, false otherwise.
     */
    public boolean isHomogeneousPointTriangulatorUsed() {
<span class="fc" id="L2342">        return useHomogeneousPointTriangulator;</span>
    }

    /**
     * Specifies whether homogeneous point triangulator must be used or not to estimate
     * 3D points when only two matches are available.
     *
     * @param useHomogeneousPointTriangulator true if homogeneous point triangulator must
     *                                        be used, false otherwise.
     * @return this instance so that method can be easily chained.
     */
    public T setHomogeneousPointTriangulatorUsed(final boolean useHomogeneousPointTriangulator) {
<span class="fc" id="L2354">        this.useHomogeneousPointTriangulator = useHomogeneousPointTriangulator;</span>
        //noinspection unchecked
<span class="fc" id="L2356">        return (T) this;</span>
    }

    /**
     * Gets robust method for point triangulation when points are matched in more
     * than two views.
     *
     * @return robust method for point triangulation.
     */
    public RobustEstimatorMethod getRobustPointTriangulatorMethod() {
<span class="fc" id="L2366">        return robustPointTriangulatorMethod;</span>
    }

    /**
     * Sets robust method for point triangulation when points are matched in more
     * than two views.
     *
     * @param robustPointTriangulatorMethod robust method for point triangulation.
     * @return this instance so that method can be easily chained.
     */
    public T setRobustPointTriangulatorMethod(final RobustEstimatorMethod robustPointTriangulatorMethod) {
<span class="fc" id="L2377">        this.robustPointTriangulatorMethod = robustPointTriangulatorMethod;</span>
        //noinspection unchecked
<span class="fc" id="L2379">        return (T) this;</span>
    }

    /**
     * Gets confidence of robustly triangulated points. By default, this is 99%.
     *
     * @return confidence of robustly triangulated points.
     */
    public double getPointTriangulatorConfidence() {
<span class="fc" id="L2388">        return pointTriangulatorConfidence;</span>
    }

    /**
     * Sets confidence of robustly triangulated points. By default, this is 99%.
     *
     * @param pointTriangulatorConfidence confidence of robustly triangulated points.
     * @return this instance so that method can be easily chained.
     */
    public T setPointTriangulatorConfidence(final double pointTriangulatorConfidence) {
<span class="fc" id="L2398">        this.pointTriangulatorConfidence = pointTriangulatorConfidence;</span>
        //noinspection unchecked
<span class="fc" id="L2400">        return (T) this;</span>
    }

    /**
     * Gets maximum number of iterations to make while robustly estimating triangulated
     * points. By default, this is 5000 iterations.
     *
     * @return maximum number of iterations to make while robustly estimating
     * triangulated points.
     */
    public int getPointTriangulatorMaxIterations() {
<span class="fc" id="L2411">        return pointTriangulatorMaxIterations;</span>
    }

    /**
     * Sets maximum number of iterations to make while robustly estimating triangulated
     * points. By default, this is 5000 iterations.
     *
     * @param pointTriangulatorMaxIterations maximum number of iterations to make while
     *                                       robustly estimating triangulated points.
     * @return this instance so that method can be easily chained.
     */
    public T setPointTriangulatorMaxIterations(final int pointTriangulatorMaxIterations) {
<span class="fc" id="L2423">        this.pointTriangulatorMaxIterations = pointTriangulatorMaxIterations;</span>
        //noinspection unchecked
<span class="fc" id="L2425">        return (T) this;</span>
    }

    /**
     * Gets threshold to determine whether samples for robust point triangulator are
     * inliers or not.
     *
     * @return threshold to determine whether samples for robust point triangulator
     * are inliers or not.
     */
    public double getPointTriangulatorThreshold() {
<span class="fc" id="L2436">        return pointTriangulatorThreshold;</span>
    }

    /**
     * Sets threshold to determine whether samples for robust point triangulator are
     * inliers or not.
     *
     * @param pointTriangulatorThreshold threshold to determine whether samples for
     *                                   robust point triangulator are inliers or not.
     * @return this instance so that method can be easily chained.
     */
    public T setPointTriangulatorThreshold(final double pointTriangulatorThreshold) {
<span class="fc" id="L2448">        this.pointTriangulatorThreshold = pointTriangulatorThreshold;</span>
        //noinspection unchecked
<span class="fc" id="L2450">        return (T) this;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>