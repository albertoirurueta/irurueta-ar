<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EssentialMatrixInitialCamerasEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.sfm</a> &gt; <span class="el_source">EssentialMatrixInitialCamerasEstimator.java</span></div><h1>EssentialMatrixInitialCamerasEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2017 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.sfm;

import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.ar.epipolar.Corrector;
import com.irurueta.ar.epipolar.CorrectorType;
import com.irurueta.ar.epipolar.EssentialMatrix;
import com.irurueta.ar.epipolar.FundamentalMatrix;
import com.irurueta.geometry.CameraException;
import com.irurueta.geometry.PinholeCamera;
import com.irurueta.geometry.PinholeCameraIntrinsicParameters;
import com.irurueta.geometry.Point2D;
import com.irurueta.geometry.Point3D;
import com.irurueta.geometry.Rotation3D;
import com.irurueta.geometry.estimators.LockedException;
import com.irurueta.geometry.estimators.NotReadyException;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.List;

/**
 * Estimates an initial pair of cameras in the metric stratum (up to an
 * arbitrary scale) using a given fundamental matrix and provided intrinsic
 * parameters on left and right views (which can be obtained by offline
 * calibration) to compute the essential matrix and choose the best combination
 * of rotation and translation on estimated cameras so that triangulated 3D
 * points obtained from provided matched 2D points are located in front of
 * the estimated cameras.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class EssentialMatrixInitialCamerasEstimator extends InitialCamerasEstimator {

    /**
     * Indicates whether matched 2D points must be triangulated by default.
     */
    public static final boolean DEFAULT_TRIANGULATE_POINTS = false;

    /**
     * Indicates whether triangulated points must be marked as valid (i.e. when
     * they lie in front of both of the estimated cameras) or not.
     */
    public static final boolean DEFAULT_MARK_VALID_TRIANGULATED_POINTS = false;

    /**
     * Intrinsic parameters to be used for estimated left camera.
     */
    private PinholeCameraIntrinsicParameters leftIntrinsic;

    /**
     * Intrinsic parameters to be used for estimated right camera.
     */
    private PinholeCameraIntrinsicParameters rightIntrinsic;

    /**
     * Matched 2D points on left view.
     */
    private List&lt;Point2D&gt; leftPoints;

    /**
     * Matched 2D points on right view.
     */
    private List&lt;Point2D&gt; rightPoints;

    /**
     * Type of corrector to use to triangulate matched points or null if no
     * corrector needs to be used.
     */
<span class="fc" id="L84">    private CorrectorType correctorType = Corrector.DEFAULT_TYPE;</span>

    /**
     * Indicates whether matched 2D points need to be triangulated.
     */
<span class="fc" id="L89">    private boolean triangulatePoints = DEFAULT_TRIANGULATE_POINTS;</span>

    /**
     * Marks which of the triangulated points are marked as valid (lie in front
     * of both of the estimated cameras) and which ones aren't.
     */
<span class="fc" id="L95">    private boolean markValidTriangulatedPoints = DEFAULT_MARK_VALID_TRIANGULATED_POINTS;</span>

    /**
     * Contains triangulated points.
     */
    private List&lt;Point3D&gt; triangulatedPoints;

    /**
     * Contains booleans indicating whether triangulated points are valid (i.e.
     * lie in front of both estimated cameras) or not.
     */
    private BitSet validTriangulatedPoints;

    /**
     * Constructor.
     */
    public EssentialMatrixInitialCamerasEstimator() {
<span class="fc" id="L112">        super();</span>
<span class="fc" id="L113">    }</span>

    /**
     * Constructor.
     *
     * @param fundamentalMatrix fundamental matrix relating two views.
     */
    public EssentialMatrixInitialCamerasEstimator(final FundamentalMatrix fundamentalMatrix) {
<span class="fc" id="L121">        super(fundamentalMatrix);</span>
<span class="fc" id="L122">    }</span>

    /**
     * Constructor.
     *
     * @param leftIntrinsic  intrinsic parameters to be used for estimated left
     *                       camera.
     * @param rightIntrinsic intrinsic parameters to be used for estimated right
     *                       camera.
     */
    public EssentialMatrixInitialCamerasEstimator(
            final PinholeCameraIntrinsicParameters leftIntrinsic,
            final PinholeCameraIntrinsicParameters rightIntrinsic) {
<span class="fc" id="L135">        super();</span>
<span class="fc" id="L136">        this.leftIntrinsic = leftIntrinsic;</span>
<span class="fc" id="L137">        this.rightIntrinsic = rightIntrinsic;</span>
<span class="fc" id="L138">    }</span>

    /**
     * Constructor.
     *
     * @param fundamentalMatrix fundamental matrix relating two views.
     * @param leftIntrinsic     intrinsic parameters to be used for estimated left
     *                          camera.
     * @param rightIntrinsic    intrinsic parameters to be used for estimated right
     *                          camera.
     */
    public EssentialMatrixInitialCamerasEstimator(
            final FundamentalMatrix fundamentalMatrix,
            final PinholeCameraIntrinsicParameters leftIntrinsic,
            final PinholeCameraIntrinsicParameters rightIntrinsic) {
<span class="fc" id="L153">        super(fundamentalMatrix);</span>
<span class="fc" id="L154">        this.leftIntrinsic = leftIntrinsic;</span>
<span class="fc" id="L155">        this.rightIntrinsic = rightIntrinsic;</span>
<span class="fc" id="L156">    }</span>

    /**
     * Constructor.
     *
     * @param leftPoints  matched 2D points on left view.
     * @param rightPoints matched 2D points on right view.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  size.
     */
    public EssentialMatrixInitialCamerasEstimator(final List&lt;Point2D&gt; leftPoints, final List&lt;Point2D&gt; rightPoints) {
<span class="fc" id="L167">        super();</span>
<span class="fc" id="L168">        internalSetLeftAndRightPoints(leftPoints, rightPoints);</span>
<span class="fc" id="L169">    }</span>

    /**
     * Constructor.
     *
     * @param fundamentalMatrix fundamental matrix relating two views.
     * @param leftPoints        matched 2D points on left view.
     * @param rightPoints       matched 2D points on right view.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  size.
     */
    public EssentialMatrixInitialCamerasEstimator(
            final FundamentalMatrix fundamentalMatrix, final List&lt;Point2D&gt; leftPoints,
            final List&lt;Point2D&gt; rightPoints) {
<span class="fc" id="L183">        super(fundamentalMatrix);</span>
<span class="fc" id="L184">        internalSetLeftAndRightPoints(leftPoints, rightPoints);</span>
<span class="fc" id="L185">    }</span>

    /**
     * Constructor.
     *
     * @param leftIntrinsic  intrinsic parameters to be used for estimated left
     *                       camera.
     * @param rightIntrinsic intrinsic parameters to be used for estimated right
     *                       camera.
     * @param leftPoints     matched 2D points on left view.
     * @param rightPoints    matched 2D points on right view.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  size.
     */
    public EssentialMatrixInitialCamerasEstimator(
            final PinholeCameraIntrinsicParameters leftIntrinsic,
            final PinholeCameraIntrinsicParameters rightIntrinsic,
            final List&lt;Point2D&gt; leftPoints, final List&lt;Point2D&gt; rightPoints) {
<span class="fc" id="L203">        this(leftIntrinsic, rightIntrinsic);</span>
<span class="fc" id="L204">        internalSetLeftAndRightPoints(leftPoints, rightPoints);</span>
<span class="fc" id="L205">    }</span>

    /**
     * Constructor.
     *
     * @param fundamentalMatrix fundamental matrix relating two views.
     * @param leftIntrinsic     intrinsic parameters to be used for estimated left
     *                          camera.
     * @param rightIntrinsic    intrinsic parameters to be used for estimated right
     *                          camera.
     * @param leftPoints        matched 2D points on left view.
     * @param rightPoints       matched 2D points on right view.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  size.
     */
    public EssentialMatrixInitialCamerasEstimator(
            final FundamentalMatrix fundamentalMatrix,
            final PinholeCameraIntrinsicParameters leftIntrinsic,
            final PinholeCameraIntrinsicParameters rightIntrinsic,
            final List&lt;Point2D&gt; leftPoints, final List&lt;Point2D&gt; rightPoints) {
<span class="fc" id="L225">        this(fundamentalMatrix, leftIntrinsic, rightIntrinsic);</span>
<span class="fc" id="L226">        internalSetLeftAndRightPoints(leftPoints, rightPoints);</span>
<span class="fc" id="L227">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events raised by this instance.
     */
    public EssentialMatrixInitialCamerasEstimator(final InitialCamerasEstimatorListener listener) {
<span class="fc" id="L235">        super(listener);</span>
<span class="fc" id="L236">    }</span>

    /**
     * Constructor.
     *
     * @param fundamentalMatrix fundamental matrix relating two views.
     * @param listener          listener to handle events raised by this instance.
     */
    public EssentialMatrixInitialCamerasEstimator(
            final FundamentalMatrix fundamentalMatrix, final InitialCamerasEstimatorListener listener) {
<span class="fc" id="L246">        super(fundamentalMatrix, listener);</span>
<span class="fc" id="L247">    }</span>

    /**
     * Constructor.
     *
     * @param leftIntrinsic  intrinsic parameters to be used for estimated left
     *                       camera.
     * @param rightIntrinsic intrinsic parameters to be used for estimated right
     *                       camera.
     * @param listener       listener to handle events raised by this instance.
     */
    public EssentialMatrixInitialCamerasEstimator(
            final PinholeCameraIntrinsicParameters leftIntrinsic,
            final PinholeCameraIntrinsicParameters rightIntrinsic,
            final InitialCamerasEstimatorListener listener) {
<span class="fc" id="L262">        super(listener);</span>
<span class="fc" id="L263">        this.leftIntrinsic = leftIntrinsic;</span>
<span class="fc" id="L264">        this.rightIntrinsic = rightIntrinsic;</span>
<span class="fc" id="L265">    }</span>

    /**
     * Constructor.
     *
     * @param fundamentalMatrix fundamental matrix relating two views.
     * @param leftIntrinsic     intrinsic parameters to be used for estimated left
     *                          camera.
     * @param rightIntrinsic    intrinsic parameters to be used for estimated right
     *                          camera.
     * @param listener          listener to handle events raised by this instance.
     */
    public EssentialMatrixInitialCamerasEstimator(
            final FundamentalMatrix fundamentalMatrix,
            final PinholeCameraIntrinsicParameters leftIntrinsic,
            final PinholeCameraIntrinsicParameters rightIntrinsic,
            final InitialCamerasEstimatorListener listener) {
<span class="fc" id="L282">        super(fundamentalMatrix, listener);</span>
<span class="fc" id="L283">        this.leftIntrinsic = leftIntrinsic;</span>
<span class="fc" id="L284">        this.rightIntrinsic = rightIntrinsic;</span>
<span class="fc" id="L285">    }</span>

    /**
     * Constructor.
     *
     * @param leftPoints  matched 2D points on left view.
     * @param rightPoints matched 2D points on right view.
     * @param listener    listener to handle events raised by this instance.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  size.
     */
    public EssentialMatrixInitialCamerasEstimator(
            final List&lt;Point2D&gt; leftPoints,
            final List&lt;Point2D&gt; rightPoints,
            final InitialCamerasEstimatorListener listener) {
<span class="fc" id="L300">        super(listener);</span>
<span class="fc" id="L301">        internalSetLeftAndRightPoints(leftPoints, rightPoints);</span>
<span class="fc" id="L302">    }</span>

    /**
     * Constructor.
     *
     * @param fundamentalMatrix fundamental matrix relating two views.
     * @param leftPoints        matched 2D points on left view.
     * @param rightPoints       matched 2D points on right view.
     * @param listener          listener to handle events raised by this instance.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  size.
     */
    public EssentialMatrixInitialCamerasEstimator(
            final FundamentalMatrix fundamentalMatrix,
            final List&lt;Point2D&gt; leftPoints,
            final List&lt;Point2D&gt; rightPoints,
            final InitialCamerasEstimatorListener listener) {
<span class="fc" id="L319">        super(fundamentalMatrix, listener);</span>
<span class="fc" id="L320">        internalSetLeftAndRightPoints(leftPoints, rightPoints);</span>
<span class="fc" id="L321">    }</span>

    /**
     * Constructor.
     *
     * @param leftIntrinsic  intrinsic parameters to be used for estimated left
     *                       camera.
     * @param rightIntrinsic intrinsic parameters to be used for estimated right
     *                       camera.
     * @param leftPoints     matched 2D points on left view.
     * @param rightPoints    matched 2D points on right view.
     * @param listener       listener to handle events raised by this instance.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  size.
     */
    public EssentialMatrixInitialCamerasEstimator(
            final PinholeCameraIntrinsicParameters leftIntrinsic,
            final PinholeCameraIntrinsicParameters rightIntrinsic,
            final List&lt;Point2D&gt; leftPoints,
            final List&lt;Point2D&gt; rightPoints,
            final InitialCamerasEstimatorListener listener) {
<span class="fc" id="L342">        this(leftIntrinsic, rightIntrinsic, listener);</span>
<span class="fc" id="L343">        internalSetLeftAndRightPoints(leftPoints, rightPoints);</span>
<span class="fc" id="L344">    }</span>

    /**
     * Constructor.
     *
     * @param fundamentalMatrix fundamental matrix relating two views.
     * @param leftIntrinsic     intrinsic parameters to be used for estimated left
     *                          camera.
     * @param rightIntrinsic    intrinsic parameters to be used for estimated right
     *                          camera.
     * @param leftPoints        matched 2D points on left view.
     * @param rightPoints       matched 2D points on right view.
     * @param listener          listener to handle events raised by this instance.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  size.
     */
    public EssentialMatrixInitialCamerasEstimator(
            final FundamentalMatrix fundamentalMatrix,
            final PinholeCameraIntrinsicParameters leftIntrinsic,
            final PinholeCameraIntrinsicParameters rightIntrinsic,
            final List&lt;Point2D&gt; leftPoints,
            final List&lt;Point2D&gt; rightPoints,
            final InitialCamerasEstimatorListener listener) {
<span class="fc" id="L367">        this(fundamentalMatrix, leftIntrinsic, rightIntrinsic, listener);</span>
<span class="fc" id="L368">        internalSetLeftAndRightPoints(leftPoints, rightPoints);</span>
<span class="fc" id="L369">    }</span>

    /**
     * Returns method used by this estimator.
     *
     * @return method used by this estimator.
     */
    @Override
    public InitialCamerasEstimatorMethod getMethod() {
<span class="fc" id="L378">        return InitialCamerasEstimatorMethod.ESSENTIAL_MATRIX;</span>
    }

    /**
     * Indicates if estimator is ready.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
<span class="pc bpc" id="L388" title="2 of 10 branches missed.">        return fundamentalMatrix != null &amp;&amp; leftIntrinsic != null &amp;&amp; rightIntrinsic != null &amp;&amp; leftPoints != null</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">                &amp;&amp; rightPoints != null &amp;&amp; leftPoints.size() == rightPoints.size();</span>
    }

    /**
     * Estimates cameras.
     *
     * @throws LockedException                         if estimator is locked.
     * @throws NotReadyException                       if estimator is not ready.
     * @throws InitialCamerasEstimationFailedException if estimation of cameras
     *                                                 fails for some reason, typically due to numerical
     *                                                 instabilities.
     */
    @Override
    public void estimate() throws LockedException, NotReadyException, InitialCamerasEstimationFailedException {
<span class="fc bfc" id="L403" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L404">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L407" title="All 2 branches covered.">        if (!isReady()) {</span>
<span class="fc" id="L408">            throw new NotReadyException();</span>
        }

        try {
<span class="fc" id="L412">            locked = true;</span>

<span class="fc bfc" id="L414" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L415">                listener.onStart(this);</span>
            }

<span class="pc bpc" id="L418" title="1 of 2 branches missed.">            if (triangulatePoints) {</span>
<span class="fc" id="L419">                triangulatedPoints = new ArrayList&lt;&gt;();</span>
            } else {
<span class="nc" id="L421">                triangulatedPoints = null;</span>
            }

<span class="fc" id="L424">            final var nPoints = leftPoints.size();</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">            if (markValidTriangulatedPoints) {</span>
<span class="fc" id="L426">                validTriangulatedPoints = new BitSet(nPoints);</span>
            } else {
<span class="nc" id="L428">                validTriangulatedPoints = null;</span>
            }

<span class="fc bfc" id="L431" title="All 2 branches covered.">            if (estimatedLeftCamera == null) {</span>
<span class="fc" id="L432">                estimatedLeftCamera = new PinholeCamera();</span>
            }
<span class="fc bfc" id="L434" title="All 2 branches covered.">            if (estimatedRightCamera == null) {</span>
<span class="fc" id="L435">                estimatedRightCamera = new PinholeCamera();</span>
            }

<span class="fc" id="L438">            generateInitialMetricCamerasFromEssentialMatrix(fundamentalMatrix, leftIntrinsic, rightIntrinsic,</span>
                    leftPoints, rightPoints, correctorType, estimatedLeftCamera, estimatedRightCamera,
                    triangulatedPoints, validTriangulatedPoints);

<span class="fc bfc" id="L442" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L443">                listener.onFinish(this, estimatedLeftCamera, estimatedRightCamera);</span>
            }
<span class="fc" id="L445">        } catch (final InitialCamerasEstimationFailedException e) {</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="nc" id="L447">                listener.onFail(this, e);</span>
            }
<span class="fc" id="L449">            throw e;</span>
        } finally {
<span class="fc" id="L451">            locked = false;</span>
        }
<span class="fc" id="L453">    }</span>

    /**
     * Gets intrinsic parameters to be used for estimated left camera.
     *
     * @return intrinsic parameters to be used for estimated left camera.
     */
    public PinholeCameraIntrinsicParameters getLeftIntrinsic() {
<span class="fc" id="L461">        return leftIntrinsic;</span>
    }

    /**
     * Sets intrinsic parameters to be used for estimated left camera.
     *
     * @param leftIntrinsic intrinsic parameters to be used for estimated left
     *                      camera.
     * @throws LockedException if estimator is locked.
     */
    public void setLeftIntrinsic(
            final PinholeCameraIntrinsicParameters leftIntrinsic) throws LockedException {
<span class="fc bfc" id="L473" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L474">            throw new LockedException();</span>
        }
<span class="fc" id="L476">        this.leftIntrinsic = leftIntrinsic;</span>
<span class="fc" id="L477">    }</span>

    /**
     * Gets intrinsic parameters to be used for estimated right camera.
     *
     * @return intrinsic parameters to be used for estimated right camera.
     */
    public PinholeCameraIntrinsicParameters getRightIntrinsic() {
<span class="fc" id="L485">        return rightIntrinsic;</span>
    }

    /**
     * Sets intrinsic parameters to be used for estimated right camera.
     *
     * @param rightIntrinsic intrinsic parameters to be used for estimated right
     *                       camera.
     * @throws LockedException if estimator is locked.
     */
    public void setRightIntrinsic(
            final PinholeCameraIntrinsicParameters rightIntrinsic) throws LockedException {
<span class="fc bfc" id="L497" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L498">            throw new LockedException();</span>
        }
<span class="fc" id="L500">        this.rightIntrinsic = rightIntrinsic;</span>
<span class="fc" id="L501">    }</span>

    /**
     * Sets intrinsic parameters to be used for estimated left and right
     * cameras.
     *
     * @param leftIntrinsic  intrinsic parameters to be used for estimated left
     *                       camera.
     * @param rightIntrinsic intrinsic parameters to be used for estimated right
     *                       camera.
     * @throws LockedException if estimator is locked.
     */
    public void setLeftAndRightIntrinsics(
            final PinholeCameraIntrinsicParameters leftIntrinsic,
            final PinholeCameraIntrinsicParameters rightIntrinsic) throws LockedException {
<span class="fc bfc" id="L516" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L517">            throw new LockedException();</span>
        }
<span class="fc" id="L519">        this.leftIntrinsic = leftIntrinsic;</span>
<span class="fc" id="L520">        this.rightIntrinsic = rightIntrinsic;</span>
<span class="fc" id="L521">    }</span>

    /**
     * Sets the same intrinsic parameters to be used for both estimated left
     * and right cameras.
     *
     * @param intrinsic intrinsic parameters to be used for both cameras.
     * @throws LockedException if estimator is locked.
     */
    public void setIntrinsicsForBoth(final PinholeCameraIntrinsicParameters intrinsic) throws LockedException {
<span class="fc bfc" id="L531" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L532">            throw new LockedException();</span>
        }
<span class="fc" id="L534">        leftIntrinsic = rightIntrinsic = intrinsic;</span>
<span class="fc" id="L535">    }</span>

    /**
     * Gets matched 2D points on left view.
     *
     * @return matched 2D points on left view.
     */
    public List&lt;Point2D&gt; getLeftPoints() {
<span class="fc" id="L543">        return leftPoints;</span>
    }

    /**
     * Sets matched 2D points on left view.
     *
     * @param leftPoints matched 2D points on left view.
     * @throws LockedException if estimator is locked.
     */
    public void setLeftPoints(final List&lt;Point2D&gt; leftPoints) throws LockedException {
<span class="fc bfc" id="L553" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L554">            throw new LockedException();</span>
        }
<span class="fc" id="L556">        this.leftPoints = leftPoints;</span>
<span class="fc" id="L557">    }</span>

    /**
     * Gets matched 2D points on right view.
     *
     * @return matched 2D points on right view.
     */
    public List&lt;Point2D&gt; getRightPoints() {
<span class="fc" id="L565">        return rightPoints;</span>
    }

    /**
     * Sets matched 2D points on right view.
     *
     * @param rightPoints matched 2D points on right view.
     * @throws LockedException if estimator is locked.
     */
    public void setRightPoints(final List&lt;Point2D&gt; rightPoints) throws LockedException {
<span class="fc bfc" id="L575" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L576">            throw new LockedException();</span>
        }
<span class="fc" id="L578">        this.rightPoints = rightPoints;</span>
<span class="fc" id="L579">    }</span>

    /**
     * Sets matched 2D points on left and right views.
     *
     * @param leftPoints  matched 2D points on left view.
     * @param rightPoints matched 2D points on right view.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  size.
     */
    public void setLeftAndRightPoints(
            final List&lt;Point2D&gt; leftPoints, final List&lt;Point2D&gt; rightPoints) throws LockedException {
<span class="fc bfc" id="L592" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L593">            throw new LockedException();</span>
        }
<span class="fc" id="L595">        internalSetLeftAndRightPoints(leftPoints, rightPoints);</span>
<span class="fc" id="L596">    }</span>

    /**
     * Gets type of corrector to use to triangulate matched points or null if
     * no corrector needs to be used.
     *
     * @return type of corrector to use.
     */
    public CorrectorType getCorrectorType() {
<span class="fc" id="L605">        return correctorType;</span>
    }

    /**
     * Sets type of corrector to use to triangulate matched points or null if
     * no corrector needs to be used.
     *
     * @param correctorType type of corrector to use.
     * @throws LockedException if estimator is locked.
     */
    public void setCorrectorType(final CorrectorType correctorType) throws LockedException {
<span class="fc bfc" id="L616" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L617">            throw new LockedException();</span>
        }
<span class="fc" id="L619">        this.correctorType = correctorType;</span>
<span class="fc" id="L620">    }</span>

    /**
     * Indicates whether matched 2D points need to be triangulated or not.
     *
     * @return true if 2D points need to be triangulated, false otherwise.
     */
    public boolean arePointsTriangulated() {
<span class="fc" id="L628">        return triangulatePoints;</span>
    }

    /**
     * Specifies whether matched 2D points need to be triangulated or not.
     *
     * @param triangulatePoints true if 2D points need to be triangulated, false
     *                          otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setPointsTriangulated(final boolean triangulatePoints) throws LockedException {
<span class="fc bfc" id="L639" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L640">            throw new LockedException();</span>
        }
<span class="fc" id="L642">        this.triangulatePoints = triangulatePoints;</span>
<span class="fc" id="L643">    }</span>

    /**
     * Indicates which triangulated points are marked as valid (lie in front
     * of both of the estimated cameras) and which ones aren't.
     *
     * @return true to mark valid and invalid triangulated points, false
     * otherwise.
     */
    public boolean areValidTriangulatedPointsMarked() {
<span class="fc" id="L653">        return markValidTriangulatedPoints;</span>
    }

    /**
     * Specifies whether triangulated points are marked as valid (lie in front
     * of both of the estimated cameras) and which ones aren't.
     *
     * @param markValidTriangulatedPoints true to mark valid and invalid
     *                                    triangulated points, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setValidTriangulatedPointsMarked(final boolean markValidTriangulatedPoints) throws LockedException {
<span class="fc bfc" id="L665" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L666">            throw new LockedException();</span>
        }
<span class="fc" id="L668">        this.markValidTriangulatedPoints = markValidTriangulatedPoints;</span>
<span class="fc" id="L669">    }</span>

    /**
     * Gets triangulated points, if available.
     *
     * @return triangulated points or null.
     */
    public List&lt;Point3D&gt; getTriangulatedPoints() {
<span class="fc" id="L677">        return triangulatedPoints;</span>
    }

    /**
     * Gets bitset indicating which of the triangulated points are valid and
     * which ones aren't.
     *
     * @return bitset indicating validity of triangulated points or null if not
     * available.
     */
    public BitSet getValidTriangulatedPoints() {
<span class="fc" id="L688">        return validTriangulatedPoints;</span>
    }

    /**
     * Generates a pair of metric cameras (up to an arbitrary space) by
     * computing the essential matrix from provided fundamental matrix and
     * intrinsic parameters of left and right cameras, and choosing the best
     * pair of camera pose and translation that yields the largest number of
     * triangulated points laying in front of both of the estimated cameras.
     * This method uses default corrector type and does not keep triangulated
     * points or valid triangulated points.
     *
     * @param fundamentalMatrix fundamental matrix relating both left and right
     *                          views.
     * @param leftIntrinsic     intrinsic parameters to be set on left view.
     *                          This can be used when cameras have been previously calibrated.
     * @param rightIntrinsic    intrinsic parameters to be set on right view.
     *                          This can be used when cameras have been previously calibrated.
     * @param leftPoints        points on left view matched with points on right view,
     *                          so they can be triangulated using estimated cameras. Both lists of points
     *                          must have the same size.
     * @param rightPoints       points on right view matched with points on left view,
     *                          so they can be triangulated using estimated cameras. Both lists of points
     *                          must have the same size.
     * @param leftCamera        instance where estimated left camera will be stored.
     * @param rightCamera       instance where estimated right camera will be stored.
     * @return number of valid triangulated points which lie in front of the two
     * estimated cameras.
     * @throws InitialCamerasEstimationFailedException if estimation of cameras
     *                                                 fails for some reason, typically due to numerical
     *                                                 instabilities.
     * @throws IllegalArgumentException                if provided lists of left and right
     *                                                 points don't have the same size.
     */
    public static int generateInitialMetricCamerasFromEssentialMatrix(
            final FundamentalMatrix fundamentalMatrix,
            final PinholeCameraIntrinsicParameters leftIntrinsic,
            final PinholeCameraIntrinsicParameters rightIntrinsic,
            final List&lt;Point2D&gt; leftPoints, final List&lt;Point2D&gt; rightPoints,
            final PinholeCamera leftCamera, final PinholeCamera rightCamera)
            throws InitialCamerasEstimationFailedException {
<span class="fc" id="L729">        return generateInitialMetricCamerasFromEssentialMatrix(</span>
                fundamentalMatrix, leftIntrinsic, rightIntrinsic, leftPoints,
                rightPoints, Corrector.DEFAULT_TYPE, leftCamera, rightCamera);
    }

    /**
     * Generates a pair of metric cameras (up to an arbitrary space) by
     * computing the essential matrix from provided fundamental matrix and
     * intrinsic parameters of left and right cameras, and choosing the best
     * pair of camera pose and translation that yields the largest number of
     * triangulated points laying in front of both of the estimated cameras.
     * This method does not keep triangulated points or valid triangulated
     * points.
     *
     * @param fundamentalMatrix fundamental matrix relating both left and right
     *                          views.
     * @param leftIntrinsic     intrinsic parameters to be set on left view.
     *                          This can be used when cameras have been previously calibrated.
     * @param rightIntrinsic    intrinsic parameters to be set on right view.
     *                          This can be used when cameras have been previously calibrated.
     * @param leftPoints        points on left view matched with points on right view,
     *                          so they can be triangulated using estimated cameras. Both lists of points
     *                          must have the same size.
     * @param rightPoints       points on right view matched with points on left view,
     *                          so they can be triangulated using estimated cameras. Both lists of points
     *                          must have the same size.
     * @param correctorType     corrector type to be used to correct 2D points, so
     *                          they follow the epipolar geometry defined by provided fundamental matrix
     *                          so that error on triangulated points is reduced. If null, no corrector
     *                          will be used.
     * @param leftCamera        instance where estimated left camera will be stored.
     * @param rightCamera       instance where estimated right camera will be stored.
     * @return number of valid triangulated points which lie in front of the two
     * estimated cameras.
     * @throws InitialCamerasEstimationFailedException if estimation of
     *                                                 cameras fails for some reason, typically due to
     *                                                 numerical instabilities.
     * @throws IllegalArgumentException                if provided lists of left and right
     *                                                 points don't have the same size.
     */
    public static int generateInitialMetricCamerasFromEssentialMatrix(
            final FundamentalMatrix fundamentalMatrix,
            final PinholeCameraIntrinsicParameters leftIntrinsic,
            final PinholeCameraIntrinsicParameters rightIntrinsic,
            final List&lt;Point2D&gt; leftPoints, final List&lt;Point2D&gt; rightPoints,
            final CorrectorType correctorType, final PinholeCamera leftCamera,
            final PinholeCamera rightCamera) throws InitialCamerasEstimationFailedException {
<span class="fc" id="L776">        return generateInitialMetricCamerasFromEssentialMatrix(</span>
                fundamentalMatrix, leftIntrinsic, rightIntrinsic, leftPoints,
                rightPoints, correctorType, leftCamera, rightCamera, null,
                null);
    }

    /**
     * Generates a pair of metric cameras (up to an arbitrary space) by
     * computing the essential matrix from provided fundamental matrix and
     * intrinsic parameters of left and right cameras, and choosing the best
     * pair of camera pose and translation that yields the largest number of
     * triangulated points laying in front of both of the estimated cameras.
     * This method uses default corrector type.
     *
     * @param fundamentalMatrix       fundamental matrix relating both left and right
     *                                views.
     * @param leftIntrinsic           intrinsic parameters to be set on left view.
     *                                This can be used when cameras have been previously calibrated.
     * @param rightIntrinsic          intrinsic parameters to be set on right view.
     *                                This can be used when cameras have been previously calibrated.
     * @param leftPoints              points on left view matched with points on right view,
     *                                so they can be triangulated using estimated cameras. Both lists of
     *                                points must have the same size.
     * @param rightPoints             points on right view matched with points on left view,
     *                                so they can be triangulated using estimated cameras. Both lists of
     *                                points must have the same size.
     * @param leftCamera              instance where estimated left camera will be stored.
     * @param rightCamera             instance where estimated right camera will be stored.
     * @param triangulatedPoints      instance where triangulated 3D points will be
     *                                stored or null if triangulated points don't need to be kept.
     * @param validTriangulatedPoints instance which indicates which
     *                                triangulated 3D points are considered valid because they lie in
     *                                front of both cameras or null if such data doesn't need to be kept.
     * @return number of valid triangulated points which lie in front of the two
     * estimated cameras.
     * @throws InitialCamerasEstimationFailedException if estimation of cameras
     *                                                 fails for some reason, typically due to numerical
     *                                                 instabilities.
     * @throws IllegalArgumentException                if provided lists of left and right
     *                                                 points don't have the same size.
     */
    public static int generateInitialMetricCamerasFromEssentialMatrix(
            final FundamentalMatrix fundamentalMatrix,
            final PinholeCameraIntrinsicParameters leftIntrinsic,
            final PinholeCameraIntrinsicParameters rightIntrinsic,
            final List&lt;Point2D&gt; leftPoints, final List&lt;Point2D&gt; rightPoints,
            final PinholeCamera leftCamera, final PinholeCamera rightCamera,
            final List&lt;Point3D&gt; triangulatedPoints, final BitSet validTriangulatedPoints)
            throws InitialCamerasEstimationFailedException {

<span class="fc" id="L826">        return generateInitialMetricCamerasFromEssentialMatrix(</span>
                fundamentalMatrix, leftIntrinsic, rightIntrinsic, leftPoints,
                rightPoints, Corrector.DEFAULT_TYPE, leftCamera, rightCamera,
                triangulatedPoints, validTriangulatedPoints);
    }

    /**
     * Generates a pair of metric cameras (up to an arbitrary space) by
     * computing the essential matrix from provided fundamental matrix and
     * intrinsic parameters of left and right cameras, and choosing the best
     * pair of camera pose and translation that yields the largest number of
     * triangulated points laying in front of both of the estimated cameras.
     *
     * @param fundamentalMatrix       fundamental matrix relating both left and right
     *                                views.
     * @param leftIntrinsic           intrinsic parameters to be set on left view.
     *                                This can be used when cameras have been previously calibrated.
     * @param rightIntrinsic          intrinsic parameters to be set on right view.
     *                                This can be used when cameras have been previously calibrated.
     * @param leftPoints              points on left view matched with points on right view,
     *                                so they can be triangulated using estimated cameras. Both lists
     *                                of points must have the same size.
     * @param rightPoints             points on right view matched with points on left view,
     *                                so they can be triangulated using estimated cameras. Both lists
     *                                of points must have the same size.
     * @param correctorType           corrector type to be used to correct 2D points, so
     *                                they follow the epipolar geometry defined by provided fundamental
     *                                matrix so that error on triangulated points is reduced. If null,
     *                                no corrector will be used.
     * @param leftCamera              instance where estimated left camera will be stored.
     * @param rightCamera             instance where estimated right camera will be stored.
     * @param triangulatedPoints      instance where triangulated 3D points will be
     *                                stored or null if triangulated points don't need to be kept.
     * @param validTriangulatedPoints instance which indicates which
     *                                triangulated 3D points are considered valid because they lie in
     *                                front of both cameras or null if such data doesn't need to be kept.
     * @return number of valid triangulated points which lie in front of the two
     * estimated cameras.
     * @throws InitialCamerasEstimationFailedException if estimation of
     *                                                 cameras fails for some reason, typically due to
     *                                                 numerical instabilities.
     * @throws IllegalArgumentException                if provided lists of left and right
     *                                                 points don't have the same size.
     */
    public static int generateInitialMetricCamerasFromEssentialMatrix(
            final FundamentalMatrix fundamentalMatrix,
            final PinholeCameraIntrinsicParameters leftIntrinsic,
            final PinholeCameraIntrinsicParameters rightIntrinsic,
            final List&lt;Point2D&gt; leftPoints, final List&lt;Point2D&gt; rightPoints,
            final CorrectorType correctorType, final PinholeCamera leftCamera,
            final PinholeCamera rightCamera, final List&lt;Point3D&gt; triangulatedPoints,
            final BitSet validTriangulatedPoints)
            throws InitialCamerasEstimationFailedException {

<span class="pc bpc" id="L880" title="1 of 2 branches missed.">        if (leftPoints.size() != rightPoints.size()) {</span>
<span class="nc" id="L881">            throw new IllegalArgumentException(</span>
                    &quot;left and right points must have the same size&quot;);
        }

        final List&lt;Point2D&gt; correctedLeftPoints;
        final List&lt;Point2D&gt; correctedRightPoints;
        final Rotation3D rotation1;
        final Rotation3D rotation2;
        final Point2D translation1;
        final Point2D translation2;
        try {
<span class="fc" id="L892">            final var essential = new EssentialMatrix(fundamentalMatrix, leftIntrinsic, rightIntrinsic);</span>

<span class="fc" id="L894">            essential.computePossibleRotationAndTranslations();</span>

<span class="fc" id="L896">            rotation1 = essential.getFirstPossibleRotation();</span>
<span class="fc" id="L897">            translation1 = essential.getFirstPossibleTranslation();</span>

<span class="fc" id="L899">            rotation2 = essential.getSecondPossibleRotation();</span>
<span class="fc" id="L900">            translation2 = essential.getSecondPossibleTranslation();</span>

<span class="fc bfc" id="L902" title="All 2 branches covered.">            if (correctorType != null) {</span>
                // use corrector
<span class="fc" id="L904">                final var corrector = Corrector.create(leftPoints, rightPoints, fundamentalMatrix, correctorType);</span>
<span class="fc" id="L905">                corrector.correct();</span>

<span class="fc" id="L907">                correctedLeftPoints = corrector.getLeftCorrectedPoints();</span>
<span class="fc" id="L908">                correctedRightPoints = corrector.getRightCorrectedPoints();</span>
<span class="fc" id="L909">            } else {</span>
                // don't use corrector
<span class="fc" id="L911">                correctedLeftPoints = leftPoints;</span>
<span class="fc" id="L912">                correctedRightPoints = rightPoints;</span>
            }
<span class="nc" id="L914">        } catch (final Exception e) {</span>
<span class="nc" id="L915">            throw new InitialCamerasEstimationFailedException(e);</span>
<span class="fc" id="L916">        }</span>

<span class="fc bfc" id="L918" title="All 2 branches covered.">        if (triangulatedPoints != null) {</span>
<span class="fc" id="L919">            triangulatedPoints.clear();</span>
        }
<span class="fc bfc" id="L921" title="All 2 branches covered.">        if (validTriangulatedPoints != null) {</span>
<span class="fc" id="L922">            validTriangulatedPoints.clear();</span>
        }
        int numValidTriangulatedPoints;

<span class="fc" id="L926">        final var numPoints = correctedLeftPoints.size();</span>
<span class="fc" id="L927">        var skip = false;</span>

        // obtain 1st pair of possible cameras and their corresponding
        // triangulated points
        try {
<span class="fc" id="L932">            numValidTriangulatedPoints = computeCamerasAndTriangulation(rotation1, translation1,</span>
                    leftIntrinsic, rightIntrinsic, correctedLeftPoints, correctedRightPoints, leftCamera, rightCamera,
                    triangulatedPoints, validTriangulatedPoints);
<span class="nc" id="L935">        } catch (final Exception e) {</span>
<span class="nc" id="L936">            numValidTriangulatedPoints = 0;</span>
<span class="fc" id="L937">        }</span>

<span class="fc bfc" id="L939" title="All 2 branches covered.">        if (numValidTriangulatedPoints &gt;= numPoints) {</span>
            // all points are valid, hence, we can set current pair of
            // cameras as the best result
<span class="fc" id="L942">            skip = true;</span>
        }

<span class="fc" id="L945">        final var attemptLeftCamera = new PinholeCamera();</span>
<span class="fc" id="L946">        final var attemptRightCamera = new PinholeCamera();</span>
<span class="fc" id="L947">        List&lt;Point3D&gt; attemptTriangulatedPoints = null;</span>
<span class="fc bfc" id="L948" title="All 2 branches covered.">        if (triangulatedPoints != null) {</span>
<span class="fc" id="L949">            attemptTriangulatedPoints = new ArrayList&lt;&gt;();</span>
        }
<span class="fc" id="L951">        BitSet attemptValidTriangulatedPoints = null;</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">        if (validTriangulatedPoints != null) {</span>
<span class="fc" id="L953">            attemptValidTriangulatedPoints = new BitSet(numPoints);</span>
        }
        int attemptNumValidTriangulatedPoints;

<span class="fc bfc" id="L957" title="All 2 branches covered.">        if (!skip) {</span>
            // obtain 2nd pair of possible cameras and their corresponding
            // triangulated points
            try {
<span class="fc" id="L961">                attemptNumValidTriangulatedPoints = computeCamerasAndTriangulation(rotation1, translation2,</span>
                        leftIntrinsic, rightIntrinsic, correctedLeftPoints, correctedRightPoints, attemptLeftCamera,
                        attemptRightCamera, attemptTriangulatedPoints, attemptValidTriangulatedPoints);
<span class="nc" id="L964">            } catch (final Exception e) {</span>
<span class="nc" id="L965">                attemptNumValidTriangulatedPoints = 0;</span>
<span class="fc" id="L966">            }</span>

<span class="fc bfc" id="L968" title="All 2 branches covered.">            if (attemptNumValidTriangulatedPoints &gt;= numPoints) {</span>
                // all points are valid, hence, we can set current pair of
                // cameras as the best result
<span class="fc" id="L971">                skip = true;</span>
            }

<span class="fc bfc" id="L974" title="All 2 branches covered.">            if (attemptNumValidTriangulatedPoints &gt; numValidTriangulatedPoints) {</span>
                // a better solution containing more valid points has been found

                // keep better solution
<span class="fc" id="L978">                updateBestSolutionData(leftCamera, rightCamera, triangulatedPoints, validTriangulatedPoints,</span>
                        attemptLeftCamera, attemptRightCamera, attemptTriangulatedPoints,
                        attemptValidTriangulatedPoints);
<span class="fc" id="L981">                numValidTriangulatedPoints = attemptNumValidTriangulatedPoints;</span>
            }
        }

<span class="fc bfc" id="L985" title="All 2 branches covered.">        if (!skip) {</span>
            // obtain 3rd pair of possible cameras and their corresponding
            // triangulated points
            try {
<span class="fc" id="L989">                attemptNumValidTriangulatedPoints = computeCamerasAndTriangulation(rotation2, translation1,</span>
                        leftIntrinsic, rightIntrinsic, correctedLeftPoints, correctedRightPoints, attemptLeftCamera,
                        attemptRightCamera, attemptTriangulatedPoints, attemptValidTriangulatedPoints);
<span class="nc" id="L992">            } catch (final Exception e) {</span>
<span class="nc" id="L993">                attemptNumValidTriangulatedPoints = 0;</span>
<span class="fc" id="L994">            }</span>

<span class="fc bfc" id="L996" title="All 2 branches covered.">            if (attemptNumValidTriangulatedPoints &gt;= numPoints) {</span>
                // all points are valid, hence, we can set current pair of
                // cameras as the best result
<span class="fc" id="L999">                skip = true;</span>
            }

<span class="fc bfc" id="L1002" title="All 2 branches covered.">            if (attemptNumValidTriangulatedPoints &gt; numValidTriangulatedPoints) {</span>
                // a better solution containing more valid points has been found

                // keep better solution
<span class="fc" id="L1006">                updateBestSolutionData(leftCamera, rightCamera, triangulatedPoints, validTriangulatedPoints,</span>
                        attemptLeftCamera, attemptRightCamera, attemptTriangulatedPoints,
                        attemptValidTriangulatedPoints);
<span class="fc" id="L1009">                numValidTriangulatedPoints = attemptNumValidTriangulatedPoints;</span>
            }
        }

<span class="fc bfc" id="L1013" title="All 2 branches covered.">        if (!skip) {</span>
            // obtain 4th pair of possible cameras and their corresponding
            // triangulated points
            try {
<span class="fc" id="L1017">                attemptNumValidTriangulatedPoints = computeCamerasAndTriangulation(rotation2, translation2,</span>
                        leftIntrinsic, rightIntrinsic, correctedLeftPoints, correctedRightPoints, attemptLeftCamera,
                        attemptRightCamera, attemptTriangulatedPoints, attemptValidTriangulatedPoints);
<span class="nc" id="L1020">            } catch (final Exception e) {</span>
<span class="nc" id="L1021">                attemptNumValidTriangulatedPoints = 0;</span>
<span class="fc" id="L1022">            }</span>

<span class="fc bfc" id="L1024" title="All 2 branches covered.">            if (attemptNumValidTriangulatedPoints &gt; numValidTriangulatedPoints) {</span>
                // a better solution containing more valid points has been found

                // keep better solution
<span class="fc" id="L1028">                updateBestSolutionData(leftCamera, rightCamera, triangulatedPoints, validTriangulatedPoints,</span>
                        attemptLeftCamera, attemptRightCamera, attemptTriangulatedPoints,
                        attemptValidTriangulatedPoints);
<span class="fc" id="L1031">                numValidTriangulatedPoints = attemptNumValidTriangulatedPoints;</span>
            }
        }

<span class="fc bfc" id="L1035" title="All 2 branches covered.">        if (numValidTriangulatedPoints == 0) {</span>
<span class="fc" id="L1036">            throw new InitialCamerasEstimationFailedException(&quot;no valid points found&quot;);</span>
        }

<span class="fc" id="L1039">        return numValidTriangulatedPoints;</span>
    }

    /**
     * Internal method to set matched 2D points on left and right views.
     * This method does not check whether the estimator is locked or not, only
     * ensures that provided lists have the same size.
     *
     * @param leftPoints  matched 2D points on left view.
     * @param rightPoints matched 2D points on right view.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  size.
     */
    private void internalSetLeftAndRightPoints(final List&lt;Point2D&gt; leftPoints, final List&lt;Point2D&gt; rightPoints) {
<span class="fc bfc" id="L1053" title="All 6 branches covered.">        if (leftPoints == null || rightPoints == null || leftPoints.size() != rightPoints.size()) {</span>
<span class="fc" id="L1054">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L1056">        this.leftPoints = leftPoints;</span>
<span class="fc" id="L1057">        this.rightPoints = rightPoints;</span>
<span class="fc" id="L1058">    }</span>

    /**
     * Updates data for best solution found so far.
     *
     * @param leftCamera                     instance where best found left camera will be stored.
     * @param rightCamera                    instance where best found right camera will be stored.
     * @param triangulatedPoints             instance where triangulated points for best
     *                                       found solution will be stored or null if points don't need to
     *                                       be kept.
     * @param validTriangulatedPoints        instance where valid triangulated points
     *                                       for best found solution will be stored or null if such data
     *                                       doesn't need to be kept.
     * @param attemptLeftCamera              estimated left camera to be copied into the best
     *                                       solution.
     * @param attemptRightCamera             estimated right camera to be copied into the best
     *                                       solution.
     * @param attemptTriangulatedPoints      triangulated points to be copied into the
     *                                       best solution, or null if nothing needs to be copied.
     * @param attemptValidTriangulatedPoints valid triangulated points to be
     *                                       copied into the best solution, or null if nothing needs to
     *                                       be copied.
     * @throws InitialCamerasEstimationFailedException if something fails.
     */
    private static void updateBestSolutionData(
            final PinholeCamera leftCamera,
            final PinholeCamera rightCamera,
            final List&lt;Point3D&gt; triangulatedPoints,
            final BitSet validTriangulatedPoints,
            final PinholeCamera attemptLeftCamera,
            final PinholeCamera attemptRightCamera,
            final List&lt;Point3D&gt; attemptTriangulatedPoints,
            final BitSet attemptValidTriangulatedPoints)
            throws InitialCamerasEstimationFailedException {

        try {
<span class="fc" id="L1094">            leftCamera.setInternalMatrix(attemptLeftCamera.getInternalMatrix());</span>
<span class="fc" id="L1095">            rightCamera.setInternalMatrix(attemptRightCamera.getInternalMatrix());</span>
<span class="pc bpc" id="L1096" title="1 of 4 branches missed.">            if (triangulatedPoints != null &amp;&amp; attemptTriangulatedPoints != null) {</span>
<span class="fc" id="L1097">                triangulatedPoints.clear();</span>
<span class="fc" id="L1098">                triangulatedPoints.addAll(attemptTriangulatedPoints);</span>
            }
<span class="pc bpc" id="L1100" title="1 of 4 branches missed.">            if (validTriangulatedPoints != null &amp;&amp; attemptValidTriangulatedPoints != null) {</span>
<span class="fc" id="L1101">                validTriangulatedPoints.clear();</span>
<span class="fc" id="L1102">                validTriangulatedPoints.or(attemptValidTriangulatedPoints);</span>
            }
<span class="nc" id="L1104">        } catch (final WrongSizeException e) {</span>
<span class="nc" id="L1105">            throw new InitialCamerasEstimationFailedException(e);</span>
<span class="fc" id="L1106">        }</span>
<span class="fc" id="L1107">    }</span>

    /**
     * Computes a pair of cameras for provided rotation and translation
     * using provided intrinsic parameters.
     * This method also triangulates proved matched 2D points and determines
     * how many of them lie in front of both estimated cameras.
     *
     * @param rotation                rotation between estimated left and right cameras.
     * @param translation             translation between estimated left and right cameras.
     * @param leftIntrinsic           intrinsic parameters to set on estimated left
     *                                camera.
     * @param rightIntrinsic          intrinsic parameters to set on estimated right
     *                                camera.
     * @param leftPoints              points on left view matched with points on right view,
     *                                so they can be triangulated using estimated cameras. Both lists
     *                                of points must have the same size.
     * @param rightPoints             points on right view matched with points on left view,
     *                                so they can be triangulated using estimated cameras. Both lists
     *                                of points must have the same size.
     * @param estimatedLeftCamera     instance where estimated left camera will be
     *                                stored.
     * @param estimatedRightCamera    instance where estimated right camera will be
     *                                stored.
     * @param triangulatedPoints      instance where triangulated 3D points will be
     *                                stored or null if triangulated points don't need to be kept.
     * @param validTriangulatedPoints instance which indicates which
     *                                triangulated 3D points are considered valid because they lie in
     *                                front of both cameras or null if such data doesn't need to be kept.
     * @return number of valid triangulated points which lie in front of the two
     * estimated cameras.
     * @throws WrongSizeException            never occurs.
     * @throws CameraException               if any of the estimated cameras become
     *                                       numerically unstable.
     * @throws LockedException               never occurs.
     * @throws NotReadyException             never occurs.
     * @throws Point3DTriangulationException if points cannot be triangulated
     *                                       because of numerical instabilities.
     */
    private static int computeCamerasAndTriangulation(
            final Rotation3D rotation,
            final Point2D translation,
            final PinholeCameraIntrinsicParameters leftIntrinsic,
            final PinholeCameraIntrinsicParameters rightIntrinsic,
            final List&lt;Point2D&gt; leftPoints,
            final List&lt;Point2D&gt; rightPoints,
            final PinholeCamera estimatedLeftCamera,
            final PinholeCamera estimatedRightCamera,
            final List&lt;Point3D&gt; triangulatedPoints,
            final BitSet validTriangulatedPoints) throws WrongSizeException, CameraException, LockedException,
            NotReadyException, Point3DTriangulationException {

<span class="fc bfc" id="L1159" title="All 2 branches covered.">        if (triangulatedPoints != null) {</span>
<span class="fc" id="L1160">            triangulatedPoints.clear();</span>
        }
<span class="fc bfc" id="L1162" title="All 2 branches covered.">        if (validTriangulatedPoints != null) {</span>
<span class="fc" id="L1163">            validTriangulatedPoints.clear();</span>
        }
<span class="fc" id="L1165">        var numValidTriangulatedPoints = 0;</span>

<span class="fc" id="L1167">        final var leftIntrinsicMatrix = leftIntrinsic.getInternalMatrix();</span>
<span class="fc" id="L1168">        final var rightIntrinsicMatrix = rightIntrinsic.getInternalMatrix();</span>

<span class="fc" id="L1170">        final var rotationMatrix = rotation.asInhomogeneousMatrix();</span>

        // 1st camera

        // set camera as a canonical matrix
<span class="fc" id="L1175">        final var tmp = Matrix.identity(PinholeCamera.PINHOLE_CAMERA_MATRIX_ROWS,</span>
                PinholeCamera.PINHOLE_CAMERA_MATRIX_COLS);

        // add intrinsic parameters
<span class="fc" id="L1179">        leftIntrinsicMatrix.multiply(tmp);</span>

        // set internal matrix, normalize and fix camera sign
<span class="fc" id="L1182">        estimatedLeftCamera.setInternalMatrix(leftIntrinsicMatrix);</span>
<span class="fc" id="L1183">        estimatedLeftCamera.normalize();</span>
<span class="fc" id="L1184">        estimatedLeftCamera.fixCameraSign();</span>

        // 2nd camera

        // set left 3x3 minor containing rotation
<span class="fc" id="L1189">        tmp.setSubmatrix(0, 0, 2, 2, rotationMatrix);</span>

        // set last column containing translation
<span class="fc" id="L1192">        translation.normalize();</span>
<span class="fc" id="L1193">        tmp.setElementAt(0, 3, translation.getHomX());</span>
<span class="fc" id="L1194">        tmp.setElementAt(1, 3, translation.getHomY());</span>
<span class="fc" id="L1195">        tmp.setElementAt(2, 3, translation.getHomW());</span>

        // add intrinsic parameters
<span class="fc" id="L1198">        rightIntrinsicMatrix.multiply(tmp);</span>

        // set internal matrix, normalize and fix camera sign
<span class="fc" id="L1201">        estimatedRightCamera.setInternalMatrix(rightIntrinsicMatrix);</span>
<span class="fc" id="L1202">        estimatedRightCamera.normalize();</span>
<span class="fc" id="L1203">        estimatedRightCamera.fixCameraSign();</span>

        // set cameras on triangulator
<span class="fc" id="L1206">        final var triangulator = SinglePoint3DTriangulator.create();</span>

<span class="fc" id="L1208">        final var numPoints = leftPoints.size();</span>
        Point2D leftPoint;
        Point2D rightPoint;
<span class="fc" id="L1211">        final var points = new ArrayList&lt;Point2D&gt;();</span>
<span class="fc" id="L1212">        final var cameras = new ArrayList&lt;PinholeCamera&gt;();</span>
        Point3D triangulatedPoint;
        boolean frontLeft;
        boolean frontRight;
<span class="fc bfc" id="L1216" title="All 2 branches covered.">        for (var i = 0; i &lt; numPoints; i++) {</span>
<span class="fc" id="L1217">            leftPoint = leftPoints.get(i);</span>
<span class="fc" id="L1218">            rightPoint = rightPoints.get(i);</span>

<span class="fc" id="L1220">            points.clear();</span>
<span class="fc" id="L1221">            points.add(leftPoint);</span>
<span class="fc" id="L1222">            points.add(rightPoint);</span>

<span class="fc" id="L1224">            cameras.clear();</span>
<span class="fc" id="L1225">            cameras.add(estimatedLeftCamera);</span>
<span class="fc" id="L1226">            cameras.add(estimatedRightCamera);</span>

<span class="fc" id="L1228">            triangulator.setPointsAndCameras(points, cameras);</span>
<span class="fc" id="L1229">            triangulatedPoint = triangulator.triangulate();</span>
<span class="fc bfc" id="L1230" title="All 2 branches covered.">            if (triangulatedPoints != null) {</span>
<span class="fc" id="L1231">                triangulatedPoints.add(triangulatedPoint);</span>
            }

            // check that triangulated point is in front of both cameras
<span class="fc" id="L1235">            frontLeft = estimatedLeftCamera.isPointInFrontOfCamera(triangulatedPoint);</span>
<span class="fc" id="L1236">            frontRight = estimatedRightCamera.isPointInFrontOfCamera(triangulatedPoint);</span>

<span class="fc bfc" id="L1238" title="All 4 branches covered.">            if (frontLeft &amp;&amp; frontRight) {</span>
                // point is valid because it is in front of both cameras
<span class="fc bfc" id="L1240" title="All 2 branches covered.">                if (validTriangulatedPoints != null) {</span>
<span class="fc" id="L1241">                    validTriangulatedPoints.set(i);</span>
                }
<span class="fc" id="L1243">                numValidTriangulatedPoints++;</span>
            } else {
                // point is not valid
<span class="fc bfc" id="L1246" title="All 2 branches covered.">                if (validTriangulatedPoints != null) {</span>
<span class="fc" id="L1247">                    validTriangulatedPoints.clear(i);</span>
                }
            }
        }

<span class="fc" id="L1252">        return numValidTriangulatedPoints;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>