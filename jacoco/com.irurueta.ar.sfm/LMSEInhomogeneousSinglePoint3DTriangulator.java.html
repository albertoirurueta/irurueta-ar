<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LMSEInhomogeneousSinglePoint3DTriangulator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.sfm</a> &gt; <span class="el_source">LMSEInhomogeneousSinglePoint3DTriangulator.java</span></div><h1>LMSEInhomogeneousSinglePoint3DTriangulator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2015 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.sfm;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.SingularValueDecomposer;
import com.irurueta.geometry.PinholeCamera;
import com.irurueta.geometry.Plane;
import com.irurueta.geometry.Point2D;
import com.irurueta.geometry.Point3D;
import com.irurueta.geometry.estimators.LockedException;

import java.util.List;

/**
 * Triangulates matched 2D points into a single 3D one by using 2D point
 * correspondences on different views along with the corresponding cameras on
 * each of those views by finding an LMSE solution to homogeneous systems of
 * equations.
 */
public class LMSEInhomogeneousSinglePoint3DTriangulator extends SinglePoint3DTriangulator {

    /**
     * Indicates if by default an LMSE (the Least Mean Square Error) is allowed if
     * more correspondences than the minimum are provided.
     */
    public static final boolean DEFAULT_ALLOW_LMSE_SOLUTION = false;

    /**
     * Indicates if an LMSE (the Least Mean Square Error) solution is allowed if
     * more correspondences than the minimum are provided. If false, the
     * exceeding correspondences will be ignored and only the 6 first
     * correspondences will be used.
     */
    private boolean allowLMSESolution;

    /**
     * Constructor.
     */
    public LMSEInhomogeneousSinglePoint3DTriangulator() {
<span class="fc" id="L55">        super();</span>
<span class="fc" id="L56">        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;</span>
<span class="fc" id="L57">    }</span>

    /**
     * Constructor.
     *
     * @param points2D list of matched 2D points on each view. Each point in the
     *                 list is assumed to be projected by the corresponding camera in the list.
     * @param cameras  camera for each view where 2D points are represented.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  length or their length is less than 2 views, which is the minimum
     *                                  required to compute triangulation.
     */
    public LMSEInhomogeneousSinglePoint3DTriangulator(final List&lt;Point2D&gt; points2D, final List&lt;PinholeCamera&gt; cameras) {
<span class="fc" id="L70">        super(points2D, cameras);</span>
<span class="fc" id="L71">        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;</span>
<span class="fc" id="L72">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to notify events generated by instances of this
     *                 class.
     */
    public LMSEInhomogeneousSinglePoint3DTriangulator(final SinglePoint3DTriangulatorListener listener) {
<span class="fc" id="L81">        super(listener);</span>
<span class="fc" id="L82">        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;</span>
<span class="fc" id="L83">    }</span>

    /**
     * Constructor.
     *
     * @param points2D list of matched 2D points on each view. Each point in the
     *                 list is assumed to be projected by the corresponding camera in the list.
     * @param cameras  cameras for each view where 2D points are represented.
     * @param listener listener to notify events generated by instances of this
     *                 class.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  length or their length is less than 2 views, which is the minimum
     *                                  required to compute triangulation.
     */
    public LMSEInhomogeneousSinglePoint3DTriangulator(final List&lt;Point2D&gt; points2D,
                                                      final List&lt;PinholeCamera&gt; cameras,
                                                      final SinglePoint3DTriangulatorListener listener) {
<span class="fc" id="L100">        super(points2D, cameras, listener);</span>
<span class="fc" id="L101">        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;</span>
<span class="fc" id="L102">    }</span>

    /**
     * Indicates if an LMSE (the Least Mean Square Error) solution is allowed if
     * more correspondences than the minimum are provided. If false, the
     * exceeding correspondences will be ignored and only the 2 first matches
     * corresponding to the first 2 views will be used.
     *
     * @return true if LMSE solution is allowed, false otherwise.
     */
    public boolean isLMSESolutionAllowed() {
<span class="fc" id="L113">        return allowLMSESolution;</span>
    }

    /**
     * Specifies if an LMSE (the Least Mean Square Error) solution is allowed if
     * more correspondences than the minimum are provided. If false, the
     * exceeding correspondences will be ignored and only the 2 first matches
     * corresponding to the first 2 views will be used.
     *
     * @param allowed true if LMSE solution is allowed, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setLMSESolutionAllowed(final boolean allowed) throws LockedException {
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L127">            throw new LockedException();</span>
        }
<span class="fc" id="L129">        allowLMSESolution = allowed;</span>
<span class="fc" id="L130">    }</span>

    /**
     * Returns type of triangulator.
     *
     * @return type of triangulator.
     */
    @Override
    public Point3DTriangulatorType getType() {
<span class="fc" id="L139">        return Point3DTriangulatorType.LMSE_INHOMOGENEOUS_TRIANGULATOR;</span>
    }

    /**
     * Internal method to triangulate provided matched 2D points being projected
     * by each corresponding camera into a single 3D point.
     * At least 2 matched 2D points and their corresponding 2 cameras are
     * required to compute triangulation. If more views are provided, an
     * averaged solution is found.
     * This method does not check whether instance is locked or ready
     *
     * @param points2D matched 2D points. Each point in the list is assumed to
     *                 be projected by the corresponding camera in the list.
     * @param cameras  list of cameras associated to the matched 2D point on the
     *                 same position as the camera on the list.
     * @param result   instance where triangulated 3D point is stored.
     * @throws Point3DTriangulationException if triangulation fails for some
     *                                       other reason (i.e. degenerate geometry, numerical
     *                                       instabilities, etc.).
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    @Override
    protected void triangulate(
            final List&lt;Point2D&gt; points2D, final List&lt;PinholeCamera&gt; cameras, final Point3D result)
            throws Point3DTriangulationException {
        try {
<span class="fc" id="L165">            locked = true;</span>

<span class="pc bpc" id="L167" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L168">                listener.onTriangulateStart(this);</span>
            }

<span class="fc" id="L171">            final var numViews = cameras.size();</span>

            final Matrix a;
            final double[] b;
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">            if (allowLMSESolution) {</span>
                // each view will add 2 equations to the linear system of
                // equations
<span class="nc" id="L178">                a = new Matrix(2 * numViews, 3);</span>
<span class="nc" id="L179">                b = new double[2 * numViews];</span>
            } else {
<span class="fc" id="L181">                a = new Matrix(2 * MIN_REQUIRED_VIEWS, 3);</span>
<span class="fc" id="L182">                b = new double[2 * MIN_REQUIRED_VIEWS];</span>
            }

            Point2D point;
            PinholeCamera camera;
<span class="fc" id="L187">            final var horizontalAxisPlane = new Plane();</span>
<span class="fc" id="L188">            final var verticalAxisPlane = new Plane();</span>
<span class="fc" id="L189">            final var principalPlane = new Plane();</span>
<span class="fc" id="L190">            var row = 0;</span>
            double rowNorm;
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">            for (var i = 0; i &lt; numViews; i++) {</span>
<span class="fc" id="L193">                point = points2D.get(i);</span>
<span class="fc" id="L194">                camera = cameras.get(i);</span>

                // to increase accuracy
<span class="fc" id="L197">                point.normalize();</span>
<span class="fc" id="L198">                camera.normalize();</span>

<span class="fc" id="L200">                final var homX = point.getHomX();</span>
<span class="fc" id="L201">                final var homY = point.getHomY();</span>
<span class="fc" id="L202">                final var homW = point.getHomW();</span>

                // pick rows of camera corresponding to different planes
                // (we do not normalize planes, as it would introduce errors)

                // 1st camera row (p1T)
<span class="fc" id="L208">                camera.verticalAxisPlane(verticalAxisPlane);</span>
                // 2nd camera row (p2T)
<span class="fc" id="L210">                camera.horizontalAxisPlane(horizontalAxisPlane);</span>
                // 3rd camera row (p3T)
<span class="fc" id="L212">                camera.principalPlane(principalPlane);</span>

                // 1st equation
<span class="fc" id="L215">                a.setElementAt(row, 0, homX * principalPlane.getA() - homW * verticalAxisPlane.getA());</span>
<span class="fc" id="L216">                a.setElementAt(row, 1, homX * principalPlane.getB() - homW * verticalAxisPlane.getB());</span>
<span class="fc" id="L217">                a.setElementAt(row, 2, homX * principalPlane.getC() - homW * verticalAxisPlane.getC());</span>

<span class="fc" id="L219">                b[row] = homW * verticalAxisPlane.getD() - homX * principalPlane.getD();</span>

                // normalize equation to increase accuracy
<span class="fc" id="L222">                rowNorm = Math.sqrt(Math.pow(a.getElementAt(row, 0), 2.0)</span>
<span class="fc" id="L223">                        + Math.pow(a.getElementAt(row, 1), 2.0)</span>
<span class="fc" id="L224">                        + Math.pow(a.getElementAt(row, 2), 2.0));</span>

<span class="fc" id="L226">                a.setElementAt(row, 0, a.getElementAt(row, 0) / rowNorm);</span>
<span class="fc" id="L227">                a.setElementAt(row, 1, a.getElementAt(row, 1) / rowNorm);</span>
<span class="fc" id="L228">                a.setElementAt(row, 2, a.getElementAt(row, 2) / rowNorm);</span>
<span class="fc" id="L229">                b[row] /= rowNorm;</span>

                // 2nd equation
<span class="fc" id="L232">                row++;</span>

<span class="fc" id="L234">                a.setElementAt(row, 0, homY * principalPlane.getA() - homW * horizontalAxisPlane.getA());</span>
<span class="fc" id="L235">                a.setElementAt(row, 1, homY * principalPlane.getB() - homW * horizontalAxisPlane.getB());</span>
<span class="fc" id="L236">                a.setElementAt(row, 2, homY * principalPlane.getC() - homW * horizontalAxisPlane.getC());</span>

<span class="fc" id="L238">                b[row] = homW * horizontalAxisPlane.getD() - homY * principalPlane.getD();</span>

                // normalize equation to increase accuracy
<span class="fc" id="L241">                rowNorm = Math.sqrt(Math.pow(a.getElementAt(row, 0), 2.0)</span>
<span class="fc" id="L242">                        + Math.pow(a.getElementAt(row, 1), 2.0)</span>
<span class="fc" id="L243">                        + Math.pow(a.getElementAt(row, 2), 2.0));</span>

<span class="fc" id="L245">                a.setElementAt(row, 0, a.getElementAt(row, 0) / rowNorm);</span>
<span class="fc" id="L246">                a.setElementAt(row, 1, a.getElementAt(row, 1) / rowNorm);</span>
<span class="fc" id="L247">                a.setElementAt(row, 2, a.getElementAt(row, 2) / rowNorm);</span>
<span class="fc" id="L248">                b[row] /= rowNorm;</span>

<span class="pc bpc" id="L250" title="1 of 4 branches missed.">                if (!allowLMSESolution &amp;&amp; i == MIN_REQUIRED_VIEWS) {</span>
<span class="fc" id="L251">                    break;</span>
                }
            }

            // make SVD to find solution of A * M = b
<span class="fc" id="L256">            final var decomposer = new SingularValueDecomposer(a);</span>

<span class="fc" id="L258">            decomposer.decompose();</span>

            // solve linear system of equations to obtain inhomogeneous
            // coordinates of triangulated point
<span class="fc" id="L262">            final var solution = decomposer.solve(b);</span>

<span class="fc" id="L264">            result.setInhomogeneousCoordinates(solution[0], solution[1], solution[2]);</span>

<span class="pc bpc" id="L266" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L267">                listener.onTriangulateEnd(this);</span>
            }
<span class="nc" id="L269">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L270">            throw new Point3DTriangulationException(e);</span>
        } finally {
<span class="fc" id="L272">            locked = false;</span>
        }
<span class="fc" id="L274">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>