<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WeightedHomogeneousSinglePoint3DTriangulator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.sfm</a> &gt; <span class="el_source">WeightedHomogeneousSinglePoint3DTriangulator.java</span></div><h1>WeightedHomogeneousSinglePoint3DTriangulator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2015 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.sfm;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.SingularValueDecomposer;
import com.irurueta.geometry.PinholeCamera;
import com.irurueta.geometry.Plane;
import com.irurueta.geometry.Point2D;
import com.irurueta.geometry.Point3D;
import com.irurueta.geometry.estimators.LockedException;
import com.irurueta.numerical.robust.WeightSelection;
import com.irurueta.sorting.SortingException;

import java.util.List;

/**
 * Triangulates matched 2D points into a single 3D one by using 2D point
 * correspondences on different views along with the corresponding cameras on
 * each of those views by finding a weighted solution to homogeneous systems
 * of equations.
 * Each equation on the linear system of equations is weighted using provided
 * weight for each point and camera correspondence, so that some equations can
 * be considered more important than others if we are more confident on some
 * measures than others.
 */
public class WeightedHomogeneousSinglePoint3DTriangulator extends SinglePoint3DTriangulator {

    /**
     * Default number of correspondences to be weighted and taken into account.
     * If more correspondences are provided, they are ignored to avoid numerical
     * inaccuracies.
     */
    public static final int DEFAULT_MAX_CORRESPONDENCES = 50;

    /**
     * Indicates if weights are sorted by default so that largest weighted
     * correspondences are used first.
     */
    public static final boolean DEFAULT_SORT_WEIGHTS = true;

    /**
     * Maximum number of correspondences to be weighted and taken into account.
     */
    private int maxCorrespondences;

    /**
     * Indicates if weights are sorted by default so that largest weighted
     * correspondences are used first.
     */
    private boolean sortWeights;

    /**
     * Array containing weights for all correspondences.
     */
    private double[] weights;

    /**
     * Constructor.
     */
    public WeightedHomogeneousSinglePoint3DTriangulator() {
<span class="fc" id="L76">        super();</span>
<span class="fc" id="L77">        maxCorrespondences = DEFAULT_MAX_CORRESPONDENCES;</span>
<span class="fc" id="L78">        sortWeights = DEFAULT_SORT_WEIGHTS;</span>
<span class="fc" id="L79">    }</span>

    /**
     * Constructor.
     *
     * @param points2D list of matched 2D points on each view. Each point in the
     *                 list is assumed to be projected by the corresponding camera in the list.
     * @param cameras  camera for each view where 2D points are represented.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  length or their length is less than 2 views, which is the minimum
     *                                  required to compute triangulation.
     */
    public WeightedHomogeneousSinglePoint3DTriangulator(
            final List&lt;Point2D&gt; points2D, final List&lt;PinholeCamera&gt; cameras) {
<span class="fc" id="L93">        super(points2D, cameras);</span>
<span class="fc" id="L94">        maxCorrespondences = DEFAULT_MAX_CORRESPONDENCES;</span>
<span class="fc" id="L95">        sortWeights = DEFAULT_SORT_WEIGHTS;</span>
<span class="fc" id="L96">    }</span>

    /**
     * Constructor.
     *
     * @param points2D list of matched 2D points on each view. Each point in the
     *                 list is assumed to be projected by the corresponding camera in the list.
     * @param cameras  camera for each view where 2D points are represented.
     * @param weights  weights assigned to each view.
     * @throws IllegalArgumentException if provided lists or weights don't have
     *                                  the same length or their length is less than 2 views, which is the
     *                                  minimum required to compute triangulation.
     */
    public WeightedHomogeneousSinglePoint3DTriangulator(
            final List&lt;Point2D&gt; points2D, final List&lt;PinholeCamera&gt; cameras, final double[] weights) {
<span class="fc" id="L111">        this();</span>
<span class="fc" id="L112">        internalSetPointsCamerasAndWeights(points2D, cameras, weights);</span>
<span class="fc" id="L113">    }</span>


    /**
     * Constructor.
     *
     * @param listener listener to notify events generated by instances of this
     *                 class.
     */
    public WeightedHomogeneousSinglePoint3DTriangulator(final SinglePoint3DTriangulatorListener listener) {
<span class="fc" id="L123">        super(listener);</span>
<span class="fc" id="L124">        maxCorrespondences = DEFAULT_MAX_CORRESPONDENCES;</span>
<span class="fc" id="L125">        sortWeights = DEFAULT_SORT_WEIGHTS;</span>
<span class="fc" id="L126">    }</span>

    /**
     * Constructor.
     *
     * @param points2D list of matched 2D points on each view. Each point in the
     *                 list is assumed to be projected by the corresponding camera in the list.
     * @param cameras  cameras for each view where 2D points are represented.
     * @param listener listener to notify events generated by instances of this
     *                 class.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  length or their length is less than 2 views, which is the minimum
     *                                  required to compute triangulation.
     */
    public WeightedHomogeneousSinglePoint3DTriangulator(
            final List&lt;Point2D&gt; points2D, final List&lt;PinholeCamera&gt; cameras,
            final SinglePoint3DTriangulatorListener listener) {
<span class="fc" id="L143">        super(points2D, cameras, listener);</span>
<span class="fc" id="L144">        maxCorrespondences = DEFAULT_MAX_CORRESPONDENCES;</span>
<span class="fc" id="L145">        sortWeights = DEFAULT_SORT_WEIGHTS;</span>
<span class="fc" id="L146">    }</span>

    /**
     * Constructor.
     *
     * @param points2D list of matched 2D points on each view. Each point in the
     *                 list is assumed to be projected by the corresponding camera in the list.
     * @param cameras  camera for each view where 2D points are represented.
     * @param weights  weights assigned to each view.
     * @param listener listener to notify events generated by instances of this
     *                 class.
     * @throws IllegalArgumentException if provided lists or weights don't have
     *                                  the same length or their length is less than 2 views, which is the
     *                                  minimum required to compute triangulation.
     */
    public WeightedHomogeneousSinglePoint3DTriangulator(
            final List&lt;Point2D&gt; points2D, final List&lt;PinholeCamera&gt; cameras, final double[] weights,
            final SinglePoint3DTriangulatorListener listener) {
<span class="fc" id="L164">        this(listener);</span>
<span class="fc" id="L165">        internalSetPointsCamerasAndWeights(points2D, cameras, weights);</span>
<span class="fc" id="L166">    }</span>

    /**
     * Returns weights assigned to each view.
     * The larger a weight is the more reliable a view is considered and
     * equations to triangulate a 3D point will be take precedence over other
     * views when estimating an averaged solution.
     *
     * @return weights assigned to each view.
     */
    public double[] getWeights() {
<span class="fc" id="L177">        return weights;</span>
    }

    /**
     * Sets list of matched 2D points for each view and their corresponding
     * cameras used to project them along with their weights.
     *
     * @param points2D list of matched 2D points on each view. Each point in the
     *                 list is assumed to be projected by the corresponding camera in the list.
     * @param cameras  cameras for each view where 2D points are represented.
     * @param weights  weights assigned to each view.
     * @throws LockedException          if this instance is locked.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  length or their length is less than 2 views, which is the minimum
     *                                  required to compute triangulation.
     */
    public void setPointsCamerasAndWeights(
            final List&lt;Point2D&gt; points2D, final List&lt;PinholeCamera&gt; cameras, final double[] weights)
            throws LockedException {
<span class="fc bfc" id="L196" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L197">            throw new LockedException();</span>
        }
<span class="fc" id="L199">        internalSetPointsCamerasAndWeights(points2D, cameras, weights);</span>
<span class="fc" id="L200">    }</span>

    /**
     * Indicates whether this instance is ready to start the triangulation.
     * An instance is ready when both lists of 2D points and cameras are
     * provided, both lists have the same length, at least data for 2 views
     * is provided and the corresponding weights are also provided.
     *
     * @return true if this instance is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
<span class="fc" id="L212">        return areValidPointsCamerasAndWeights(points2D, cameras, weights);</span>
    }

    /**
     * Indicates whether provided points, cameras and weights are valid to start
     * the triangulation.
     * In order to triangulate points, at least two cameras and their
     * corresponding 2 matched 2D points are required along with weights for
     * each view.
     * If more views are provided, an averaged solution can be found.
     *
     * @param points2D list of matched points on each view.
     * @param cameras  cameras for each view where 2D points are represented.
     * @param weights  weights assigned to each view.
     * @return true if data is enough to start triangulation, false otherwise.
     */
    public static boolean areValidPointsCamerasAndWeights(
            final List&lt;Point2D&gt; points2D, final List&lt;PinholeCamera&gt; cameras, final double[] weights) {
<span class="fc bfc" id="L230" title="All 6 branches covered.">        return areValidPointsAndCameras(points2D, cameras) &amp;&amp; weights != null &amp;&amp; weights.length == points2D.size();</span>
    }

    /**
     * Returns maximum number of correspondences to be weighted and taken into
     * account.
     *
     * @return maximum number of correspondences to be weighted.
     */
    public int getMaxCorrespondences() {
<span class="fc" id="L240">        return maxCorrespondences;</span>
    }

    /**
     * Sets maximum number of correspondences to be weighted and taken into
     * account.
     *
     * @param maxCorrespondences maximum number of correspondences to be
     *                           weighted.
     * @throws IllegalArgumentException if provided value is less than the
     *                                  minimum required number of views, which is 2.
     * @throws LockedException          if this instance is locked.
     */
    public void setMaxCorrespondences(final int maxCorrespondences) throws LockedException {
<span class="fc bfc" id="L254" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L255">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (maxCorrespondences &lt; MIN_REQUIRED_VIEWS) {</span>
<span class="fc" id="L258">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L261">        this.maxCorrespondences = maxCorrespondences;</span>
<span class="fc" id="L262">    }</span>

    /**
     * Indicates if weights are sorted by so that largest weighted
     * correspondences are used first.
     *
     * @return true if weights are sorted, false otherwise.
     */
    public boolean isSortWeightsEnabled() {
<span class="fc" id="L271">        return sortWeights;</span>
    }

    /**
     * Specifies whether weights are sorted by so that largest weighted
     * correspondences are used first.
     *
     * @param sortWeights true if weights are sorted, false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setSortWeightsEnabled(final boolean sortWeights) throws LockedException {
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L283">            throw new LockedException();</span>
        }

<span class="fc" id="L286">        this.sortWeights = sortWeights;</span>
<span class="fc" id="L287">    }</span>

    /**
     * Returns type of triangulator.
     *
     * @return type of triangulator.
     */
    @Override
    public Point3DTriangulatorType getType() {
<span class="fc" id="L296">        return Point3DTriangulatorType.WEIGHTED_HOMOGENEOUS_TRIANGULATOR;</span>
    }

    /**
     * Internal method to triangulate provided matched 2D points being projected
     * by each corresponding camera into a single 3D point.
     * At least 2 matched 2D points and their corresponding 2 cameras are
     * required to compute triangulation. If more views are provided, an
     * averaged solution is found.
     * This method does not check whether instance is locked or ready.
     *
     * @param points2D matched 2D points. Each point in the list is assumed to
     *                 be projected by the corresponding camera in the list.
     * @param cameras  list of cameras associated to the matched 2D point on the
     *                 same position as the camera on the list.
     * @param result   instance where triangulated 3D point is stored.
     * @throws Point3DTriangulationException if triangulation fails for some
     *                                       other reason (i.e. degenerate geometry, numerical
     *                                       instabilities, etc.).
     */
    @Override
    @SuppressWarnings(&quot;Duplicates&quot;)
    protected void triangulate(final List&lt;Point2D&gt; points2D, final List&lt;PinholeCamera&gt; cameras, final Point3D result)
            throws Point3DTriangulationException {
        try {
<span class="fc" id="L321">            locked = true;</span>

<span class="pc bpc" id="L323" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L324">                listener.onTriangulateStart(this);</span>
            }

<span class="fc" id="L327">            final var selection = WeightSelection.selectWeights(weights, sortWeights, maxCorrespondences);</span>

<span class="fc" id="L329">            final var selected = selection.getSelected();</span>

<span class="fc" id="L331">            final var numViews = cameras.size();</span>

<span class="fc" id="L333">            final var a = new Matrix(2 * numViews, 2 * MIN_REQUIRED_VIEWS);</span>

<span class="fc" id="L335">            final var horizontalAxisPlane = new Plane();</span>
<span class="fc" id="L336">            final var verticalAxisPlane = new Plane();</span>
<span class="fc" id="L337">            final var principalPlane = new Plane();</span>
<span class="fc" id="L338">            var row = 0;</span>
            double rowNorm;
<span class="fc bfc" id="L340" title="All 2 branches covered.">            for (var i = 0; i &lt; numViews; i++) {</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">                if (selected[i]) {</span>
<span class="fc" id="L342">                    final var point = points2D.get(i);</span>
<span class="fc" id="L343">                    final var camera = cameras.get(i);</span>

                    // to increase accuracy
<span class="fc" id="L346">                    point.normalize();</span>
<span class="fc" id="L347">                    camera.normalize();</span>

<span class="fc" id="L349">                    final var homX = point.getHomX();</span>
<span class="fc" id="L350">                    final var homY = point.getHomY();</span>
<span class="fc" id="L351">                    final var homW = point.getHomW();</span>

                    // pick rows of camera corresponding to different planes
                    // (we do not normalize planes, as it would introduce errors)

                    // 1st camera row (p1T)
<span class="fc" id="L357">                    camera.verticalAxisPlane(verticalAxisPlane);</span>
                    // 2nd camera row (p2T)
<span class="fc" id="L359">                    camera.horizontalAxisPlane(horizontalAxisPlane);</span>
                    // 3rd camera row (p3T)
<span class="fc" id="L361">                    camera.principalPlane(principalPlane);</span>


                    // 1st equation
<span class="fc" id="L365">                    a.setElementAt(row, 0, homX * principalPlane.getA()</span>
<span class="fc" id="L366">                            - homW * verticalAxisPlane.getA());</span>
<span class="fc" id="L367">                    a.setElementAt(row, 1, homX * principalPlane.getB()</span>
<span class="fc" id="L368">                            - homW * verticalAxisPlane.getB());</span>
<span class="fc" id="L369">                    a.setElementAt(row, 2, homX * principalPlane.getC()</span>
<span class="fc" id="L370">                            - homW * verticalAxisPlane.getC());</span>
<span class="fc" id="L371">                    a.setElementAt(row, 3, homX * principalPlane.getD()</span>
<span class="fc" id="L372">                            - homW * verticalAxisPlane.getD());</span>

                    // normalize row (equation) to increase accuracy
<span class="fc" id="L375">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(row, 0), 2.0)</span>
<span class="fc" id="L376">                            + Math.pow(a.getElementAt(row, 1), 2.0)</span>
<span class="fc" id="L377">                            + Math.pow(a.getElementAt(row, 2), 2.0)</span>
<span class="fc" id="L378">                            + Math.pow(a.getElementAt(row, 3), 2.0));</span>

<span class="fc" id="L380">                    a.setElementAt(row, 0, a.getElementAt(row, 0) / rowNorm);</span>
<span class="fc" id="L381">                    a.setElementAt(row, 1, a.getElementAt(row, 1) / rowNorm);</span>
<span class="fc" id="L382">                    a.setElementAt(row, 2, a.getElementAt(row, 2) / rowNorm);</span>
<span class="fc" id="L383">                    a.setElementAt(row, 3, a.getElementAt(row, 3) / rowNorm);</span>

                    // 2nd equation
<span class="fc" id="L386">                    row++;</span>

<span class="fc" id="L388">                    a.setElementAt(row, 0, homY * principalPlane.getA()</span>
<span class="fc" id="L389">                            - homW * horizontalAxisPlane.getA());</span>
<span class="fc" id="L390">                    a.setElementAt(row, 1, homY * principalPlane.getB()</span>
<span class="fc" id="L391">                            - homW * horizontalAxisPlane.getB());</span>
<span class="fc" id="L392">                    a.setElementAt(row, 2, homY * principalPlane.getC()</span>
<span class="fc" id="L393">                            - homW * horizontalAxisPlane.getC());</span>
<span class="fc" id="L394">                    a.setElementAt(row, 3, homY * principalPlane.getD()</span>
<span class="fc" id="L395">                            - homW * horizontalAxisPlane.getD());</span>

                    // normalize row (equation) to increase accuracy
<span class="fc" id="L398">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(row, 0), 2.0)</span>
<span class="fc" id="L399">                            + Math.pow(a.getElementAt(row, 1), 2.0)</span>
<span class="fc" id="L400">                            + Math.pow(a.getElementAt(row, 2), 2.0)</span>
<span class="fc" id="L401">                            + Math.pow(a.getElementAt(row, 3), 2.0));</span>

<span class="fc" id="L403">                    a.setElementAt(row, 0, a.getElementAt(row, 0) / rowNorm);</span>
<span class="fc" id="L404">                    a.setElementAt(row, 1, a.getElementAt(row, 1) / rowNorm);</span>
<span class="fc" id="L405">                    a.setElementAt(row, 2, a.getElementAt(row, 2) / rowNorm);</span>
<span class="fc" id="L406">                    a.setElementAt(row, 3, a.getElementAt(row, 3) / rowNorm);</span>
                }
            }

            // make SVD to find solution of A * M = 0
<span class="fc" id="L411">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L412">            decomposer.decompose();</span>

<span class="pc bpc" id="L414" title="1 of 2 branches missed.">            if (decomposer.getNullity() &gt; 1) {</span>
                // degenerate case. Unique solution (up to scale) cannot be found
<span class="nc" id="L416">                throw new Point3DTriangulationException();</span>
            }

<span class="fc" id="L419">            final var v = decomposer.getV();</span>

            // last column of v will contain homogeneous coordinates of
            // triangulated point
<span class="fc" id="L423">            result.setHomogeneousCoordinates(v.getElementAt(0, 3),</span>
<span class="fc" id="L424">                    v.getElementAt(1, 3), v.getElementAt(2, 3),</span>
<span class="fc" id="L425">                    v.getElementAt(3, 3));</span>

<span class="pc bpc" id="L427" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L428">                listener.onTriangulateEnd(this);</span>
            }
<span class="nc" id="L430">        } catch (final AlgebraException | SortingException e) {</span>
<span class="nc" id="L431">            throw new Point3DTriangulationException(e);</span>
        } finally {
<span class="fc" id="L433">            locked = false;</span>
        }

<span class="fc" id="L436">    }</span>

    /**
     * Internal method to set list of matched 2D points for each view and their
     * corresponding cameras used to project them along with their weights.
     * This method does not check whether instance is locked.
     *
     * @param points2D list of matched 2D points on each view. Each point in the
     *                 list is assumed to be projected by the corresponding camera in the list.
     * @param cameras  cameras for each view where 2D points are represented.
     * @param weights  weights assigned to each view.
     * @throws IllegalArgumentException if provided lists don't have the same
     *                                  length or their length is less than 2 views, which is the minimum
     *                                  required to compute triangulation.
     */
    private void internalSetPointsCamerasAndWeights(
            final List&lt;Point2D&gt; points2D, final List&lt;PinholeCamera&gt; cameras, final double[] weights) {
<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (!areValidPointsCamerasAndWeights(points2D, cameras, weights)) {</span>
<span class="fc" id="L454">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L457">        this.points2D = points2D;</span>
<span class="fc" id="L458">        this.cameras = cameras;</span>
<span class="fc" id="L459">        this.weights = weights;</span>
<span class="fc" id="L460">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>