<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LMSEImageOfAbsoluteConicEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.calibration.estimators</a> &gt; <span class="el_source">LMSEImageOfAbsoluteConicEstimator.java</span></div><h1>LMSEImageOfAbsoluteConicEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2015 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.calibration.estimators;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.SingularValueDecomposer;
import com.irurueta.ar.calibration.ImageOfAbsoluteConic;
import com.irurueta.geometry.ProjectiveTransformation2D;
import com.irurueta.geometry.Transformation2D;
import com.irurueta.geometry.estimators.LockedException;
import com.irurueta.geometry.estimators.NotReadyException;

import java.util.List;

/**
 * This class defines an LMSE (the Least Mean Square Error) estimator of Image
 * of Absolute Conic (IAC).
 * Aside from enabling constraints whenever possible to obtain more stable and
 * accurate results, it is also discouraged to enable LMSE solutions, or at
 * least if LMSE must be used, the minimum possible number of homographies
 * should be provided in order to introduce the least amount of rounding errors
 * possible.
 * If a large number of homographies is available (assuming constant IAC),
 * instead a robust estimation method should be chosen to discard outliers and
 * obtain the most accurate and stable solution possible.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class LMSEImageOfAbsoluteConicEstimator extends ImageOfAbsoluteConicEstimator {

    /**
     * Indicates if by default an LMSE (the Least Mean Square Error) solution is
     * allowed if more homographies than the minimum are provided.
     */
    public static final boolean DEFAULT_ALLOW_LMSE_SOLUTION = false;

    /**
     * Indicates if an LMSE (the Least Mean Square Error) solution is allowed if
     * more homographies than the minimum are provided. If false, the
     * exceeding homographies will be ignored and only the first required
     * homographies will be used.
     */
    private boolean allowLMSESolution;

    /**
     * Constructor.
     */
    public LMSEImageOfAbsoluteConicEstimator() {
<span class="fc" id="L62">        super();</span>
<span class="fc" id="L63">        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;</span>
<span class="fc" id="L64">    }</span>

    /**
     * Constructor with listener.
     *
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     */
    public LMSEImageOfAbsoluteConicEstimator(final ImageOfAbsoluteConicEstimatorListener listener) {
<span class="fc" id="L73">        super(listener);</span>
<span class="fc" id="L74">        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;</span>
<span class="fc" id="L75">    }</span>

    /**
     * Constructor
     *
     * @param homographies list of homographies (2D transformations) used to
     *                     estimate the image of absolute conic (IAC), which can be used to obtain
     *                     pinhole camera intrinsic parameters.
     * @throws IllegalArgumentException if not enough homographies are provided
     *                                  for default IAC estimation constraints.
     */
    public LMSEImageOfAbsoluteConicEstimator(final List&lt;Transformation2D&gt; homographies) {
<span class="fc" id="L87">        super(homographies);</span>
<span class="fc" id="L88">        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;</span>
<span class="fc" id="L89">    }</span>

    /**
     * Constructor
     *
     * @param homographies list of homographies (2D transformations) used to
     *                     estimate the image of absolute conic (IAC), which can be used to obtain
     *                     pinhole camera intrinsic parameters.
     * @param listener     listener to be notified of events such as when estimation
     *                     starts, ends or estimation progress changes.
     * @throws IllegalArgumentException if not enough homographies are provided
     *                                  for default IAC estimation constraints.
     */
    public LMSEImageOfAbsoluteConicEstimator(
            final List&lt;Transformation2D&gt; homographies, final ImageOfAbsoluteConicEstimatorListener listener) {
<span class="fc" id="L104">        super(homographies, listener);</span>
<span class="fc" id="L105">        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;</span>
<span class="fc" id="L106">    }</span>

    /**
     * Indicates if an LMSE (the Least Mean Square Error) solution is allowed if
     * more homographies than the minimum are provided. If false, the
     * exceeding homographies will be ignored and only the first required
     * correspondences will be used.
     *
     * @return true if LMSE solution is allowed, false otherwise.
     */
    public boolean isLMSESolutionAllowed() {
<span class="fc" id="L117">        return allowLMSESolution;</span>
    }

    /**
     * Specifies if an LMSE (the Least Mean Square Error) solution is allowed if
     * more homographies than the minimum are provided. If false, the
     * exceeding homographies will be ignored and only the first required ones
     * will be used.
     *
     * @param allowed true if LMSE solution is allowed, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setLMSESolutionAllowed(final boolean allowed) throws LockedException {
<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L131">            throw new LockedException();</span>
        }
<span class="fc" id="L133">        allowLMSESolution = allowed;</span>
<span class="fc" id="L134">    }</span>

    /**
     * Estimates Image of Absolute Conic (IAC).
     *
     * @return estimated IAC.
     * @throws LockedException                        if estimator is locked.
     * @throws NotReadyException                      if input has not yet been provided.
     * @throws ImageOfAbsoluteConicEstimatorException if an error occurs during
     *                                                estimation, usually because repeated homographies are
     *                                                provided, or homographies corresponding to degenerate
     *                                                camera movements such as pure parallel translations
     *                                                where no additional data is really provided. Indeed,
     *                                                if provided homographies belong to the group of affine
     *                                                transformations (or other groups contained within
     *                                                such as metric or Euclidean ones), this exception will
     *                                                raise because camera movements will be degenerate. To
     *                                                avoid this exception, homographies must be purely
     *                                                projective.
     */
    @Override
    public ImageOfAbsoluteConic estimate() throws LockedException, NotReadyException,
            ImageOfAbsoluteConicEstimatorException {
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L158">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L161">            throw new NotReadyException();</span>
        }

        try {
<span class="fc" id="L165">            locked = true;</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L167">                listener.onEstimateStart(this);</span>
            }

            final ImageOfAbsoluteConic iac;
<span class="fc bfc" id="L171" title="All 4 branches covered.">            if (zeroSkewness &amp;&amp; principalPointAtOrigin) {</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">                if (focalDistanceAspectRatioKnown) {</span>
<span class="fc" id="L173">                    iac = estimateZeroSkewnessPrincipalPointAtOriginAndKnownFocalDistanceAspectRatio();</span>
                } else {
<span class="fc" id="L175">                    iac = estimateZeroSkewnessAndPrincipalPointAtOrigin();</span>
                }
<span class="fc bfc" id="L177" title="All 2 branches covered.">            } else if (zeroSkewness) { // &amp;&amp; !mPrincipalPointAtOrigin</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">                if (focalDistanceAspectRatioKnown) {</span>
<span class="fc" id="L179">                    iac = estimateZeroSkewnessAndKnownFocalDistanceAspectRatio();</span>
                } else {
<span class="fc" id="L181">                    iac = estimateZeroSkewness();</span>
                }
<span class="fc bfc" id="L183" title="All 2 branches covered.">            } else if (principalPointAtOrigin) { // &amp;&amp; !mZeroSkewness</span>
<span class="fc" id="L184">                iac = estimatePrincipalPointAtOrigin();</span>
            } else {
<span class="fc" id="L186">                iac = estimateNoConstraints();</span>
            }

<span class="fc bfc" id="L189" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L190">                listener.onEstimateEnd(this);</span>
            }

<span class="fc" id="L193">            return iac;</span>
        } finally {
<span class="fc" id="L195">            locked = false;</span>
        }
    }

    /**
     * Returns type of IAC estimator.
     *
     * @return type of IAC estimator.
     */
    @Override
    public ImageOfAbsoluteConicEstimatorType getType() {
<span class="fc" id="L206">        return ImageOfAbsoluteConicEstimatorType.LMSE_IAC_ESTIMATOR;</span>
    }

    /**
     * Estimates Image of Absolute Conic (IAC) without constraints.
     *
     * @return estimated IAC.
     * @throws ImageOfAbsoluteConicEstimatorException if an error occurs during
     *                                                estimation, usually because repeated homographies are
     *                                                provided, or homographies corresponding to degenerate
     *                                                camera movements such as pure parallel translations
     *                                                where no additional data is really provided.
     */
    private ImageOfAbsoluteConic estimateNoConstraints() throws ImageOfAbsoluteConicEstimatorException {

        try {
<span class="fc" id="L222">            final var nHomographies = homographies.size();</span>

            final Matrix a;
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (isLMSESolutionAllowed()) {</span>
                // initialize new matrix to zero when LMSE is enabled
<span class="fc" id="L227">                a = new Matrix(2 * nHomographies, 6);</span>
            } else {
                // When LMSE is disabled, initialize new matrix to zero only with
                // 5 equations
<span class="fc" id="L231">                a = new Matrix(MIN_REQUIRED_EQUATIONS, 6);</span>
            }

<span class="fc" id="L234">            var counter = 0;</span>
<span class="fc" id="L235">            ProjectiveTransformation2D t = null;</span>
<span class="fc" id="L236">            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);</span>
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
<span class="fc bfc" id="L245" title="All 2 branches covered.">            for (final var homography : homographies) {</span>
                // convert homography into projective so it can be normalized
<span class="fc" id="L247">                homography.asMatrix(h);</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">                if (t == null) {</span>
<span class="fc" id="L249">                    t = new ProjectiveTransformation2D(h);</span>
                } else {
<span class="fc" id="L251">                    t.setT(h);</span>
                }

                // normalize
<span class="fc" id="L255">                t.normalize();</span>

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
<span class="fc" id="L260">                h11 = h.getElementAt(0, 0);</span>
<span class="fc" id="L261">                h12 = h.getElementAt(0, 1);</span>

<span class="fc" id="L263">                h21 = h.getElementAt(1, 0);</span>
<span class="fc" id="L264">                h22 = h.getElementAt(1, 1);</span>

<span class="fc" id="L266">                h31 = h.getElementAt(2, 0);</span>
<span class="fc" id="L267">                h32 = h.getElementAt(2, 1);</span>

                // fill first equation
<span class="fc" id="L270">                a.setElementAt(counter, 0, h11 * h12);</span>
<span class="fc" id="L271">                a.setElementAt(counter, 1, h11 * h22 + h21 * h12);</span>
<span class="fc" id="L272">                a.setElementAt(counter, 2, h21 * h22);</span>
<span class="fc" id="L273">                a.setElementAt(counter, 3, h11 * h32 + h31 * h12);</span>
<span class="fc" id="L274">                a.setElementAt(counter, 4, h21 * h32 + h31 * h22);</span>
<span class="fc" id="L275">                a.setElementAt(counter, 5, h31 * h32);</span>

                // normalize row
<span class="fc" id="L278">                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L279">                        + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L280">                        + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L281">                        + Math.pow(a.getElementAt(counter, 3), 2.0)</span>
<span class="fc" id="L282">                        + Math.pow(a.getElementAt(counter, 4), 2.0)</span>
<span class="fc" id="L283">                        + Math.pow(a.getElementAt(counter, 5), 2.0));</span>

<span class="fc" id="L285">                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);</span>
<span class="fc" id="L286">                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);</span>
<span class="fc" id="L287">                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);</span>
<span class="fc" id="L288">                a.setElementAt(counter, 3, a.getElementAt(counter, 3) / rowNorm);</span>
<span class="fc" id="L289">                a.setElementAt(counter, 4, a.getElementAt(counter, 4) / rowNorm);</span>
<span class="fc" id="L290">                a.setElementAt(counter, 5, a.getElementAt(counter, 5) / rowNorm);</span>

<span class="fc" id="L292">                counter++;</span>

                // in case we want an exact solution (up to scale) when LMSE is
                // disabled, we stop after 5 equations
<span class="fc bfc" id="L296" title="All 4 branches covered.">                if (!isLMSESolutionAllowed() &amp;&amp; (counter &gt;= MIN_REQUIRED_EQUATIONS)) {</span>
<span class="fc" id="L297">                    break;</span>
                }

                // fill second equation
<span class="fc" id="L301">                a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0));</span>
<span class="fc" id="L302">                a.setElementAt(counter, 1, 2.0 * (h11 * h21 - h12 * h22));</span>
<span class="fc" id="L303">                a.setElementAt(counter, 2, Math.pow(h21, 2.0) - Math.pow(h22, 2.0));</span>
<span class="fc" id="L304">                a.setElementAt(counter, 3, 2.0 * (h11 * h31 - h12 * h32));</span>
<span class="fc" id="L305">                a.setElementAt(counter, 4, 2.0 * (h21 * h31 - h22 * h32));</span>
<span class="fc" id="L306">                a.setElementAt(counter, 5, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));</span>

                // normalize row
<span class="fc" id="L309">                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L310">                        + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L311">                        + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L312">                        + Math.pow(a.getElementAt(counter, 3), 2.0)</span>
<span class="fc" id="L313">                        + Math.pow(a.getElementAt(counter, 4), 2.0)</span>
<span class="fc" id="L314">                        + Math.pow(a.getElementAt(counter, 5), 2.0));</span>

<span class="fc" id="L316">                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);</span>
<span class="fc" id="L317">                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);</span>
<span class="fc" id="L318">                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);</span>
<span class="fc" id="L319">                a.setElementAt(counter, 3, a.getElementAt(counter, 3) / rowNorm);</span>
<span class="fc" id="L320">                a.setElementAt(counter, 4, a.getElementAt(counter, 4) / rowNorm);</span>
<span class="fc" id="L321">                a.setElementAt(counter, 5, a.getElementAt(counter, 5) / rowNorm);</span>

<span class="fc" id="L323">                counter++;</span>
<span class="fc" id="L324">            }</span>

<span class="fc" id="L326">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L327">            decomposer.decompose();</span>

<span class="pc bpc" id="L329" title="1 of 2 branches missed.">            if (decomposer.getNullity() &gt; 1) {</span>
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
<span class="nc" id="L333">                throw new ImageOfAbsoluteConicEstimatorException();</span>
            }

<span class="fc" id="L336">            final var v = decomposer.getV();</span>

            // use last column of V as IAC vector

            // the last column of V contains IAC matrix (B), which is symmetric
            // and positive definite, ordered as follows: B11, B12, B22, B13,
            // B23, B33
<span class="fc" id="L343">            final var b11 = v.getElementAt(0, 5);</span>
<span class="fc" id="L344">            final var b12 = v.getElementAt(1, 5);</span>
<span class="fc" id="L345">            final var b22 = v.getElementAt(2, 5);</span>
<span class="fc" id="L346">            final var b13 = v.getElementAt(3, 5);</span>
<span class="fc" id="L347">            final var b23 = v.getElementAt(4, 5);</span>
<span class="fc" id="L348">            final var b33 = v.getElementAt(5, 5);</span>

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
<span class="fc" id="L353">            return new ImageOfAbsoluteConic(b11, b12, b22, b13, b23, b33);</span>
<span class="nc" id="L354">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L355">            throw new ImageOfAbsoluteConicEstimatorException(e);</span>
        }
    }

    /**
     * Estimates Image of Absolute Conic (IAC) assuming that skewness is zero.
     *
     * @return estimated IAC
     * @throws ImageOfAbsoluteConicEstimatorException if an error occurs during
     *                                                estimation, usually because repeated homographies are
     *                                                provided, or homographies corresponding to degenerate
     *                                                camera movements such as pure parallel translations
     *                                                where no additional data is really provided
     */
    private ImageOfAbsoluteConic estimateZeroSkewness() throws ImageOfAbsoluteConicEstimatorException {
        try {
<span class="fc" id="L371">            final var nHomographies = homographies.size();</span>

            final Matrix a;
<span class="fc bfc" id="L374" title="All 2 branches covered.">            if (isLMSESolutionAllowed()) {</span>
                // initialize new matrix to zero when LMSE is enabled
<span class="fc" id="L376">                a = new Matrix(2 * nHomographies, 5);</span>
            } else {
                // When LMSE is disabled, initialize new matrix to zero only with
                // 4 equations
<span class="fc" id="L380">                a = new Matrix(MIN_REQUIRED_EQUATIONS - 1, 5);</span>
            }

<span class="fc" id="L383">            var counter = 0;</span>
<span class="fc" id="L384">            ProjectiveTransformation2D t = null;</span>
<span class="fc" id="L385">            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);</span>
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
<span class="fc bfc" id="L394" title="All 2 branches covered.">            for (final var homography : homographies) {</span>
                // convert homography into projective so it can be normalized
<span class="fc" id="L396">                homography.asMatrix(h);</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">                if (t == null) {</span>
<span class="fc" id="L398">                    t = new ProjectiveTransformation2D(h);</span>
                } else {
<span class="fc" id="L400">                    t.setT(h);</span>
                }

                // normalize
<span class="fc" id="L404">                t.normalize();</span>

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
<span class="fc" id="L409">                h11 = h.getElementAt(0, 0);</span>
<span class="fc" id="L410">                h12 = h.getElementAt(0, 1);</span>

<span class="fc" id="L412">                h21 = h.getElementAt(1, 0);</span>
<span class="fc" id="L413">                h22 = h.getElementAt(1, 1);</span>

<span class="fc" id="L415">                h31 = h.getElementAt(2, 0);</span>
<span class="fc" id="L416">                h32 = h.getElementAt(2, 1);</span>

                // fill first equation
<span class="fc" id="L419">                a.setElementAt(counter, 0, h11 * h12);</span>
<span class="fc" id="L420">                a.setElementAt(counter, 1, h21 * h22);</span>
<span class="fc" id="L421">                a.setElementAt(counter, 2, h11 * h32 + h31 * h12);</span>
<span class="fc" id="L422">                a.setElementAt(counter, 3, h21 * h32 + h31 * h22);</span>
<span class="fc" id="L423">                a.setElementAt(counter, 4, h31 * h32);</span>

                // normalize row
<span class="fc" id="L426">                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L427">                        + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L428">                        + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L429">                        + Math.pow(a.getElementAt(counter, 3), 2.0)</span>
<span class="fc" id="L430">                        + Math.pow(a.getElementAt(counter, 4), 2.0));</span>

<span class="fc" id="L432">                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);</span>
<span class="fc" id="L433">                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);</span>
<span class="fc" id="L434">                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);</span>
<span class="fc" id="L435">                a.setElementAt(counter, 3, a.getElementAt(counter, 3) / rowNorm);</span>
<span class="fc" id="L436">                a.setElementAt(counter, 4, a.getElementAt(counter, 4) / rowNorm);</span>

<span class="fc" id="L438">                counter++;</span>

                // fill second equation
<span class="fc" id="L441">                a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0));</span>
<span class="fc" id="L442">                a.setElementAt(counter, 1, Math.pow(h21, 2.0) - Math.pow(h22, 2.0));</span>
<span class="fc" id="L443">                a.setElementAt(counter, 2, 2.0 * (h11 * h31 - h12 * h32));</span>
<span class="fc" id="L444">                a.setElementAt(counter, 3, 2.0 * (h21 * h31 - h22 * h32));</span>
<span class="fc" id="L445">                a.setElementAt(counter, 4, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));</span>

                // normalize row
<span class="fc" id="L448">                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L449">                        + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L450">                        + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L451">                        + Math.pow(a.getElementAt(counter, 3), 2.0)</span>
<span class="fc" id="L452">                        + Math.pow(a.getElementAt(counter, 4), 2.0));</span>

<span class="fc" id="L454">                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);</span>
<span class="fc" id="L455">                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);</span>
<span class="fc" id="L456">                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);</span>
<span class="fc" id="L457">                a.setElementAt(counter, 3, a.getElementAt(counter, 3) / rowNorm);</span>
<span class="fc" id="L458">                a.setElementAt(counter, 4, a.getElementAt(counter, 4) / rowNorm);</span>

<span class="fc" id="L460">                counter++;</span>

                // in case we want an exact solution (up to scale) when LMSE is
                // disabled, we stop after 4 equations
<span class="fc bfc" id="L464" title="All 4 branches covered.">                if (!isLMSESolutionAllowed() &amp;&amp; (counter &gt;= (MIN_REQUIRED_EQUATIONS - 1))) {</span>
<span class="fc" id="L465">                    break;</span>
                }
<span class="fc" id="L467">            }</span>

<span class="fc" id="L469">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L470">            decomposer.decompose();</span>

<span class="pc bpc" id="L472" title="1 of 2 branches missed.">            if (decomposer.getNullity() &gt; 1) {</span>
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
<span class="nc" id="L476">                throw new ImageOfAbsoluteConicEstimatorException();</span>
            }

<span class="fc" id="L479">            final var v = decomposer.getV();</span>

            // use last column of V as IAC vector

            // the last column of V contains IAC matrix (B), which is symmetric
            // and positive definite, ordered as follows: B11, B12, B22, B13,
            // B23, B33
<span class="fc" id="L486">            final var b11 = v.getElementAt(0, 4);</span>
<span class="fc" id="L487">            final var b22 = v.getElementAt(1, 4);</span>
<span class="fc" id="L488">            final var b13 = v.getElementAt(2, 4);</span>
<span class="fc" id="L489">            final var b23 = v.getElementAt(3, 4);</span>
<span class="fc" id="L490">            final var b33 = v.getElementAt(4, 4);</span>

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
            // Since skewness is zero b12 = B = 0.0
<span class="fc" id="L496">            return new ImageOfAbsoluteConic(b11, 0.0, b22, b13, b23, b33);</span>
<span class="nc" id="L497">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L498">            throw new ImageOfAbsoluteConicEstimatorException(e);</span>
        }
    }

    /**
     * Estimates Image of Absolute Conic (IAC) assuming that principal point is
     * located at origin of coordinates.
     *
     * @return estimated IAC
     * @throws ImageOfAbsoluteConicEstimatorException if an error occurs during
     *                                                estimation, usually because repeated homographies are
     *                                                provided, or homographies corresponding to degenerate
     *                                                camera movements such as pure parallel translations
     *                                                where no additional data is really provided
     */
    private ImageOfAbsoluteConic estimatePrincipalPointAtOrigin() throws ImageOfAbsoluteConicEstimatorException {

        try {
<span class="fc" id="L516">            final var nHomographies = homographies.size();</span>

            final Matrix a;
<span class="fc bfc" id="L519" title="All 2 branches covered.">            if (isLMSESolutionAllowed()) {</span>
                // initialize new matrix to zero when LMSE is enabled
<span class="fc" id="L521">                a = new Matrix(2 * nHomographies, 4);</span>
            } else {
                // When LMSE is disabled, initialize new matrix to zero only with
                // 2 equations
<span class="fc" id="L525">                a = new Matrix(MIN_REQUIRED_EQUATIONS - 2, 4);</span>
            }

<span class="fc" id="L528">            var counter = 0;</span>
<span class="fc" id="L529">            ProjectiveTransformation2D t = null;</span>
<span class="fc" id="L530">            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);</span>
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
<span class="fc bfc" id="L539" title="All 2 branches covered.">            for (final var homography : homographies) {</span>
                // convert homography into projective so it can be normalized
<span class="fc" id="L541">                homography.asMatrix(h);</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">                if (t == null) {</span>
<span class="fc" id="L543">                    t = new ProjectiveTransformation2D(h);</span>
                } else {
<span class="fc" id="L545">                    t.setT(h);</span>
                }

                // normalize
<span class="fc" id="L549">                t.normalize();</span>

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
<span class="fc" id="L554">                h11 = h.getElementAt(0, 0);</span>
<span class="fc" id="L555">                h12 = h.getElementAt(0, 1);</span>

<span class="fc" id="L557">                h21 = h.getElementAt(1, 0);</span>
<span class="fc" id="L558">                h22 = h.getElementAt(1, 1);</span>

<span class="fc" id="L560">                h31 = h.getElementAt(2, 0);</span>
<span class="fc" id="L561">                h32 = h.getElementAt(2, 1);</span>

                // fill first equation
<span class="fc" id="L564">                a.setElementAt(counter, 0, h11 * h12);</span>
<span class="fc" id="L565">                a.setElementAt(counter, 1, h11 * h22 + h21 * h12);</span>
<span class="fc" id="L566">                a.setElementAt(counter, 2, h21 * h22);</span>
<span class="fc" id="L567">                a.setElementAt(counter, 3, h31 * h32);</span>

                // normalize row
<span class="fc" id="L570">                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L571">                        + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L572">                        + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L573">                        + Math.pow(a.getElementAt(counter, 3), 2.0));</span>

<span class="fc" id="L575">                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);</span>
<span class="fc" id="L576">                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);</span>
<span class="fc" id="L577">                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);</span>
<span class="fc" id="L578">                a.setElementAt(counter, 3, a.getElementAt(counter, 3) / rowNorm);</span>

<span class="fc" id="L580">                counter++;</span>

                // in case we want an exact solution (up to scale) when LMSE is
                // disabled, we stop after 2 equations
<span class="fc bfc" id="L584" title="All 4 branches covered.">                if (!isLMSESolutionAllowed() &amp;&amp; (counter &gt;= MIN_REQUIRED_EQUATIONS - 2)) {</span>
<span class="fc" id="L585">                    break;</span>
                }

                // fill second equation
<span class="fc" id="L589">                a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0));</span>
<span class="fc" id="L590">                a.setElementAt(counter, 1, 2.0 * (h11 * h21 - h12 * h22));</span>
<span class="fc" id="L591">                a.setElementAt(counter, 2, Math.pow(h21, 2.0) - Math.pow(h22, 2.0));</span>
<span class="fc" id="L592">                a.setElementAt(counter, 3, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));</span>

                // normalize row
<span class="fc" id="L595">                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L596">                        + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L597">                        + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L598">                        + Math.pow(a.getElementAt(counter, 3), 2.0));</span>

<span class="fc" id="L600">                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);</span>
<span class="fc" id="L601">                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);</span>
<span class="fc" id="L602">                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);</span>
<span class="fc" id="L603">                a.setElementAt(counter, 3, a.getElementAt(counter, 3) / rowNorm);</span>

<span class="fc" id="L605">                counter++;</span>
<span class="fc" id="L606">            }</span>

<span class="fc" id="L608">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L609">            decomposer.decompose();</span>

<span class="pc bpc" id="L611" title="1 of 2 branches missed.">            if (decomposer.getNullity() &gt; 1) {</span>
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
<span class="nc" id="L615">                throw new ImageOfAbsoluteConicEstimatorException();</span>
            }

<span class="fc" id="L618">            final var v = decomposer.getV();</span>

            // use last column of V as IAC vector

            // the last column of V contains IAC matrix (B), which is symmetric
            // and positive definite, ordered as follows: B11, B12, B22, B13,
            // B23, B33
<span class="fc" id="L625">            final var b11 = v.getElementAt(0, 3);</span>
<span class="fc" id="L626">            final var b12 = v.getElementAt(1, 3);</span>
<span class="fc" id="L627">            final var b22 = v.getElementAt(2, 3);</span>
<span class="fc" id="L628">            final var b33 = v.getElementAt(3, 3);</span>

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
            // Since principal point is at origin of coordinates
            // b13 = D = 0.0, b23 = E = 0.0
<span class="fc" id="L635">            return new ImageOfAbsoluteConic(b11, b12, b22, 0.0, 0.0, b33);</span>
<span class="nc" id="L636">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L637">            throw new ImageOfAbsoluteConicEstimatorException(e);</span>
        }
    }

    /**
     * Estimates Image of Absolute Conic (IAC) assuming that skewness is zero
     * and that principal point is located at origin of coordinates.
     *
     * @return estimated IAC
     * @throws ImageOfAbsoluteConicEstimatorException if an error occurs during
     *                                                estimation, usually because repeated homographies are
     *                                                provided, or homographies corresponding to degenerate
     *                                                camera movements such as pure parallel translations
     *                                                where no additional data is really provided
     */
    private ImageOfAbsoluteConic estimateZeroSkewnessAndPrincipalPointAtOrigin()
            throws ImageOfAbsoluteConicEstimatorException {

        try {
<span class="fc" id="L656">            final var nHomographies = homographies.size();</span>

            final Matrix a;
<span class="fc bfc" id="L659" title="All 2 branches covered.">            if (isLMSESolutionAllowed()) {</span>
                // initialize new matrix to zero when LMSE is enabled
<span class="fc" id="L661">                a = new Matrix(2 * nHomographies, 3);</span>
            } else {
                // When LMSE is disabled, initialize new matrix to zero only with
                // 2 equations
<span class="fc" id="L665">                a = new Matrix(MIN_REQUIRED_EQUATIONS - 3, 3);</span>
            }

<span class="fc" id="L668">            var counter = 0;</span>
<span class="fc" id="L669">            ProjectiveTransformation2D t = null;</span>
<span class="fc" id="L670">            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);</span>
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
<span class="fc bfc" id="L679" title="All 2 branches covered.">            for (final var homography : homographies) {</span>
                // convert homography into projective so it can be normalized
<span class="fc" id="L681">                homography.asMatrix(h);</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">                if (t == null) {</span>
<span class="fc" id="L683">                    t = new ProjectiveTransformation2D(h);</span>
                } else {
<span class="fc" id="L685">                    t.setT(h);</span>
                }

                // normalize
<span class="fc" id="L689">                t.normalize();</span>

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
<span class="fc" id="L694">                h11 = h.getElementAt(0, 0);</span>
<span class="fc" id="L695">                h12 = h.getElementAt(0, 1);</span>

<span class="fc" id="L697">                h21 = h.getElementAt(1, 0);</span>
<span class="fc" id="L698">                h22 = h.getElementAt(1, 1);</span>

<span class="fc" id="L700">                h31 = h.getElementAt(2, 0);</span>
<span class="fc" id="L701">                h32 = h.getElementAt(2, 1);</span>

                // fill first equation
<span class="fc" id="L704">                a.setElementAt(counter, 0, h11 * h12);</span>
<span class="fc" id="L705">                a.setElementAt(counter, 1, h21 * h22);</span>
<span class="fc" id="L706">                a.setElementAt(counter, 2, h31 * h32);</span>

                // normalize row
<span class="fc" id="L709">                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L710">                        + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L711">                        + Math.pow(a.getElementAt(counter, 2), 2.0));</span>

<span class="fc" id="L713">                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);</span>
<span class="fc" id="L714">                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);</span>
<span class="fc" id="L715">                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);</span>

<span class="fc" id="L717">                counter++;</span>

                // fill second equation
<span class="fc" id="L720">                a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0));</span>
<span class="fc" id="L721">                a.setElementAt(counter, 1, Math.pow(h21, 2.0) - Math.pow(h22, 2.0));</span>
<span class="fc" id="L722">                a.setElementAt(counter, 2, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));</span>

                // normalize row
<span class="fc" id="L725">                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L726">                        + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L727">                        + Math.pow(a.getElementAt(counter, 2), 2.0));</span>

<span class="fc" id="L729">                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);</span>
<span class="fc" id="L730">                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);</span>
<span class="fc" id="L731">                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);</span>

<span class="fc" id="L733">                counter++;</span>

                // in case we want an exact solution (up to scale) when LMSE is
                // disabled, we stop after 2 equations
<span class="pc bpc" id="L737" title="1 of 4 branches missed.">                if (!isLMSESolutionAllowed() &amp;&amp; (counter &gt;= MIN_REQUIRED_EQUATIONS - 3)) {</span>
<span class="fc" id="L738">                    break;</span>
                }
<span class="fc" id="L740">            }</span>

<span class="fc" id="L742">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L743">            decomposer.decompose();</span>

<span class="pc bpc" id="L745" title="1 of 2 branches missed.">            if (decomposer.getNullity() &gt; 1) {</span>
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
<span class="nc" id="L749">                throw new ImageOfAbsoluteConicEstimatorException();</span>
            }

<span class="fc" id="L752">            final var v = decomposer.getV();</span>

            // use last column of V as IAC vector

            // the last column of V contains IAC matrix (B), which is symmetric
            // and positive definite, ordered as follows: B11, B12, B22, B13,
            // B23, B33
<span class="fc" id="L759">            final var b11 = v.getElementAt(0, 2);</span>
<span class="fc" id="L760">            final var b22 = v.getElementAt(1, 2);</span>
<span class="fc" id="L761">            final var b33 = v.getElementAt(2, 2);</span>

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
            // Since principal point is at origin of coordinates
            // b12 = B = 0, b13 = D = 0.0, b23 = E = 0.0
<span class="fc" id="L768">            return new ImageOfAbsoluteConic(b11, 0.0, b22, 0.0, 0.0, b33);</span>
<span class="nc" id="L769">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L770">            throw new ImageOfAbsoluteConicEstimatorException(e);</span>
        }
    }

    /**
     * Estimates Image of Absolute Conic (IAC) assuming that skewness is zero
     * and that aspect ratio of focal distances is known.
     *
     * @return estimated IAC
     * @throws ImageOfAbsoluteConicEstimatorException if an error occurs during
     *                                                estimation, usually because repeated homographies are
     *                                                provided, or homographies corresponding to degenerate
     *                                                camera movements such as pure parallel translations
     *                                                where no additional data is really provided
     */
    private ImageOfAbsoluteConic estimateZeroSkewnessAndKnownFocalDistanceAspectRatio()
            throws ImageOfAbsoluteConicEstimatorException {
        try {
<span class="fc" id="L788">            final var nHomographies = homographies.size();</span>

            final Matrix a;
<span class="fc bfc" id="L791" title="All 2 branches covered.">            if (isLMSESolutionAllowed()) {</span>
                // initialize new matrix to zero when LMSE is enabled
<span class="fc" id="L793">                a = new Matrix(2 * nHomographies, 4);</span>
            } else {
                // When LMSE is disabled, initialize new matrix to zero only with
                // 4 equations
<span class="fc" id="L797">                a = new Matrix(MIN_REQUIRED_EQUATIONS - 2, 4);</span>
            }

<span class="fc" id="L800">            final var sqrAspectRatio = Math.pow(focalDistanceAspectRatio, 2.0);</span>

<span class="fc" id="L802">            var counter = 0;</span>
<span class="fc" id="L803">            ProjectiveTransformation2D t = null;</span>
<span class="fc" id="L804">            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);</span>
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
<span class="fc bfc" id="L813" title="All 2 branches covered.">            for (final var homography : homographies) {</span>
                // convert homography into projective so it can be normalized
<span class="fc" id="L815">                homography.asMatrix(h);</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">                if (t == null) {</span>
<span class="fc" id="L817">                    t = new ProjectiveTransformation2D(h);</span>
                } else {
<span class="fc" id="L819">                    t.setT(h);</span>
                }

                // normalize
<span class="fc" id="L823">                t.normalize();</span>

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
<span class="fc" id="L828">                h11 = h.getElementAt(0, 0);</span>
<span class="fc" id="L829">                h12 = h.getElementAt(0, 1);</span>

<span class="fc" id="L831">                h21 = h.getElementAt(1, 0);</span>
<span class="fc" id="L832">                h22 = h.getElementAt(1, 1);</span>

<span class="fc" id="L834">                h31 = h.getElementAt(2, 0);</span>
<span class="fc" id="L835">                h32 = h.getElementAt(2, 1);</span>

                // fill first equation
<span class="fc" id="L838">                a.setElementAt(counter, 0, h11 * h12 + h21 * h22 / sqrAspectRatio);</span>
<span class="fc" id="L839">                a.setElementAt(counter, 1, h11 * h32 + h31 * h12);</span>
<span class="fc" id="L840">                a.setElementAt(counter, 2, h21 * h32 + h31 * h22);</span>
<span class="fc" id="L841">                a.setElementAt(counter, 3, h31 * h32);</span>

                // normalize row
<span class="fc" id="L844">                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L845">                        + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L846">                        + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L847">                        + Math.pow(a.getElementAt(counter, 3), 2.0));</span>

<span class="fc" id="L849">                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);</span>
<span class="fc" id="L850">                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);</span>
<span class="fc" id="L851">                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);</span>
<span class="fc" id="L852">                a.setElementAt(counter, 3, a.getElementAt(counter, 3) / rowNorm);</span>

<span class="fc" id="L854">                counter++;</span>

                // in case we want an exact solution (up to scale) when LMSE is
                // disabled, we stop after 4 equations
<span class="fc bfc" id="L858" title="All 4 branches covered.">                if (!isLMSESolutionAllowed() &amp;&amp; (counter &gt;= (MIN_REQUIRED_EQUATIONS - 2))) {</span>
<span class="fc" id="L859">                    break;</span>
                }

                // fill second equation
<span class="fc" id="L863">                a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0)</span>
<span class="fc" id="L864">                        + (Math.pow(h21, 2.0) - Math.pow(h22, 2.0)) / sqrAspectRatio);</span>
<span class="fc" id="L865">                a.setElementAt(counter, 1, 2.0 * (h11 * h31 - h12 * h32));</span>
<span class="fc" id="L866">                a.setElementAt(counter, 2, 2.0 * (h21 * h31 - h22 * h32));</span>
<span class="fc" id="L867">                a.setElementAt(counter, 3, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));</span>

                // normalize row
<span class="fc" id="L870">                rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L871">                        + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L872">                        + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L873">                        + Math.pow(a.getElementAt(counter, 3), 2.0));</span>

<span class="fc" id="L875">                a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);</span>
<span class="fc" id="L876">                a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);</span>
<span class="fc" id="L877">                a.setElementAt(counter, 2, a.getElementAt(counter, 2) / rowNorm);</span>
<span class="fc" id="L878">                a.setElementAt(counter, 3, a.getElementAt(counter, 3) / rowNorm);</span>

<span class="fc" id="L880">                counter++;</span>
<span class="fc" id="L881">            }</span>

<span class="fc" id="L883">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L884">            decomposer.decompose();</span>

<span class="pc bpc" id="L886" title="1 of 2 branches missed.">            if (decomposer.getNullity() &gt; 1) {</span>
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
<span class="nc" id="L890">                throw new ImageOfAbsoluteConicEstimatorException();</span>
            }

<span class="fc" id="L893">            final var v = decomposer.getV();</span>

            // use last column of V as IAC vector

            // the last column of V contains IAC matrix (B), which is symmetric
            // and positive definite, ordered as follows: B11, B12, B22, B13,
            // B23, B33
<span class="fc" id="L900">            final var b11 = v.getElementAt(0, 3);</span>
<span class="fc" id="L901">            final var b13 = v.getElementAt(1, 3);</span>
<span class="fc" id="L902">            final var b23 = v.getElementAt(2, 3);</span>
<span class="fc" id="L903">            final var b33 = v.getElementAt(3, 3);</span>

<span class="fc" id="L905">            final var b22 = b11 / sqrAspectRatio;</span>

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
            // Since skewness is zero b12 = B = 0.0
<span class="fc" id="L911">            return new ImageOfAbsoluteConic(b11, 0.0, b22, b13, b23, b33);</span>
<span class="nc" id="L912">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L913">            throw new ImageOfAbsoluteConicEstimatorException(e);</span>
        }
    }

    /**
     * Estimates Image of Absolute Conic (IAC) assuming that skewness is zero,
     * principal point is located at origin of coordinates and that aspect ratio
     * of focal distances is known.
     *
     * @return estimated IAC
     * @throws ImageOfAbsoluteConicEstimatorException if an error occurs during
     *                                                estimation, usually because repeated homographies are
     *                                                provided, or homographies corresponding to degenerate
     *                                                camera movements such as pure parallel translations
     *                                                where no additional data is really provided
     */
    private ImageOfAbsoluteConic estimateZeroSkewnessPrincipalPointAtOriginAndKnownFocalDistanceAspectRatio()
            throws ImageOfAbsoluteConicEstimatorException {

        try {
<span class="fc" id="L933">            final double sqrAspectRatio = Math.pow(focalDistanceAspectRatio, 2.0);</span>

            double b11;
            double b33;

<span class="fc" id="L938">            ProjectiveTransformation2D t = null;</span>
<span class="fc" id="L939">            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);</span>
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;

<span class="fc bfc" id="L947" title="All 2 branches covered.">            if (!isLMSESolutionAllowed()) {</span>
                // NO LMSE

                // For a single homography we have two equations, but indeed we
                // only need 1 to solve b11 because b33 is defined up to scale
                // (i.e. b33 = 1.0)

                // Hence
                // b11 * (h11 * h12 + h21 * h22 / sqrAspectRatio) + b33 * h31 * h32 = 0
                // b11 = -b33 * h31 * h32 / (h11 * h12 + h21 * h22 / sqrAspectRatio)

<span class="fc" id="L958">                final var homography = homographies.get(0);</span>

                // convert homography into projective so it can be normalized
<span class="fc" id="L961">                homography.asMatrix(h);</span>
<span class="fc" id="L962">                t = new ProjectiveTransformation2D(h);</span>

                // normalize
<span class="fc" id="L965">                t.normalize();</span>

                // obtain elements of projective transformation matrix
                // there is no need to retrieve internal matrix h, as we already
                // hold a reference
<span class="fc" id="L970">                h11 = h.getElementAt(0, 0);</span>
<span class="fc" id="L971">                h12 = h.getElementAt(0, 1);</span>

<span class="fc" id="L973">                h21 = h.getElementAt(1, 0);</span>
<span class="fc" id="L974">                h22 = h.getElementAt(1, 1);</span>

<span class="fc" id="L976">                h31 = h.getElementAt(2, 0);</span>
<span class="fc" id="L977">                h32 = h.getElementAt(2, 1);</span>

<span class="fc" id="L979">                b33 = 1.0;</span>
<span class="fc" id="L980">                b11 = -h31 * h32 / (h11 * h12 + h21 * h22 / sqrAspectRatio);</span>
<span class="fc" id="L981">            } else {</span>
<span class="fc" id="L982">                final var nHomographies = homographies.size();</span>

<span class="fc" id="L984">                final var a = new Matrix(2 * nHomographies, 2);</span>

<span class="fc" id="L986">                var counter = 0;</span>
                // elements ij of homography (last column is not required)
                double rowNorm;
<span class="fc bfc" id="L989" title="All 2 branches covered.">                for (final var homography : homographies) {</span>
                    // convert homography into projective so it can be normalized
<span class="fc" id="L991">                    homography.asMatrix(h);</span>
<span class="fc bfc" id="L992" title="All 2 branches covered.">                    if (t == null) {</span>
<span class="fc" id="L993">                        t = new ProjectiveTransformation2D(h);</span>
                    } else {
<span class="fc" id="L995">                        t.setT(h);</span>
                    }

                    // normalize
<span class="fc" id="L999">                    t.normalize();</span>

                    // obtain elements of projective transformation matrix
                    // there is no need to retrieve internal matrix h, as we already
                    // hold a reference
<span class="fc" id="L1004">                    h11 = h.getElementAt(0, 0);</span>
<span class="fc" id="L1005">                    h12 = h.getElementAt(0, 1);</span>

<span class="fc" id="L1007">                    h21 = h.getElementAt(1, 0);</span>
<span class="fc" id="L1008">                    h22 = h.getElementAt(1, 1);</span>

<span class="fc" id="L1010">                    h31 = h.getElementAt(2, 0);</span>
<span class="fc" id="L1011">                    h32 = h.getElementAt(2, 1);</span>

                    // fill first equation
<span class="fc" id="L1014">                    a.setElementAt(counter, 0, h11 * h12 + h21 * h22 / sqrAspectRatio);</span>
<span class="fc" id="L1015">                    a.setElementAt(counter, 1, h31 * h32);</span>

                    // normalize row
<span class="fc" id="L1018">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L1019">                            + Math.pow(a.getElementAt(counter, 1), 2.0));</span>

<span class="fc" id="L1021">                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);</span>
<span class="fc" id="L1022">                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);</span>

<span class="fc" id="L1024">                    counter++;</span>

                    // fill second equation
<span class="fc" id="L1027">                    a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0)</span>
<span class="fc" id="L1028">                            + (Math.pow(h21, 2.0) - Math.pow(h22, 2.0)) / sqrAspectRatio);</span>
<span class="fc" id="L1029">                    a.setElementAt(counter, 1, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));</span>

                    // normalize row
<span class="fc" id="L1032">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L1033">                            + Math.pow(a.getElementAt(counter, 1), 2.0));</span>

<span class="fc" id="L1035">                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) / rowNorm);</span>
<span class="fc" id="L1036">                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) / rowNorm);</span>

<span class="fc" id="L1038">                    counter++;</span>
<span class="fc" id="L1039">                }</span>

<span class="fc" id="L1041">                final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L1042">                decomposer.decompose();</span>

<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">                if (decomposer.getNullity() &gt; 1) {</span>
                    // homographies constitute a degenerate camera movement.
                    // A linear combination of possible IAC's exist (i.e.
                    // solution is not unique up to scale)
<span class="nc" id="L1048">                    throw new ImageOfAbsoluteConicEstimatorException();</span>
                }

<span class="fc" id="L1051">                final var v = decomposer.getV();</span>

                // use last column of V as IAC vector

                // the last column of V contains IAC matrix (B), which is
                // symmetric and positive definite, ordered as follows: B11, B12,
                // B22, B13, B23, B33
<span class="fc" id="L1058">                b11 = v.getElementAt(0, 1);</span>
<span class="fc" id="L1059">                b33 = v.getElementAt(1, 1);</span>
            }

<span class="fc" id="L1062">            final var b22 = b11 / sqrAspectRatio;</span>

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
            // Since principal point is at origin of coordinates
            // b12 = B = 0, b13 = D = 0.0, b23 = E = 0.0
<span class="fc" id="L1069">            return new ImageOfAbsoluteConic(b11, 0.0, b22, 0.0, 0.0, b33);</span>
<span class="nc" id="L1070">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L1071">            throw new ImageOfAbsoluteConicEstimatorException(e);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>