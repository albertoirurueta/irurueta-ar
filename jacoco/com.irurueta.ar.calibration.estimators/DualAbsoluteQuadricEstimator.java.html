<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DualAbsoluteQuadricEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.calibration.estimators</a> &gt; <span class="el_source">DualAbsoluteQuadricEstimator.java</span></div><h1>DualAbsoluteQuadricEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2016 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.calibration.estimators;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.SingularValueDecomposer;
import com.irurueta.algebra.Utils;
import com.irurueta.ar.calibration.DualAbsoluteQuadric;
import com.irurueta.geometry.PinholeCamera;
import com.irurueta.geometry.estimators.LockedException;
import com.irurueta.geometry.estimators.NotReadyException;
import com.irurueta.numerical.NumericalException;
import com.irurueta.numerical.polynomials.Polynomial;

import java.util.List;

/**
 * This class defines the interface for an estimator of the Dual Absolute
 * Quadric (DAQ) assuming equal vertical and horizontal focal length, no
 * skewness and principal point at the center of the image.
 * The projection of the Dual Absolute Quadric through a given
 * pinhole camera P, becomes the Dual Image of Absolute Conic (DIAC).
 * Since the DIAC is directly related to the intrinsic parameters K of the
 * camera P used for projection, then by using a pair of arbitrary cameras,
 * it is possible to solve their corresponding focal length, assuming that:
 * - cameras are arbitrary (usually the initial camera is the identity and must
 * be discarded) as it creates a numerical degeneracy.
 * - all provided cameras have the same intrinsic parameters.
 * - it is assumed that skewness is zero, the principal point is at the center
 * of the image plane (zero), and both horizontal and vertical focal planes are
 * equal.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public abstract class DualAbsoluteQuadricEstimator {

    /**
     * Constant defining whether zero skewness is assumed.
     */
    public static final boolean DEFAULT_ZERO_SKEWNESS = true;

    /**
     * Constant defining whether principal point is assumed to be at origin of
     * coordinates.
     */
    public static final boolean DEFAULT_PRINCIPAL_POINT_AT_ORIGIN = true;

    /**
     * Constant defining whether aspect ratio of focal distance (i.e. vertical
     * focal distance divided by horizontal focal distance) is known or not.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio. Typically, LCD sensor cells are square and hence aspect
     * ratio of focal distances is known and equal to 1.
     */
    public static final boolean DEFAULT_FOCAL_DISTANCE_ASPECT_RATIO_KNOWN = true;

    /**
     * Constant defining default aspect ratio of focal distances. This constant
     * takes into account that typically LCD sensor cells are square and hence
     * aspect ratio of focal distances is known and equal to 1.
     */
    public static final double DEFAULT_FOCAL_DISTANCE_ASPECT_RATIO = 1.0;

    /**
     * Constant defining whether rank 3 must be enforced in estimated Dual
     * Absolute Quadric (DAQ), thus making it singular.
     * DAQ is always singular in any arbitrary projective space, however, due to
     * noise in samples, estimation might not be singular.
     * By enforcing singularity an additional constraint is imposed, which might
     * result in less cameras needed for DAQ estimation.
     */
    public static final boolean DEFAULT_ENFORCE_SINGULARITY = true;

    /**
     * Indicates whether enforced singularity will be validated by checking that
     * determinant of estimated Dual Absolute Quadric (DAQ) is below a certain
     * threshold.
     */
    public static final boolean DEFAULT_VALIDATE_ENFORCED_SINGULARITY = true;

    /**
     * Default threshold to determine whether estimated Dual Absolute Quadric
     * (DAQ) has rank 3 or not.
     */
    public static final double DEFAULT_DETERMINANT_THRESHOLD = 1e-6;

    /**
     * Minimum absolute value allowed for aspect ratio of focal distances.
     */
    public static final double MIN_ABS_FOCAL_DISTANCE_ASPECT_RATIO = 1e-6;

    /**
     * Minimum number of required equations to solve DAQ.
     */
    protected static final int MIN_REQUIRED_EQUATIONS = 9;

    /**
     * Default type for a DAQ estimator.
     */
<span class="fc" id="L113">    public static final DualAbsoluteQuadricEstimatorType DEFAULT_ESTIMATOR_TYPE =</span>
            DualAbsoluteQuadricEstimatorType.LMSE_DUAL_ABSOLUTE_QUADRIC_ESTIMATOR;

    /**
     * Indicates whether camera skewness is assumed to be zero or not.
     */
    protected boolean zeroSkewness;

    /**
     * Indicates whether principal point is assumed to be at origin of
     * coordinates or not.
     * If false, the principal point will be estimated, otherwise it will be
     * assumed to be at image center (i.e. origin of coordinates).
     */
    protected boolean principalPointAtOrigin;

    /**
     * Indicates whether aspect ratio of focal distances (i.e. vertical focal
     * distance divided by horizontal focal distance) is known or not.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio. Typically, LCD sensor cells are square and hence aspect
     * ratio of focal distances is known and equal to 1.
     * This value is only taken into account if skewness is assumed to be zero,
     * otherwise it is ignored.
     */
    protected boolean focalDistanceAspectRatioKnown;

    /**
     * Contains aspect ratio of focal distances (i.e. vertical focal distance
     * divided by horizontal focal distance).
     * This value is only taken into account if skewness is assumed to be zero
     * and focal distance aspect ratio is marked as known, otherwise it is
     * ignored.
     * By default, this is 1.0, since it is taken into account that typically
     * LCD sensor cells are square and hence aspect ratio focal distances is
     * known and equal to 1.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio.
     */
    protected double focalDistanceAspectRatio;

    /**
     * Indicates whether a singular DAQ is enforced or not.
     * Dual Absolute Quadric is singular (has rank 3) in any projective space,
     * however, due to noise in samples, estimated DAQ might not be fully
     * singular.
     */
    protected boolean singularityEnforced;

    /**
     * Indicates whether enforced singularity will be validated by checking that
     * determinant of estimated Dual Absolute Quadric (DAQ) is below a certain
     * threshold.
     */
    protected boolean validateEnforcedSingularity;

    /**
     * Threshold to determine whether estimated Dual Absolute Quadric (DAQ)
     * has rank 3 or not when validation is enabled.
     */
    protected double determinantThreshold;

    /**
     * True when an estimator is estimating the Dual Absolute Quadric (DAQ).
     */
    protected boolean locked;

    /**
     * Listener to be notified of events such as when estimation starts, ends or
     * estimation progress changes.
     */
    protected DualAbsoluteQuadricEstimatorListener listener;

    /**
     * List of cameras used to estimate the Dual Absolute Quadric (DAQ).
     */
    protected List&lt;PinholeCamera&gt; cameras;

    /**
     * Constructor.
     */
<span class="fc" id="L194">    protected DualAbsoluteQuadricEstimator() {</span>
<span class="fc" id="L195">        zeroSkewness = DEFAULT_ZERO_SKEWNESS;</span>
<span class="fc" id="L196">        principalPointAtOrigin = DEFAULT_PRINCIPAL_POINT_AT_ORIGIN;</span>
<span class="fc" id="L197">        focalDistanceAspectRatioKnown = DEFAULT_FOCAL_DISTANCE_ASPECT_RATIO_KNOWN;</span>
<span class="fc" id="L198">        focalDistanceAspectRatio = DEFAULT_FOCAL_DISTANCE_ASPECT_RATIO;</span>
<span class="fc" id="L199">        singularityEnforced = DEFAULT_ENFORCE_SINGULARITY;</span>
<span class="fc" id="L200">        validateEnforcedSingularity = DEFAULT_VALIDATE_ENFORCED_SINGULARITY;</span>
<span class="fc" id="L201">        determinantThreshold = DEFAULT_DETERMINANT_THRESHOLD;</span>

<span class="fc" id="L203">        locked = false;</span>
<span class="fc" id="L204">        listener = null;</span>
<span class="fc" id="L205">        cameras = null;</span>
<span class="fc" id="L206">    }</span>

    /**
     * Constructor with listener.
     *
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     */
    protected DualAbsoluteQuadricEstimator(final DualAbsoluteQuadricEstimatorListener listener) {
<span class="fc" id="L215">        this();</span>
<span class="fc" id="L216">        this.listener = listener;</span>
<span class="fc" id="L217">    }</span>

    /**
     * Constructor.
     *
     * @param cameras list of cameras used to estimate the Dual Absolute Quadric
     *                (DAQ).
     * @throws IllegalArgumentException if list of cameras is null or invalid
     *                                  for default constraints.
     */
    protected DualAbsoluteQuadricEstimator(final List&lt;PinholeCamera&gt; cameras) {
<span class="fc" id="L228">        this();</span>
        try {
<span class="fc" id="L230">            setCameras(cameras);</span>
<span class="nc" id="L231">        } catch (final LockedException ignore) {</span>
            // never thrown
<span class="fc" id="L233">        }</span>
<span class="fc" id="L234">    }</span>

    /**
     * Constructor.
     *
     * @param cameras  list of cameras used to estimate the Dual Absolute Quadric
     *                 (DAQ).
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     * @throws IllegalArgumentException if list of cameras is null or invalid
     *                                  for default constraints.
     */
    protected DualAbsoluteQuadricEstimator(final List&lt;PinholeCamera&gt; cameras,
                                           final DualAbsoluteQuadricEstimatorListener listener) {
<span class="fc" id="L248">        this(cameras);</span>
<span class="fc" id="L249">        this.listener = listener;</span>
<span class="fc" id="L250">    }</span>

    /**
     * Returns boolean indicating whether camera skewness is assumed to be zero
     * or not.
     * Skewness determines whether LCD sensor cells are properly aligned or not,
     * where zero indicates perfect alignment.
     * Typically, skewness is a value equal or very close to zero.
     *
     * @return true if camera skewness is assumed to be zero, otherwise camera
     * skewness is estimated
     */
    public boolean isZeroSkewness() {
<span class="fc" id="L263">        return zeroSkewness;</span>
    }

    /**
     * Sets boolean indicating whether camera skewness is assumed to be zero or
     * not.
     * Skewness determines whether LCD sensor cells are properly aligned or not,
     * where zero indicates perfect alignment.
     * Typically, skewness is a value equal or very close to zero.
     *
     * @param zeroSkewness true if camera skewness is assumed to be zero,
     *                     otherwise camera skewness is estimated
     * @throws LockedException if estimator is locked
     */
    public void setZeroSkewness(final boolean zeroSkewness) throws LockedException {
<span class="fc bfc" id="L278" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L279">            throw new LockedException();</span>
        }

<span class="fc" id="L282">        this.zeroSkewness = zeroSkewness;</span>
<span class="fc" id="L283">    }</span>

    /**
     * Returns boolean indicating whether principal point is assumed to be at
     * origin of coordinates or not.
     * Typically principal point is located at image center (origin of
     * coordinates), and usually matches the center of radial distortion if
     * it is taken into account.
     *
     * @return true if principal point is assumed to be at origin of
     * coordinates, false if principal point must be estimated
     */
    public boolean isPrincipalPointAtOrigin() {
<span class="fc" id="L296">        return principalPointAtOrigin;</span>
    }

    /**
     * Sets boolean indicating whether principal point is assumed to be at
     * origin of coordinates or not.
     * Typically principal point is located at image center (origin of
     * coordinates), and usually matches the center of radial distortion if it
     * is taken into account.
     *
     * @param principalPointAtOrigin true if principal point is assumed to be at
     *                               origin of coordinates, false if principal point must be estimated
     * @throws LockedException if estimator is locked
     */
    public void setPrincipalPointAtOrigin(final boolean principalPointAtOrigin) throws LockedException {
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L312">            throw new LockedException();</span>
        }

<span class="fc" id="L315">        this.principalPointAtOrigin = principalPointAtOrigin;</span>
<span class="fc" id="L316">    }</span>

    /**
     * Returns boolean indicating whether aspect ratio of focal distances (i.e.
     * vertical focal distance divided by horizontal focal distance) is known or
     * not.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio. Typically, LCD sensor cells are square and hence aspect
     * ratio of focal distances is known and equal to 1.
     * This value is only taken into account if skewness is assumed to be zero,
     * otherwise it is ignored.
     *
     * @return true if focal distance aspect ratio is known, false otherwise
     */
    public boolean isFocalDistanceAspectRatioKnown() {
<span class="fc" id="L331">        return focalDistanceAspectRatioKnown;</span>
    }

    /**
     * Sets value indicating whether aspect ratio of focal distances (i.e.
     * vertical focal distance divided by horizontal focal distance) is known or
     * not.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio. Typically, LCD sensor cells are square and hence aspect
     * ratio of focal distances is known and equal to 1.
     * This value is only taken into account if skewness is assumed to be zero,
     * otherwise it is ignored.
     *
     * @param focalDistanceAspectRatioKnown true if focal distance aspect ratio
     *                                      is known, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFocalDistanceAspectRatioKnown(final boolean focalDistanceAspectRatioKnown) throws LockedException {
<span class="fc bfc" id="L349" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L350">            throw new LockedException();</span>
        }

<span class="fc" id="L353">        this.focalDistanceAspectRatioKnown = focalDistanceAspectRatioKnown;</span>
<span class="fc" id="L354">    }</span>

    /**
     * Returns aspect ratio of focal distances (i.e. vertical focal distance
     * divided by horizontal focal distance).
     * This value is only taken into account if skewness is assumed to be zero
     * and focal distance aspect ratio is marked as known, otherwise it is
     * ignored.
     * By default, this is 1.0, since it is taken into account that typically
     * LCD sensor cells are square and hence aspect ratio focal distances is
     * known and equal to 1.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio.
     * Notice that a negative aspect ratio indicates that vertical axis is
     * reversed. This can be useful in some situations where image vertical
     * coordinates are reversed respect to the physical world (i.e. in computer
     * graphics typically image vertical coordinates go downwards, while in
     * physical world they go upwards).
     *
     * @return aspect ratio of focal distances.
     */
    public double getFocalDistanceAspectRatio() {
<span class="fc" id="L376">        return focalDistanceAspectRatio;</span>
    }

    /**
     * Sets aspect ratio of focal distances (i.e. vertical focal distance
     * divided by horizontal focal distance).
     * This value is only taken into account if skewness is assumed to be zero
     * and focal distance aspect ratio is marked as known, otherwise it is
     * ignored.
     * By default, this is 1.0, since it is taken into account that typically
     * LCD sensor cells are square and hence aspect ratio focal distances is
     * known and equal to 1.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio.
     * Notice that a negative aspect ratio indicates that vertical axis is
     * reversed. This can be useful in some situations where image vertical
     * coordinates are reversed respect to the physical world (i.e. in computer
     * graphics typically image vertical coordinates go downwards, while in
     * physical world they go upwards).
     *
     * @param focalDistanceAspectRatio aspect ratio of focal distances to be set.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if focal distance aspect ratio is too
     *                                  close to zero, as it might produce numerical instabilities.
     */
    public void setFocalDistanceAspectRatio(final double focalDistanceAspectRatio) throws LockedException {
<span class="fc bfc" id="L402" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L403">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L405" title="All 2 branches covered.">        if (Math.abs(focalDistanceAspectRatio) &lt; MIN_ABS_FOCAL_DISTANCE_ASPECT_RATIO) {</span>
<span class="fc" id="L406">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L409">        this.focalDistanceAspectRatio = focalDistanceAspectRatio;</span>
<span class="fc" id="L410">    }</span>

    /**
     * Indicates whether a singular DAQ is enforced or not.
     * Dual Absolute Quadric is singular (has rank 3) in any projective space,
     * however, due to noise in samples, estimated DAQ might not be fully
     * singular.
     *
     * @return true when singular DAQ is enforced, false otherwise.
     */
    public boolean isSingularityEnforced() {
<span class="fc" id="L421">        return singularityEnforced;</span>
    }

    /**
     * Specifies whether a singular DAQ is enforced or not.
     * Dual Absolute Quadric is singular (has rank 3) in any projective space,
     * however, due to noise in samples, estimated DAQ might not be fully
     * singular.
     *
     * @param singularityEnforced true when singular DAQ is enforced, false
     *                            otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setSingularityEnforced(final boolean singularityEnforced) throws LockedException {
<span class="fc bfc" id="L435" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L436">            throw new LockedException();</span>
        }
<span class="fc" id="L438">        this.singularityEnforced = singularityEnforced;</span>
<span class="fc" id="L439">    }</span>

    /**
     * Indicates whether enforced singularity will be validated by checking that
     * determinant of estimated Dual Absolute Quadric (DAQ) is below a certain
     * threshold.
     *
     * @return true if enforced singularity is validated, false otherwise.
     */
    public boolean isEnforcedSingularityValidated() {
<span class="fc" id="L449">        return validateEnforcedSingularity;</span>
    }

    /**
     * Specifies whether enforced singularity will be validated by checking that
     * determinant of estimated Dual Absolute Quadric (DAQ) is below a certain
     * threshold.
     *
     * @param validateEnforcedSingularity true if enforced singularity is
     *                                    validated, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setEnforcedSingularityValidated(final boolean validateEnforcedSingularity) throws LockedException {
<span class="fc bfc" id="L462" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L463">            throw new LockedException();</span>
        }
<span class="fc" id="L465">        this.validateEnforcedSingularity = validateEnforcedSingularity;</span>
<span class="fc" id="L466">    }</span>

    /**
     * Returns threshold to determine whether estimated Dual Absolute Quadric
     * (DAQ) has rank 3 or not when validation is enabled.
     *
     * @return threshold to determine whether estimated DAQ has rank 3 or not.
     */
    public double getDeterminantThreshold() {
<span class="fc" id="L475">        return determinantThreshold;</span>
    }

    /**
     * Sets threshold to determine whether estimated Dual Absolute Quadric (DAQ)
     * has rank 3 or not when validation is enabled.
     *
     * @param determinantThreshold threshold to determine whether estimated DAQ
     *                             has rank 3 or not.
     * @throws IllegalArgumentException if provided value is zero or negative.
     * @throws LockedException          if estimator is locked.
     */
    public void setDeterminantThreshold(final double determinantThreshold) throws LockedException {
<span class="fc bfc" id="L488" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L489">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L491" title="All 2 branches covered.">        if (determinantThreshold &lt; 0.0) {</span>
<span class="fc" id="L492">            throw new IllegalArgumentException(&quot;threshold must be positive and greater than zero&quot;);</span>
        }
<span class="fc" id="L494">        this.determinantThreshold = determinantThreshold;</span>
<span class="fc" id="L495">    }</span>

    /**
     * Indicates whether this instance is locked.
     *
     * @return true if this estimator is busy estimating the Dual Absolute
     * Quadric, false otherwise.
     */
    public boolean isLocked() {
<span class="fc" id="L504">        return locked;</span>
    }

    /**
     * Obtains listener to be notified of events such as when estimation starts,
     * ends or estimation progress changes.
     *
     * @return listener to be notified of events.
     */
    public DualAbsoluteQuadricEstimatorListener getListener() {
<span class="fc" id="L514">        return listener;</span>
    }

    /**
     * Sets listener to be notified of events such as when estimation starts,
     * ends or estimation progress changes.
     *
     * @param listener listener to be notified of events.
     */
    public void setListener(final DualAbsoluteQuadricEstimatorListener listener) {
<span class="fc" id="L524">        this.listener = listener;</span>
<span class="fc" id="L525">    }</span>

    /**
     * Obtains the list of cameras used to estimate the Dual Absolute Quadric
     * (DAQ).
     *
     * @return list of cameras to estimate the DAQ.
     */
    public List&lt;PinholeCamera&gt; getCameras() {
<span class="fc" id="L534">        return cameras;</span>
    }

    /**
     * Sets the list of cameras used to estimate the Dual Absolute Quadric
     * (DAQ).
     *
     * @param cameras list of cameras used to estimate the DAQ.
     * @throws IllegalArgumentException if list is null.
     * @throws LockedException          if estimator is locked.
     */
    public final void setCameras(final List&lt;PinholeCamera&gt; cameras) throws LockedException {
<span class="fc bfc" id="L546" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L547">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L549" title="1 of 4 branches missed.">        if (cameras == null || cameras.size() &lt; getMinNumberOfRequiredCameras()) {</span>
<span class="fc" id="L550">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L552">        this.cameras = cameras;</span>
<span class="fc" id="L553">    }</span>

    /**
     * Returns minimum number of required cameras needed to estimate the
     * Dual Absolute Quadric (DAQ).
     * At least 8 equations are needed to solve the DAQ
     * For each imposed constraint, one less equation is required.
     * Depending on the number of constraints more or less cameras will be
     * required.
     * If zero skewness is enforced, a solution is available with 8 cameras.
     * If zero skewness and focal distance aspect ratio is known, then a
     * solution is available with 4 cameras.
     * If principal point is located at origin, then a solution is available
     * with 4 cameras.
     * If zero skewness and principal point at origin are enforced, then a
     * solution is available with 3 cameras.
     * If zero skewness is enforced, focal distance aspect ratio is known and
     * principal point is at origin, then a solution is available with 2
     * cameras.
     * NOTE: minimum number of cameras considers only the cameras providing
     * additional information. If a camera is equivalent to another one or does
     * not provide additional information (such as a camera at the origin with
     * no rotation), then more cameras will be needed.
     *
     * @return minimum number of required cameras needed to estimate the Dual
     * Absolute Quadric (DAQ) or -1 if constraints configurations is not valid.
     */
    public int getMinNumberOfRequiredCameras() {
<span class="fc" id="L581">        var numEquations = 0;</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">        if (principalPointAtOrigin) {</span>
<span class="fc" id="L583">            numEquations += 2;</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">            if (zeroSkewness) {</span>
<span class="fc" id="L585">                numEquations++;</span>

                // only a linear solution exists for known aspect ratio if
                // skewness is zero
<span class="fc bfc" id="L589" title="All 2 branches covered.">                if (focalDistanceAspectRatioKnown) {</span>
<span class="fc" id="L590">                    numEquations++;</span>
                }
            }
        }

<span class="fc bfc" id="L595" title="All 2 branches covered.">        if (numEquations == 0) {</span>
<span class="fc" id="L596">            return -1;</span>
        }

<span class="fc" id="L599">        var minRequiredEquations = MIN_REQUIRED_EQUATIONS;</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">        if (singularityEnforced) {</span>
<span class="fc" id="L601">            minRequiredEquations--;</span>
        }
<span class="fc bfc" id="L603" title="All 2 branches covered.">        return (minRequiredEquations / numEquations) + ((minRequiredEquations % numEquations != 0) ? 1 : 0);</span>
    }

    /**
     * Indicates whether current constraints are enough to start the estimation.
     * In order to obtain a linear solution for the DAQ estimation, we need at
     * least the principal point at origin constraint.
     *
     * @return true if constraints are valid, false otherwise.
     */
    public boolean areValidConstraints() {
<span class="fc bfc" id="L614" title="All 6 branches covered.">        return principalPointAtOrigin &amp;&amp; (focalDistanceAspectRatioKnown || !singularityEnforced);</span>
    }


    /**
     * Indicates if this estimator is ready to start the estimation.
     *
     * @return true if estimator is ready, false otherwise.
     */
    public boolean isReady() {
<span class="fc bfc" id="L624" title="All 6 branches covered.">        return cameras != null &amp;&amp; cameras.size() &gt;= getMinNumberOfRequiredCameras() &amp;&amp; areValidConstraints();</span>
    }


    /**
     * Estimates the Dual Absolute Quadric using provided cameras.
     *
     * @return estimated Dual Absolute Quadric (DAQ).
     * @throws LockedException                       if estimator is locked.
     * @throws NotReadyException                     if no valid input data has already been
     *                                               provided.
     * @throws DualAbsoluteQuadricEstimatorException if an error occurs during
     *                                               estimation, usually because input data is not valid
     *                                               or numerically unstable.
     */
    public DualAbsoluteQuadric estimate() throws LockedException, NotReadyException,
            DualAbsoluteQuadricEstimatorException {
<span class="fc" id="L641">        final var result = new DualAbsoluteQuadric();</span>
<span class="fc" id="L642">        estimate(result);</span>
<span class="fc" id="L643">        return result;</span>
    }

    /**
     * Estimates the Dual Absolute Quadric using provided cameras.
     *
     * @param result instance where estimated Dual Absolute Quadric (DAQ) will
     *               be stored.
     * @throws LockedException                       if estimator is locked.
     * @throws NotReadyException                     if no valid input data has already been
     *                                               provided.
     * @throws DualAbsoluteQuadricEstimatorException if an error occurs during
     *                                               estimation, usually because input data is not valid
     *                                               or numerically unstable.
     */
    public abstract void estimate(final DualAbsoluteQuadric result) throws LockedException, NotReadyException,
        DualAbsoluteQuadricEstimatorException;


    /**
     * Returns type of Dual Absolute Quadric estimator.
     *
     * @return type of DAQ estimator.
     */
    public abstract DualAbsoluteQuadricEstimatorType getType();

    /**
     * Creates an instance of a DAQ estimator using default type.
     *
     * @return an instance of a DAQ estimator.
     */
    public static DualAbsoluteQuadricEstimator create() {
<span class="fc" id="L675">        return create(DEFAULT_ESTIMATOR_TYPE);</span>
    }

    /**
     * Creates an instance of Dual Absolute Quadric estimator using provided
     * listener and default type.
     *
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     * @return an instance of a DAQ estimator.
     */
    public static DualAbsoluteQuadricEstimator create(final DualAbsoluteQuadricEstimatorListener listener) {
<span class="fc" id="L687">        return create(listener, DEFAULT_ESTIMATOR_TYPE);</span>
    }

    /**
     * Creates an instance of Dual Absolute Quadric estimator using provided
     * cameras.
     *
     * @param cameras list of cameras used to estimate the Dual Absolute Quadric
     *                (DAQ).
     * @return an instance of a DAQ estimator.
     * @throws IllegalArgumentException if list of cameras is null or invalid
     *                                  for default constraints.
     */
    public static DualAbsoluteQuadricEstimator create(final List&lt;PinholeCamera&gt; cameras) {
<span class="fc" id="L701">        return create(cameras, DEFAULT_ESTIMATOR_TYPE);</span>
    }

    /**
     * Creates an instance of Dual Absolute Quadric estimator using provided
     * cameras and listener.
     *
     * @param cameras  list of cameras used to estimate the Dual Absolute Quadric
     *                 (DAQ).
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     * @return an instance of a DAQ estimator.
     * @throws IllegalArgumentException if list of cameras is null or invalid
     *                                  for default constraints.
     */
    public static DualAbsoluteQuadricEstimator create(
            final List&lt;PinholeCamera&gt; cameras, final DualAbsoluteQuadricEstimatorListener listener) {

<span class="fc" id="L719">        return create(cameras, listener, DEFAULT_ESTIMATOR_TYPE);</span>
    }

    /**
     * Creates an instance of a DAQ estimator using provided type.
     *
     * @param type type of DAQ estimator.
     * @return an instance of a DAQ estimator.
     */
    public static DualAbsoluteQuadricEstimator create(final DualAbsoluteQuadricEstimatorType type) {
<span class="fc bfc" id="L729" title="All 2 branches covered.">        return type == DualAbsoluteQuadricEstimatorType.WEIGHTED_DUAL_ABSOLUTE_QUADRIC_ESTIMATOR</span>
<span class="fc" id="L730">                ? new WeightedDualAbsoluteQuadricEstimator() : new LMSEDualAbsoluteQuadricEstimator();</span>
    }

    /**
     * Creates an instance of a DAQ estimator using provided listener and type.
     *
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     * @param type     type of DAQ estimator.
     * @return an instance of a DAQ estimator.
     */
    public static DualAbsoluteQuadricEstimator create(
            final DualAbsoluteQuadricEstimatorListener listener, final DualAbsoluteQuadricEstimatorType type) {
<span class="fc bfc" id="L743" title="All 2 branches covered.">        return type == DualAbsoluteQuadricEstimatorType.WEIGHTED_DUAL_ABSOLUTE_QUADRIC_ESTIMATOR</span>
<span class="fc" id="L744">                ? new WeightedDualAbsoluteQuadricEstimator(listener) : new LMSEDualAbsoluteQuadricEstimator(listener);</span>
    }

    /**
     * Creates an instance of a DAQ estimator using provided cameras and type.
     *
     * @param cameras list of cameras used to estimate the Dual Absolute Quadric
     *                (DAQ).
     * @param type    type of DAQ estimator.
     * @return an instance of a DAQ estimator.
     * @throws IllegalArgumentException if list of cameras is null or invalid
     *                                  for default constraints.
     */
    public static DualAbsoluteQuadricEstimator create(
            final List&lt;PinholeCamera&gt; cameras, final DualAbsoluteQuadricEstimatorType type) {
<span class="fc bfc" id="L759" title="All 2 branches covered.">        return type == DualAbsoluteQuadricEstimatorType.WEIGHTED_DUAL_ABSOLUTE_QUADRIC_ESTIMATOR</span>
<span class="fc" id="L760">                ? new WeightedDualAbsoluteQuadricEstimator(cameras) : new LMSEDualAbsoluteQuadricEstimator(cameras);</span>
    }

    /**
     * Creates an instance of a DAQ estimator using provided cameras, listener
     * and type.
     *
     * @param cameras  list of cameras used to estimate the Dual Absolute Quadric
     *                 (DAQ).
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     * @param type     type of DAQ estimator.
     * @return an instance of DAQ estimator.
     * @throws IllegalArgumentException if list of cameras is null or invalid
     *                                  for default constraints.
     */
    public static DualAbsoluteQuadricEstimator create(
            final List&lt;PinholeCamera&gt; cameras, final DualAbsoluteQuadricEstimatorListener listener,
            final DualAbsoluteQuadricEstimatorType type) {

<span class="fc bfc" id="L780" title="All 2 branches covered.">        return type == DualAbsoluteQuadricEstimatorType.WEIGHTED_DUAL_ABSOLUTE_QUADRIC_ESTIMATOR</span>
<span class="fc" id="L781">                ? new WeightedDualAbsoluteQuadricEstimator(cameras, listener)</span>
<span class="fc" id="L782">                : new LMSEDualAbsoluteQuadricEstimator(cameras, listener);</span>
    }

    /**
     * Normalizes i-th row of provided matrix &quot;a&quot;.
     *
     * @param a matrix whose row must be normalized.
     * @param i row to be normalized.
     */
    protected void normalizeRow(final Matrix a, final int i) {
<span class="fc" id="L792">        var rowNorm = 0.0;</span>
<span class="fc" id="L793">        final var cols = a.getColumns();</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">        for (var j = 0; j &lt; cols; j++) {</span>
<span class="fc" id="L795">            rowNorm += Math.pow(a.getElementAt(i, j), 2.0);</span>
        }

<span class="fc" id="L798">        rowNorm = Math.sqrt(rowNorm);</span>

<span class="fc bfc" id="L800" title="All 2 branches covered.">        for (var j = 0; j &lt; cols; j++) {</span>
<span class="fc" id="L801">            a.setElementAt(i, j, a.getElementAt(i, j) / rowNorm);</span>
        }
<span class="fc" id="L803">    }</span>

    /**
     * Fills equation p3^t*Q*p1 in provided row of matrix &quot;a&quot;.
     *
     * @param p11 element (1,1) of camera matrix.
     * @param p31 element (3,1) of camera matrix.
     * @param p12 element (1,2) of camera matrix.
     * @param p32 element (3,2) of camera matrix.
     * @param p13 element (1,3) of camera matrix.
     * @param p33 element (3,3) of camera matrix.
     * @param p14 element (1,4) of camera matrix.
     * @param p34 element (3,4) of camera matrix.
     * @param a   matrix where data is stored.
     * @param row row of matrix a where data is stored.
     */
    protected void fill3rdRowAnd1stRowEquation(
        final double p11, final double p31, final double p12, final double p32, final double p13, final double p33,
        final double p14, final double p34, final Matrix a, final int row) {

        // a
<span class="fc" id="L824">        a.setElementAt(row, 0, p31 * p11);</span>
        // b
<span class="fc" id="L826">        a.setElementAt(row, 1, p32 * p12);</span>
        // c
<span class="fc" id="L828">        a.setElementAt(row, 2, p33 * p13);</span>
        // d
<span class="fc" id="L830">        a.setElementAt(row, 3, p32 * p11 + p31 * p12);</span>
        // e
<span class="fc" id="L832">        a.setElementAt(row, 4, p33 * p12 + p32 * p13);</span>
        // f
<span class="fc" id="L834">        a.setElementAt(row, 5, p33 * p11 + p31 * p13);</span>
        // g
<span class="fc" id="L836">        a.setElementAt(row, 6, p34 * p11 + p31 * p14);</span>
        // h
<span class="fc" id="L838">        a.setElementAt(row, 7, p34 * p12 + p32 * p14);</span>
        // i
<span class="fc" id="L840">        a.setElementAt(row, 8, p34 * p13 + p33 * p14);</span>
        // j
<span class="fc" id="L842">        a.setElementAt(row, 9, p34 * p14);</span>

<span class="fc" id="L844">        normalizeRow(a, row);</span>
<span class="fc" id="L845">    }</span>

    /**
     * Fills equation p3^t*Q*p2 in provided row of matrix &quot;a&quot;.
     *
     * @param p21 element (2,1) of camera matrix.
     * @param p31 element (3,1) of camera matrix.
     * @param p22 element (2,2) of camera matrix.
     * @param p32 element (3,2) of camera matrix.
     * @param p23 element (2,3) of camera matrix.
     * @param p33 element (3,3) of camera matrix.
     * @param p24 element (2,4) of camera matrix.
     * @param p34 element (3,4) of camera matrix.
     * @param a   matrix where data is stored.
     * @param row row of matrix a where data is stored.
     */
    protected void fill3rdRowAnd2ndRowEquation(
        final double p21, final double p31, final double p22, final double p32, final double p23, final double p33,
        final double p24, final double p34, final Matrix a, final int row) {

        // a
<span class="fc" id="L866">        a.setElementAt(row, 0, p31 * p21);</span>
        // b
<span class="fc" id="L868">        a.setElementAt(row, 1, p32 * p22);</span>
        // c
<span class="fc" id="L870">        a.setElementAt(row, 2, p33 * p23);</span>
        // d
<span class="fc" id="L872">        a.setElementAt(row, 3, p32 * p21 + p31 * p22);</span>
        // e
<span class="fc" id="L874">        a.setElementAt(row, 4, p33 * p22 + p32 * p23);</span>
        // f
<span class="fc" id="L876">        a.setElementAt(row, 5, p33 * p21 + p31 * p23);</span>
        // g
<span class="fc" id="L878">        a.setElementAt(row, 6, p34 * p21 + p31 * p24);</span>
        // h
<span class="fc" id="L880">        a.setElementAt(row, 7, p34 * p22 + p32 * p24);</span>
        // i
<span class="fc" id="L882">        a.setElementAt(row, 8, p34 * p23 + p33 * p24);</span>
        // j
<span class="fc" id="L884">        a.setElementAt(row, 9, p34 * p24);</span>

<span class="fc" id="L886">        normalizeRow(a, row);</span>
<span class="fc" id="L887">    }</span>

    /**
     * Fills equation p2^t*Q*p1 in provided row of matrix &quot;a&quot;.
     *
     * @param p11 element (1,1) of camera matrix.
     * @param p21 element (2,1) of camera matrix.
     * @param p12 element (1,2) of camera matrix.
     * @param p22 element (2,2) of camera matrix.
     * @param p13 element (1,3) of camera matrix.
     * @param p23 element (2,3) of camera matrix.
     * @param p14 element (1,4) of camera matrix.
     * @param p24 element (2,4) of camera matrix.
     * @param a   matrix where data is stored.
     * @param row row of matrix a where data is stored.
     */
    protected void fill2ndRowAnd1stRowEquation(
        final double p11, final double p21, final double p12, final double p22, final double p13, final double p23,
        final double p14, final double p24, final Matrix a, final int row) {

        // a
<span class="fc" id="L908">        a.setElementAt(row, 0, p21 * p11);</span>
        // b
<span class="fc" id="L910">        a.setElementAt(row, 1, p22 * p12);</span>
        // c
<span class="fc" id="L912">        a.setElementAt(row, 2, p23 * p13);</span>
        // d
<span class="fc" id="L914">        a.setElementAt(row, 3, p22 * p11 + p21 * p12);</span>
        // e
<span class="fc" id="L916">        a.setElementAt(row, 4, p23 * p12 + p22 * p13);</span>
        // f
<span class="fc" id="L918">        a.setElementAt(row, 5, p23 * p11 + p21 * p13);</span>
        // g
<span class="fc" id="L920">        a.setElementAt(row, 6, p24 * p11 + p21 * p14);</span>
        // h
<span class="fc" id="L922">        a.setElementAt(row, 7, p24 * p12 + p22 * p14);</span>
        // i
<span class="fc" id="L924">        a.setElementAt(row, 8, p24 * p13 + p23 * p14);</span>
        // j
<span class="fc" id="L926">        a.setElementAt(row, 9, p24 * p14);</span>

<span class="fc" id="L928">        normalizeRow(a, row);</span>
<span class="fc" id="L929">    }</span>

    /**
     * Fills equation p1^t*Q*p1 = r^2*p2^t*Q*p2
     *
     * @param p11 element (1,1) of camera matrix.
     * @param p21 element (2,1) of camera matrix.
     * @param p12 element (1,2) of camera matrix.
     * @param p22 element (2,2) of camera matrix.
     * @param p13 element (1,3) of camera matrix.
     * @param p23 element (2,3) of camera matrix.
     * @param p14 element (1,4) of camera matrix.
     * @param p24 element (2,4) of camera matrix.
     * @param a   matrix where data is stored.
     * @param row row of matrix a where data is stored.
     */
    protected void fill1stRowEqualTo2ndRowEquation(
        final double p11, final double p21, final double p12, final double p22, final double p13, final double p23,
        final double p14, final double p24, final Matrix a, final int row) {

<span class="fc" id="L949">        final var r2 = focalDistanceAspectRatio * focalDistanceAspectRatio;</span>

        // a
<span class="fc" id="L952">        a.setElementAt(row, 0, p11 * p11 * r2 - p21 * p21);</span>
        // b
<span class="fc" id="L954">        a.setElementAt(row, 1, p12 * p12 * r2 - p22 * p22);</span>
        // c
<span class="fc" id="L956">        a.setElementAt(row, 2, p13 * p13 * r2 - p23 * p23);</span>
        // d
<span class="fc" id="L958">        a.setElementAt(row, 3, 2.0 * (p12 * p11 * r2 - p22 * p21));</span>
        // e
<span class="fc" id="L960">        a.setElementAt(row, 4, 2.0 * (p13 * p12 * r2 - p23 * p22));</span>
        // f
<span class="fc" id="L962">        a.setElementAt(row, 5, 2.0 * (p13 * p11 * r2 - p23 * p21));</span>
        // g
<span class="fc" id="L964">        a.setElementAt(row, 6, 2.0 * (p14 * p11 * r2 - p24 * p21));</span>
        // h
<span class="fc" id="L966">        a.setElementAt(row, 7, 2.0 * (p14 * p12 * r2 - p24 * p22));</span>
        // i
<span class="fc" id="L968">        a.setElementAt(row, 8, 2.0 * (p14 * p13 * r2 - p24 * p23));</span>
        // j
<span class="fc" id="L970">        a.setElementAt(row, 9, p14 * p14 * r2 - p24 * p24);</span>

<span class="fc" id="L972">        normalizeRow(a, row);</span>
<span class="fc" id="L973">    }</span>

    /**
     * Enforces (if needed) rank 3 of estimated quadric by building a polynomial
     * out of the last columns of the singular value vector matrix to obtain a
     * linear combination solution.
     *
     * @param decomposer decomposer containing possible solutions after
     *                   decomposition.
     * @param result     instance where estimated Dual Absolute Quadrics (DAQs) with
     *                   rank 3 enforced will be stored.
     * @throws AlgebraException                      if there are numerical instabilities
     * @throws NumericalException                    if a solution to the polynomial enforcing
     *                                               rank 3 cannot be found.
     * @throws DualAbsoluteQuadricEstimatorException if something else fails.
     */
    protected void enforceRank3IfNeeded(final SingularValueDecomposer decomposer, final DualAbsoluteQuadric result)
        throws AlgebraException, NumericalException, DualAbsoluteQuadricEstimatorException {

<span class="fc" id="L992">        decomposer.decompose();</span>

<span class="fc bfc" id="L994" title="All 2 branches covered.">        if (singularityEnforced) {</span>
<span class="pc bpc" id="L995" title="1 of 2 branches missed.">            if (decomposer.getNullity() &gt; 2) {</span>
                // provided cameras are degenerate and there is not a single
                // solution for the DAQ (up to scale)
<span class="nc" id="L998">                throw new DualAbsoluteQuadricEstimatorException();</span>
            }

<span class="fc" id="L1001">            final var v = decomposer.getV();</span>

            // last 2 columns of v contains parameters a, b, c, d, e,
            // f, g, h, i  that can be obtained as a linear combination of
            // those last columns (i.e. a = a1 + alpha*a2).
            // By enforcing determinant zero, we can obtain a 4th degree
            // polynomial to determine alpha to find the unique linear
            // combination of last 2 columns that solve both DAQ equation and
            // generates rank 3 DAQ.
<span class="fc" id="L1010">            final var a1 = v.getElementAt(0, 8);</span>
<span class="fc" id="L1011">            final var b1 = v.getElementAt(1, 8);</span>
<span class="fc" id="L1012">            final var c1 = v.getElementAt(2, 8);</span>
<span class="fc" id="L1013">            final var d1 = v.getElementAt(3, 8);</span>
<span class="fc" id="L1014">            final var e1 = v.getElementAt(4, 8);</span>
<span class="fc" id="L1015">            final var f1 = v.getElementAt(5, 8);</span>
<span class="fc" id="L1016">            final var g1 = v.getElementAt(6, 8);</span>
<span class="fc" id="L1017">            final var h1 = v.getElementAt(7, 8);</span>
<span class="fc" id="L1018">            final var i1 = v.getElementAt(8, 8);</span>
<span class="fc" id="L1019">            final var j1 = v.getElementAt(9, 8);</span>

<span class="fc" id="L1021">            final var a2 = v.getElementAt(0, 9);</span>
<span class="fc" id="L1022">            final var b2 = v.getElementAt(1, 9);</span>
<span class="fc" id="L1023">            final var c2 = v.getElementAt(2, 9);</span>
<span class="fc" id="L1024">            final var d2 = v.getElementAt(3, 9);</span>
<span class="fc" id="L1025">            final var e2 = v.getElementAt(4, 9);</span>
<span class="fc" id="L1026">            final var f2 = v.getElementAt(5, 9);</span>
<span class="fc" id="L1027">            final var g2 = v.getElementAt(6, 9);</span>
<span class="fc" id="L1028">            final var h2 = v.getElementAt(7, 9);</span>
<span class="fc" id="L1029">            final var i2 = v.getElementAt(8, 9);</span>
<span class="fc" id="L1030">            final var j2 = v.getElementAt(9, 9);</span>

<span class="fc" id="L1032">            final var poly = buildPolynomialToEnforceRank3(a1, b1, c1, d1, e1, f1, g1, h1, i1, j1, a2, b2, c2, d2, e2,</span>
                    f2, g2, h2, i2, j2);

<span class="fc" id="L1035">            final var roots = poly.getRoots();</span>

<span class="pc bpc" id="L1037" title="1 of 2 branches missed.">            if (roots != null) {</span>
                // pick the best solution (closest real root) = evaluation closest to
                // zero
<span class="fc" id="L1040">                var bestPolyEval = Double.MAX_VALUE;</span>
<span class="fc bfc" id="L1041" title="All 2 branches covered.">                for (final var root : roots) {</span>
<span class="fc" id="L1042">                    final var real = root.getReal();</span>
<span class="fc" id="L1043">                    final var polyEval = Math.abs(poly.evaluate(real));</span>
<span class="fc bfc" id="L1044" title="All 2 branches covered.">                    if (polyEval &lt; bestPolyEval) {</span>
<span class="fc" id="L1045">                        bestPolyEval = polyEval;</span>
<span class="fc" id="L1046">                        final var a = a1 + real * a2;</span>
<span class="fc" id="L1047">                        final var b = b1 + real * b2;</span>
<span class="fc" id="L1048">                        final var c = c1 + real * c2;</span>
<span class="fc" id="L1049">                        final var d = d1 + real * d2;</span>
<span class="fc" id="L1050">                        final var e = e1 + real * e2;</span>
<span class="fc" id="L1051">                        final var f = f1 + real * f2;</span>
<span class="fc" id="L1052">                        final var g = g1 + real * g2;</span>
<span class="fc" id="L1053">                        final var h = h1 + real * h2;</span>
<span class="fc" id="L1054">                        final var i = i1 + real * i2;</span>
<span class="fc" id="L1055">                        final var j = j1 + real * j2;</span>
<span class="fc" id="L1056">                        result.setParameters(a, b, c, d, e, f, g, h, i, j);</span>
                    }
                }
<span class="fc" id="L1059">            } else {</span>
                // if no roots could be found, it might be due to numerical
                // inaccuracies, so we find minimum or maximum of polynomial
                // which evaluates closest to zero
<span class="nc" id="L1063">                final var extrema = poly.getExtrema();</span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">                if (extrema == null) {</span>
                    // polynomial has no extrema, which means it is degenerate
<span class="nc" id="L1066">                    throw new DualAbsoluteQuadricEstimatorException();</span>
                }

<span class="nc" id="L1069">                var bestPolyEval = Double.MAX_VALUE;</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">                for (final var extremum : extrema) {</span>
<span class="nc" id="L1071">                    final var polyEval = Math.abs(poly.evaluate(extremum));</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">                    if (polyEval &lt; bestPolyEval) {</span>
<span class="nc" id="L1073">                        bestPolyEval = polyEval;</span>
<span class="nc" id="L1074">                        final var a = a1 + extremum * a2;</span>
<span class="nc" id="L1075">                        final var b = b1 + extremum * b2;</span>
<span class="nc" id="L1076">                        final var c = c1 + extremum * c2;</span>
<span class="nc" id="L1077">                        final var d = d1 + extremum * d2;</span>
<span class="nc" id="L1078">                        final var e = e1 + extremum * e2;</span>
<span class="nc" id="L1079">                        final var f = f1 + extremum * f2;</span>
<span class="nc" id="L1080">                        final var g = g1 + extremum * g2;</span>
<span class="nc" id="L1081">                        final var h = h1 + extremum * h2;</span>
<span class="nc" id="L1082">                        final var i = i1 + extremum * i2;</span>
<span class="nc" id="L1083">                        final var j = j1 + extremum * j2;</span>
<span class="nc" id="L1084">                        result.setParameters(a, b, c, d, e, f, g, h, i, j);</span>
                    }
                }

<span class="nc bnc" id="L1088" title="All 2 branches missed.">                if (validateEnforcedSingularity) {</span>
                    // check that determinant of estimated DAQ is below allowed
                    // threshold
<span class="nc" id="L1091">                    final var absDet = Math.abs(Utils.det(result.asMatrix()));</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">                    if (absDet &gt; determinantThreshold) {</span>
                        // DAQ does not have rank 3
<span class="nc" id="L1094">                        throw new DualAbsoluteQuadricEstimatorException();</span>
                    }
                }
            }

<span class="fc" id="L1099">        } else {</span>
<span class="fc bfc" id="L1100" title="All 2 branches covered.">            if (decomposer.getNullity() &gt; 1) {</span>
                // provided cameras are degenerate and there is not a single
                // solution for the DAQ (up to scale)
<span class="fc" id="L1103">                throw new DualAbsoluteQuadricEstimatorException();</span>
            }

<span class="fc" id="L1106">            final var v = decomposer.getV();</span>

            // last column of v contains parameters a, b, c, d, e, f, g, h, i
            // defining the Dual Absolute Quadric (DAQ) as:
<span class="fc" id="L1110">            final var a = v.getElementAt(0, 9);</span>
<span class="fc" id="L1111">            final var b = v.getElementAt(1, 9);</span>
<span class="fc" id="L1112">            final var c = v.getElementAt(2, 9);</span>
<span class="fc" id="L1113">            final var d = v.getElementAt(3, 9);</span>
<span class="fc" id="L1114">            final var e = v.getElementAt(4, 9);</span>
<span class="fc" id="L1115">            final var f = v.getElementAt(5, 9);</span>
<span class="fc" id="L1116">            final var g = v.getElementAt(6, 9);</span>
<span class="fc" id="L1117">            final var h = v.getElementAt(7, 9);</span>
<span class="fc" id="L1118">            final var i = v.getElementAt(8, 9);</span>
<span class="fc" id="L1119">            final var j = v.getElementAt(9, 9);</span>

<span class="fc" id="L1121">            result.setParameters(a, b, c, d, e, f, g, h, i, j);</span>
        }
<span class="fc" id="L1123">    }</span>

    /**
     * Builds polynomial to enforce rank 3 (zero determinant).
     *
     * @param a1 a of 1st DAQ.
     * @param b1 b of 1st DAQ.
     * @param c1 c of 1st DAQ.
     * @param d1 d of 1st DAQ.
     * @param e1 e of 1st DAQ.
     * @param f1 f of 1st DAQ.
     * @param g1 g of 1st DAQ.
     * @param h1 h of 1st DAQ.
     * @param i1 i of 1st DAQ.
     * @param j1 j of 1st DAQ.
     * @param a2 a of 2nd DAQ.
     * @param b2 b of 2nd DAQ.
     * @param c2 c of 2nd DAQ.
     * @param d2 d of 2nd DAQ.
     * @param e2 e of 2nd DAQ.
     * @param f2 f of 2nd DAQ.
     * @param g2 g of 2nd DAQ.
     * @param h2 h of 2nd DAQ.
     * @param i2 i of 2nd DAQ.
     * @param j2 j of 2nd DAQ.
     * @return polynomial.
     */
    private Polynomial buildPolynomialToEnforceRank3(
            final double a1, final double b1, final double c1, final double d1, final double e1,
            final double f1, final double g1, final double h1, final double i1, final double j1,
            final double a2, final double b2, final double c2, final double d2, final double e2,
            final double f2, final double g2, final double h2, final double i2, final double j2) {

<span class="fc" id="L1156">        final var polyA = new Polynomial(a1, a2);</span>
<span class="fc" id="L1157">        final var polyB = new Polynomial(b1, b2);</span>
<span class="fc" id="L1158">        final var polyC = new Polynomial(c1, c2);</span>
<span class="fc" id="L1159">        final var polyD = new Polynomial(d1, d2);</span>
<span class="fc" id="L1160">        final var polyE = new Polynomial(e1, e2);</span>
<span class="fc" id="L1161">        final var polyF = new Polynomial(f1, f2);</span>
<span class="fc" id="L1162">        final var polyG = new Polynomial(g1, g2);</span>
<span class="fc" id="L1163">        final var polyH = new Polynomial(h1, h2);</span>
<span class="fc" id="L1164">        final var polyI = new Polynomial(i1, i2);</span>
<span class="fc" id="L1165">        final var polyJ = new Polynomial(j1, j2);</span>

<span class="fc" id="L1167">        final var result = new Polynomial(5);</span>

        // (a1 + x*a2) * (b1 + x*b2) * (c1 + x*c2) * (j1 + x*j2)
<span class="fc" id="L1170">        var tmp = polyA.multiplyAndReturnNew(polyB);</span>
<span class="fc" id="L1171">        tmp.multiply(polyC);</span>
<span class="fc" id="L1172">        tmp.multiply(polyJ);</span>

<span class="fc" id="L1174">        result.add(tmp);</span>

        // 2 * (a1 + x*a2) * (e1 + x*e2) * (h1 + x*h2) * (i1 + x*i2)
<span class="fc" id="L1177">        tmp = polyA.multiplyAndReturnNew(polyE);</span>
<span class="fc" id="L1178">        tmp.multiply(polyH);</span>
<span class="fc" id="L1179">        tmp.multiply(polyI);</span>
<span class="fc" id="L1180">        tmp.multiplyByScalar(2.0);</span>

<span class="fc" id="L1182">        result.add(tmp);</span>

        // -1 * (a1 + x*a2) * (c1 + x*c2) * (h1 + x*h2)^2
<span class="fc" id="L1185">        tmp = polyA.multiplyAndReturnNew(polyC);</span>
<span class="fc" id="L1186">        tmp.multiply(polyH);</span>
<span class="fc" id="L1187">        tmp.multiply(polyH);</span>
<span class="fc" id="L1188">        tmp.multiplyByScalar(-1.0);</span>

<span class="fc" id="L1190">        result.add(tmp);</span>

        // -1 * (a1 + x*a2) * (b1 + x*b2) * (i1 + x*i2)^2
<span class="fc" id="L1193">        tmp = polyA.multiplyAndReturnNew(polyB);</span>
<span class="fc" id="L1194">        tmp.multiply(polyI);</span>
<span class="fc" id="L1195">        tmp.multiply(polyI);</span>
<span class="fc" id="L1196">        tmp.multiplyByScalar(-1.0);</span>

<span class="fc" id="L1198">        result.add(tmp);</span>

        // -1 * (a1 + x*a2) * (e1 + x*e2)^2 * (j1 + x*j2)
<span class="fc" id="L1201">        tmp = polyA.multiplyAndReturnNew(polyE);</span>
<span class="fc" id="L1202">        tmp.multiply(polyE);</span>
<span class="fc" id="L1203">        tmp.multiply(polyJ);</span>
<span class="fc" id="L1204">        tmp.multiplyByScalar(-1.0);</span>

<span class="fc" id="L1206">        result.add(tmp);</span>

        // -1 * (c1 + x*c2) * (d1 + x*d2)^2 * (j1 + x*j2)
<span class="fc" id="L1209">        tmp = polyC.multiplyAndReturnNew(polyD);</span>
<span class="fc" id="L1210">        tmp.multiply(polyD);</span>
<span class="fc" id="L1211">        tmp.multiply(polyJ);</span>
<span class="fc" id="L1212">        tmp.multiplyByScalar(-1.0);</span>

<span class="fc" id="L1214">        result.add(tmp);</span>

        // -2 * (d1 + x*d2) * (f1 + x*f2) * (h1 + x*h2) * (i1 + x*i2)
<span class="fc" id="L1217">        tmp = polyD.multiplyAndReturnNew(polyF);</span>
<span class="fc" id="L1218">        tmp.multiply(polyH);</span>
<span class="fc" id="L1219">        tmp.multiply(polyI);</span>
<span class="fc" id="L1220">        tmp.multiplyByScalar(-2.0);</span>

<span class="fc" id="L1222">        result.add(tmp);</span>

        // -2 * (d1 + x*d2) * (e1 + x*e2) * (g1 + x*g2) * (i1 + x*i2)
<span class="fc" id="L1225">        tmp = polyD.multiplyAndReturnNew(polyE);</span>
<span class="fc" id="L1226">        tmp.multiply(polyG);</span>
<span class="fc" id="L1227">        tmp.multiply(polyI);</span>
<span class="fc" id="L1228">        tmp.multiplyByScalar(-2.0);</span>

<span class="fc" id="L1230">        result.add(tmp);</span>

        // 2 * (c1 + x*c2) * (d1 + x*d2) * (g1 + x*g2) * (h1 + x*h2)
<span class="fc" id="L1233">        tmp = polyC.multiplyAndReturnNew(polyD);</span>
<span class="fc" id="L1234">        tmp.multiply(polyG);</span>
<span class="fc" id="L1235">        tmp.multiply(polyH);</span>
<span class="fc" id="L1236">        tmp.multiplyByScalar(2.0);</span>

<span class="fc" id="L1238">        result.add(tmp);</span>

        // (d1 + x*d2)^2 * (i1 + x*i2)^2
<span class="fc" id="L1241">        tmp = polyD.multiplyAndReturnNew(polyD);</span>
<span class="fc" id="L1242">        tmp.multiply(polyI);</span>
<span class="fc" id="L1243">        tmp.multiply(polyI);</span>

<span class="fc" id="L1245">        result.add(tmp);</span>

        // 2 * (d1 + x*d2) * (e1 + x*e2) * (f1 + x*f2) * (j1 + x*j2)
<span class="fc" id="L1248">        tmp = polyD.multiplyAndReturnNew(polyE);</span>
<span class="fc" id="L1249">        tmp.multiply(polyF);</span>
<span class="fc" id="L1250">        tmp.multiply(polyJ);</span>
<span class="fc" id="L1251">        tmp.multiplyByScalar(2.0);</span>

<span class="fc" id="L1253">        result.add(tmp);</span>

        // (f1 + x*f2)^2 * (h1 + x*h2)^2
<span class="fc" id="L1256">        tmp = polyF.multiplyAndReturnNew(polyF);</span>
<span class="fc" id="L1257">        tmp.multiply(polyH);</span>
<span class="fc" id="L1258">        tmp.multiply(polyH);</span>

<span class="fc" id="L1260">        result.add(tmp);</span>

        // 2 * (b1 + x*b2) * (f1 + x*f2) * (g1 + x*g2) * (i1 + x*i2)
<span class="fc" id="L1263">        tmp = polyB.multiplyAndReturnNew(polyF);</span>
<span class="fc" id="L1264">        tmp.multiply(polyG);</span>
<span class="fc" id="L1265">        tmp.multiply(polyI);</span>
<span class="fc" id="L1266">        tmp.multiplyByScalar(2.0);</span>

<span class="fc" id="L1268">        result.add(tmp);</span>

        // -2 * (e1 + x*e2) * (f1 + x*r2) * (g1 + x*g2) * (h1 + x*h2)
<span class="fc" id="L1271">        tmp = polyE.multiplyAndReturnNew(polyF);</span>
<span class="fc" id="L1272">        tmp.multiply(polyG);</span>
<span class="fc" id="L1273">        tmp.multiply(polyH);</span>
<span class="fc" id="L1274">        tmp.multiplyByScalar(-2.0);</span>

<span class="fc" id="L1276">        result.add(tmp);</span>

        // -1 * (b1 + x*b2) * (f1 + x*f2)^2 * (j1 + x*j2)
<span class="fc" id="L1279">        tmp = polyB.multiplyAndReturnNew(polyF);</span>
<span class="fc" id="L1280">        tmp.multiply(polyF);</span>
<span class="fc" id="L1281">        tmp.multiply(polyJ);</span>
<span class="fc" id="L1282">        tmp.multiplyByScalar(-1.0);</span>

<span class="fc" id="L1284">        result.add(tmp);</span>

        // -1 * (b1 + x*b2) * (c1 + x*c2) * (g1 + x*g2)^2
<span class="fc" id="L1287">        tmp = polyB.multiplyAndReturnNew(polyC);</span>
<span class="fc" id="L1288">        tmp.multiply(polyG);</span>
<span class="fc" id="L1289">        tmp.multiply(polyG);</span>
<span class="fc" id="L1290">        tmp.multiplyByScalar(-1.0);</span>

<span class="fc" id="L1292">        result.add(tmp);</span>

        // (e1 + x*e2)^2 * (g1 + x*g2)^2
<span class="fc" id="L1295">        tmp = polyE.multiplyAndReturnNew(polyE);</span>
<span class="fc" id="L1296">        tmp.multiply(polyG);</span>
<span class="fc" id="L1297">        tmp.multiply(polyG);</span>

<span class="fc" id="L1299">        result.add(tmp);</span>

<span class="fc" id="L1301">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>