<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WeightedDualAbsoluteQuadricEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.calibration.estimators</a> &gt; <span class="el_source">WeightedDualAbsoluteQuadricEstimator.java</span></div><h1>WeightedDualAbsoluteQuadricEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2016 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.irurueta.ar.calibration.estimators;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.SingularValueDecomposer;
import com.irurueta.algebra.Utils;
import com.irurueta.ar.calibration.DualAbsoluteQuadric;
import com.irurueta.geometry.BaseQuadric;
import com.irurueta.geometry.PinholeCamera;
import com.irurueta.geometry.estimators.LockedException;
import com.irurueta.geometry.estimators.NotReadyException;
import com.irurueta.numerical.NumericalException;
import com.irurueta.numerical.robust.WeightSelection;
import com.irurueta.sorting.SortingException;

import java.util.List;

/**
 * Implementation of a Dual Absolute Quadric estimator using a weighted solution
 * for provided pinhole cameras.
 * This implementation assumes that:
 * - cameras are arbitrary (usually the initial camera is the identity and must
 * be discarded) as it creates a numerical degeneracy.
 * - all provided cameras have the same intrinsic parameters
 * - it is assumed that skewness is zero, the principal point is at the center
 * of the image plane (zero), and both horizontal and vertical focal planes are
 * equal.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class WeightedDualAbsoluteQuadricEstimator extends DualAbsoluteQuadricEstimator {

    /**
     * Default number of cameras (i.e. correspondences) to be weighted and taken
     * into account.
     */
    public static final int DEFAULT_MAX_CAMERAS = 50;

    /**
     * Indicates if weights are sorted by default so that largest weighted
     * cameras are used first.
     */
    public static final boolean DEFAULT_SORT_WEIGHTS = true;

    /**
     * Maximum number of cameras (i.e. correspondences) to be weighted and taken
     * into account.
     */
    private int maxCameras;

    /**
     * Indicates if weights are sorted by default so that largest weighted
     * cameras are used first.
     */
    private boolean sortWeights;

    /**
     * Array containing weights for all cameras.
     */
    private double[] weights;

    /**
     * Constructor.
     */
    public WeightedDualAbsoluteQuadricEstimator() {
<span class="fc" id="L81">        super();</span>
<span class="fc" id="L82">        maxCameras = DEFAULT_MAX_CAMERAS;</span>
<span class="fc" id="L83">        sortWeights = DEFAULT_SORT_WEIGHTS;</span>
<span class="fc" id="L84">        weights = null;</span>
<span class="fc" id="L85">    }</span>

    /**
     * Constructor with listener.
     *
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     */
    public WeightedDualAbsoluteQuadricEstimator(final DualAbsoluteQuadricEstimatorListener listener) {
<span class="fc" id="L94">        super(listener);</span>
<span class="fc" id="L95">        maxCameras = DEFAULT_MAX_CAMERAS;</span>
<span class="fc" id="L96">        sortWeights = DEFAULT_SORT_WEIGHTS;</span>
<span class="fc" id="L97">        weights = null;</span>
<span class="fc" id="L98">    }</span>

    /**
     * Constructor.
     *
     * @param cameras list of cameras used to estimate the Dual Absolute Quadric
     *                (DAQ).
     * @throws IllegalArgumentException if list of cameras is null.
     */
    public WeightedDualAbsoluteQuadricEstimator(final List&lt;PinholeCamera&gt; cameras) {
<span class="fc" id="L108">        super(cameras);</span>
<span class="fc" id="L109">        maxCameras = DEFAULT_MAX_CAMERAS;</span>
<span class="fc" id="L110">        sortWeights = DEFAULT_SORT_WEIGHTS;</span>
<span class="fc" id="L111">        weights = null;</span>
<span class="fc" id="L112">    }</span>

    /**
     * Constructor.
     *
     * @param cameras  list of cameras used to estimate the Dual Absolute Quadric
     *                 (DAQ).
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     * @throws IllegalArgumentException if list of cameras is null.
     */
    public WeightedDualAbsoluteQuadricEstimator(
            final List&lt;PinholeCamera&gt; cameras, final DualAbsoluteQuadricEstimatorListener listener) {
<span class="fc" id="L125">        super(cameras, listener);</span>
<span class="fc" id="L126">        maxCameras = DEFAULT_MAX_CAMERAS;</span>
<span class="fc" id="L127">        sortWeights = DEFAULT_SORT_WEIGHTS;</span>
<span class="fc" id="L128">        weights = null;</span>
<span class="fc" id="L129">    }</span>

    /**
     * Constructor.
     *
     * @param cameras list of cameras used to estimate the Dual Absolute Quadric
     *                (DAQ).
     * @param weights array containing a weight amount for each corresponding
     *                camera. The larger the value of a weight, the most significant the
     *                corresponding camera data will be.
     * @throws IllegalArgumentException if provided lists of cameras and weights
     *                                  don't have the same size or enough cameras.
     */
    public WeightedDualAbsoluteQuadricEstimator(
            final List&lt;PinholeCamera&gt; cameras, final double[] weights) {
<span class="fc" id="L144">        super(cameras);</span>
<span class="fc" id="L145">        maxCameras = DEFAULT_MAX_CAMERAS;</span>
<span class="fc" id="L146">        sortWeights = DEFAULT_SORT_WEIGHTS;</span>
        try {
<span class="fc" id="L148">            setWeights(weights);</span>
<span class="nc" id="L149">        } catch (final LockedException ignore) {</span>
            // never thrown
<span class="fc" id="L151">        }</span>
<span class="fc" id="L152">    }</span>

    /**
     * Constructor.
     *
     * @param cameras  list of cameras used to estimate the Dual Absolute Quadric
     *                 (DAQ).
     * @param weights  array containing a weight amount for each corresponding
     *                 camera. The largest the value of a weight, the most significant the
     *                 corresponding camera data will be.
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     * @throws IllegalArgumentException if provided lists of cameras and weights
     *                                  don't have the same size or enough cameras.
     */
    public WeightedDualAbsoluteQuadricEstimator(
            final List&lt;PinholeCamera&gt; cameras, final double[] weights,
            final DualAbsoluteQuadricEstimatorListener listener) {
<span class="fc" id="L170">        super(cameras, listener);</span>
<span class="fc" id="L171">        maxCameras = DEFAULT_MAX_CAMERAS;</span>
<span class="fc" id="L172">        sortWeights = DEFAULT_SORT_WEIGHTS;</span>
        try {
<span class="fc" id="L174">            setWeights(weights);</span>
<span class="nc" id="L175">        } catch (final LockedException ignore) {</span>
            // never thrown
<span class="fc" id="L177">        }</span>
<span class="fc" id="L178">    }</span>

    /**
     * Indicates whether provided cameras and weights are valid or not.
     * Cameras and weights must have the same length to be valid and their
     * length must be greater than 1.
     *
     * @param cameras list of cameras to check.
     * @param weights array of weights to check.
     * @return true if cameras and weights are valid, false otherwise.
     */
    public static boolean areValidCamerasAndWeights(final List&lt;PinholeCamera&gt; cameras, final double[] weights) {
<span class="fc bfc" id="L190" title="All 6 branches covered.">        return cameras != null &amp;&amp; weights != null &amp;&amp; cameras.size() == weights.length;</span>
    }

    /**
     * Returns array containing a weight amount for each corresponding camera.
     * The largest the value of a weight, the more significant the corresponding
     * camera data will be.
     *
     * @return weights for each corresponding camera.
     */
    public double[] getWeights() {
<span class="fc" id="L201">        return weights;</span>
    }

    /**
     * Sets array of camera weight for each corresponding camera.
     * The largest the value of a weight, the more significant the corresponding
     * camera data will be.
     *
     * @param weights weights for each corresponding camera.
     * @throws IllegalArgumentException if provided lists of cameras and weights
     *                                  don't have the same size or enough cameras.
     * @throws LockedException          if estimator is locked.
     */
    public final void setWeights(final double[] weights) throws LockedException {
<span class="fc bfc" id="L215" title="All 2 branches covered.">        if (!areValidCamerasAndWeights(cameras, weights)) {</span>
<span class="fc" id="L216">            throw new IllegalArgumentException(&quot;cameras and weights must have the same length&quot;);</span>
        }
<span class="fc bfc" id="L218" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L219">            throw new LockedException();</span>
        }

<span class="fc" id="L222">        this.weights = weights;</span>
<span class="fc" id="L223">    }</span>

    /**
     * Sets list of cameras and corresponding weights.
     *
     * @param cameras list of cameras used to estimate the Dual Absolute Quadric
     *                (DAQ).
     * @param weights array containing a weight amount for each corresponding
     *                camera. The largest the value of a weight, the most significant the
     *                corresponding camera data will be.
     * @throws IllegalArgumentException if provided lists of cameras and weights
     *                                  don't have the same size or enough cameras.
     * @throws LockedException          if estimator is locked.
     */
    public void setCamerasAndWeights(final List&lt;PinholeCamera&gt; cameras, final double[] weights) throws LockedException {
<span class="fc bfc" id="L238" title="All 2 branches covered.">        if (!areValidCamerasAndWeights(cameras, weights)) {</span>
<span class="fc" id="L239">            throw new IllegalArgumentException(&quot;cameras and weights must have the same length&quot;);</span>
        }
<span class="fc bfc" id="L241" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L242">            throw new LockedException();</span>
        }

<span class="fc" id="L245">        this.cameras = cameras;</span>
<span class="fc" id="L246">        this.weights = weights;</span>
<span class="fc" id="L247">    }</span>

    /**
     * Indicates whether weights have already been provided or not.
     *
     * @return true if weights have been provided, false otherwise.
     */
    public boolean areWeightsAvailable() {
<span class="fc bfc" id="L255" title="All 2 branches covered.">        return weights != null;</span>
    }

    /**
     * Gets the maximum number of cameras (i.e. correspondences) to be weighted
     * and taken into account.
     *
     * @return maximum number of cameras.
     */
    public int getMaxCameras() {
<span class="fc" id="L265">        return maxCameras;</span>
    }

    /**
     * Sets the maximum number of cameras (i.e. correspondences) to be weighted
     * and taken into account.
     *
     * @param maxCameras maximum number of cameras.
     * @throws IllegalArgumentException if provided value is less than 2.
     * @throws LockedException          if estimator is locked.
     */
    public void setMaxCameras(final int maxCameras) throws LockedException {
<span class="fc bfc" id="L277" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L278">            throw new LockedException();</span>
        }

<span class="fc" id="L281">        this.maxCameras = maxCameras;</span>
<span class="fc" id="L282">    }</span>

    /**
     * Indicates if weights are sorted by default so that largest weighted
     * cameras are used first.
     *
     * @return true if weights are sorted by default, false otherwise.
     */
    public boolean isSortWeightsEnabled() {
<span class="fc" id="L291">        return sortWeights;</span>
    }

    /**
     * Specifies whether weights are sorted by default so that largest weighted
     * cameras are used first.
     *
     * @param sortWeights true if weights are sorted by default, false
     *                    otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setSortWeightsEnabled(final boolean sortWeights) throws LockedException {
<span class="fc bfc" id="L303" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L304">            throw new LockedException();</span>
        }

<span class="fc" id="L307">        this.sortWeights = sortWeights;</span>
<span class="fc" id="L308">    }</span>

    /**
     * Indicates if this estimator is ready to start the estimation.
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
<span class="pc bpc" id="L317" title="1 of 6 branches missed.">        return super.isReady() &amp;&amp; areWeightsAvailable() &amp;&amp; maxCameras &gt;= getMinNumberOfRequiredCameras();</span>
    }

    /**
     * Estimates the Dual Absolute Quadric using provided cameras.
     *
     * @param result instance where estimated Dual Absolute Quadric (DAQ) will
     *               be stored.
     * @throws LockedException                       if estimator is locked.
     * @throws NotReadyException                     if no valid input data has already been
     *                                               provided.
     * @throws DualAbsoluteQuadricEstimatorException if an error occurs during
     *                                               estimation, usually because input data is not valid or
     *                                               numerically unstable.
     */
    @Override
    public void estimate(final DualAbsoluteQuadric result) throws LockedException, NotReadyException,
            DualAbsoluteQuadricEstimatorException {

<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L337">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L339" title="All 2 branches covered.">        if (!isReady()) {</span>
<span class="fc" id="L340">            throw new NotReadyException();</span>
        }

        try {
<span class="fc" id="L344">            locked = true;</span>
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L346">                listener.onEstimateStart(this);</span>
            }

<span class="pc bpc" id="L349" title="1 of 2 branches missed.">            if (principalPointAtOrigin) {</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">                if (zeroSkewness) {</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">                    if (focalDistanceAspectRatioKnown) {</span>
<span class="fc" id="L352">                        estimateZeroSkewnessPrincipalPointAtOriginAndKnownFocalDistanceAspectRatio(result);</span>
                    } else {
<span class="nc" id="L354">                        estimateZeroSkewnessAndPrincipalPointAtOrigin(result);</span>
                    }
                } else {
<span class="nc" id="L357">                    estimatePrincipalPointAtOrigin(result);</span>
                }
            }

<span class="pc bpc" id="L361" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L362">                listener.onEstimateEnd(this);</span>
            }
        } finally {
<span class="fc" id="L365">            locked = false;</span>
        }
<span class="fc" id="L367">    }</span>

    /**
     * Returns type of Dual Absolute Quadric estimator.
     *
     * @return type of DAQ estimator.
     */
    @Override
    public DualAbsoluteQuadricEstimatorType getType() {
<span class="fc" id="L376">        return DualAbsoluteQuadricEstimatorType.WEIGHTED_DUAL_ABSOLUTE_QUADRIC_ESTIMATOR;</span>
    }

    /**
     * Indicates whether current constraints are enough to start the estimation.
     * In order to obtain a linear solution for the DAQ estimation, we need at
     * least the principal point at origin constraint.
     *
     * @return true if constraints are valid, false otherwise.
     */
    @Override
    public boolean areValidConstraints() {
<span class="fc bfc" id="L388" title="All 6 branches covered.">        return super.areValidConstraints() &amp;&amp; isZeroSkewness() &amp;&amp; isFocalDistanceAspectRatioKnown();</span>
    }

    /**
     * Estimates Dual Absolute Quadric (DAQ) assuming that skewness is zero,
     * principal point is located at origin of coordinates and that aspect ratio
     * of focal distances is known.
     *
     * @param result instance where resulting estimated Dual Absolute Quadric
     *               will be stored.
     * @throws DualAbsoluteQuadricEstimatorException if an error occurs during
     *                                               estimation, usually because repeated cameras are
     *                                               provided, or cameras corresponding to critical motion
     *                                               sequences such as pure parallel translations are
     *                                               provided, where no additional data is really provided.
     */
    private void estimateZeroSkewnessPrincipalPointAtOriginAndKnownFocalDistanceAspectRatio(
            final DualAbsoluteQuadric result) throws DualAbsoluteQuadricEstimatorException {

        try {
<span class="fc" id="L408">            final var nCams = Math.min(cameras.size(), maxCameras);</span>

<span class="fc" id="L410">            final var selection = WeightSelection.selectWeights(weights, sortWeights, nCams);</span>
<span class="fc" id="L411">            final var selected = selection.getSelected();</span>

<span class="fc" id="L413">            final var a = new Matrix(BaseQuadric.N_PARAMS, BaseQuadric.N_PARAMS);</span>
<span class="fc" id="L414">            final var row = new Matrix(4, BaseQuadric.N_PARAMS);</span>
<span class="fc" id="L415">            final var transRow = new Matrix(BaseQuadric.N_PARAMS, 4);</span>
<span class="fc" id="L416">            final var tmp = new Matrix(BaseQuadric.N_PARAMS, BaseQuadric.N_PARAMS);</span>

            Matrix cameraMatrix;
            double p11;
            double p12;
            double p13;
            double p14;
            double p21;
            double p22;
            double p23;
            double p24;
            double p31;
            double p32;
            double p33;
            double p34;
            int eqCounter;
<span class="fc" id="L432">            var cameraCounter = 0;</span>
            double weight;
<span class="fc" id="L434">            var previousNorm = 1.0;</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">            for (final var camera : cameras) {</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">                if (selected[cameraCounter]) {</span>
<span class="fc" id="L437">                    eqCounter = 0;</span>

                    // normalize cameras to increase accuracy
<span class="fc" id="L440">                    camera.normalize();</span>

<span class="fc" id="L442">                    cameraMatrix = camera.getInternalMatrix();</span>

<span class="fc" id="L444">                    p11 = cameraMatrix.getElementAt(0, 0);</span>
<span class="fc" id="L445">                    p21 = cameraMatrix.getElementAt(1, 0);</span>
<span class="fc" id="L446">                    p31 = cameraMatrix.getElementAt(2, 0);</span>

<span class="fc" id="L448">                    p12 = cameraMatrix.getElementAt(0, 1);</span>
<span class="fc" id="L449">                    p22 = cameraMatrix.getElementAt(1, 1);</span>
<span class="fc" id="L450">                    p32 = cameraMatrix.getElementAt(2, 1);</span>

<span class="fc" id="L452">                    p13 = cameraMatrix.getElementAt(0, 2);</span>
<span class="fc" id="L453">                    p23 = cameraMatrix.getElementAt(1, 2);</span>
<span class="fc" id="L454">                    p33 = cameraMatrix.getElementAt(2, 2);</span>

<span class="fc" id="L456">                    p14 = cameraMatrix.getElementAt(0, 3);</span>
<span class="fc" id="L457">                    p24 = cameraMatrix.getElementAt(1, 3);</span>
<span class="fc" id="L458">                    p34 = cameraMatrix.getElementAt(2, 3);</span>

<span class="fc" id="L460">                    weight = weights[cameraCounter];</span>

                    // 1st row
<span class="fc" id="L463">                    fill2ndRowAnd1stRowEquation(p11, p21, p12, p22, p13, p23, p14, p24, row, eqCounter);</span>
<span class="fc" id="L464">                    applyWeight(row, eqCounter, weight);</span>
<span class="fc" id="L465">                    eqCounter++;</span>

                    // 2nd row
<span class="fc" id="L468">                    fill3rdRowAnd1stRowEquation(p11, p31, p12, p32, p13, p33, p14, p34, row, eqCounter);</span>
<span class="fc" id="L469">                    applyWeight(row, eqCounter, weight);</span>
<span class="fc" id="L470">                    eqCounter++;</span>

                    // 3rd row
<span class="fc" id="L473">                    fill3rdRowAnd2ndRowEquation(p21, p31, p22, p32, p23, p33, p24, p34, row, eqCounter);</span>
<span class="fc" id="L474">                    applyWeight(row, eqCounter, weight);</span>
<span class="fc" id="L475">                    eqCounter++;</span>

                    // 4th row
<span class="fc" id="L478">                    fill1stRowEqualTo2ndRowEquation(p11, p21, p12, p22, p13, p23, p14, p24, row, eqCounter);</span>
<span class="fc" id="L479">                    applyWeight(row, eqCounter, weight);</span>

                    // transRow = row'
<span class="fc" id="L482">                    row.transpose(transRow);</span>
<span class="fc" id="L483">                    transRow.multiply(row, tmp);</span>

<span class="fc" id="L485">                    tmp.multiplyByScalar(1.0 / previousNorm);</span>

                    // a += 1.0 / previousNorm * tmp
<span class="fc" id="L488">                    a.add(tmp);</span>
                    // normalize
<span class="fc" id="L490">                    previousNorm = Utils.normF(a);</span>
<span class="fc" id="L491">                    a.multiplyByScalar(1.0 / previousNorm);</span>
                }

<span class="fc" id="L494">                cameraCounter++;</span>
<span class="fc" id="L495">            }</span>

<span class="fc" id="L497">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L498">            enforceRank3IfNeeded(decomposer, result);</span>

<span class="nc" id="L500">        } catch (final AlgebraException | SortingException | NumericalException e) {</span>
<span class="nc" id="L501">            throw new DualAbsoluteQuadricEstimatorException(e);</span>
<span class="fc" id="L502">        }</span>
<span class="fc" id="L503">    }</span>

    /**
     * Estimates Dual Absolute Quadric (DAQ) assuming that skewness is zero,
     * and principal point is located at origin of coordinates.
     *
     * @param result instance where resulting estimated Dual Absolute Quadrics
     *               will be stored.
     * @throws DualAbsoluteQuadricEstimatorException if an error occurs during
     *                                               estimation, usually because repeated cameras are
     *                                               provided, or cameras corresponding to critical motion
     *                                               sequences such as pure parallel translations are
     *                                               provided, where no additional data is really provided.
     */
    private void estimateZeroSkewnessAndPrincipalPointAtOrigin(final DualAbsoluteQuadric result)
            throws DualAbsoluteQuadricEstimatorException {

        try {
<span class="nc" id="L521">            final var nCams = Math.min(cameras.size(), maxCameras);</span>

<span class="nc" id="L523">            final var selection = WeightSelection.selectWeights(weights, sortWeights, nCams);</span>
<span class="nc" id="L524">            final var selected = selection.getSelected();</span>

<span class="nc" id="L526">            final var a = new Matrix(BaseQuadric.N_PARAMS, BaseQuadric.N_PARAMS);</span>
<span class="nc" id="L527">            final var row = new Matrix(3, BaseQuadric.N_PARAMS);</span>
<span class="nc" id="L528">            final var transRow = new Matrix(BaseQuadric.N_PARAMS, 3);</span>
<span class="nc" id="L529">            final var tmp = new Matrix(BaseQuadric.N_PARAMS, BaseQuadric.N_PARAMS);</span>

            Matrix cameraMatrix;
            double p11;
            double p12;
            double p13;
            double p14;
            double p21;
            double p22;
            double p23;
            double p24;
            double p31;
            double p32;
            double p33;
            double p34;
            int eqCounter;
<span class="nc" id="L545">            var cameraCounter = 0;</span>
            double weight;
<span class="nc" id="L547">            var previousNorm = 1.0;</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">            for (final var camera : cameras) {</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">                if (selected[cameraCounter]) {</span>
<span class="nc" id="L550">                    eqCounter = 0;</span>

                    // normalize cameras to increase accuracy
<span class="nc" id="L553">                    camera.normalize();</span>

<span class="nc" id="L555">                    cameraMatrix = camera.getInternalMatrix();</span>

<span class="nc" id="L557">                    p11 = cameraMatrix.getElementAt(0, 0);</span>
<span class="nc" id="L558">                    p21 = cameraMatrix.getElementAt(1, 0);</span>
<span class="nc" id="L559">                    p31 = cameraMatrix.getElementAt(2, 0);</span>

<span class="nc" id="L561">                    p12 = cameraMatrix.getElementAt(0, 1);</span>
<span class="nc" id="L562">                    p22 = cameraMatrix.getElementAt(1, 1);</span>
<span class="nc" id="L563">                    p32 = cameraMatrix.getElementAt(2, 1);</span>

<span class="nc" id="L565">                    p13 = cameraMatrix.getElementAt(0, 2);</span>
<span class="nc" id="L566">                    p23 = cameraMatrix.getElementAt(1, 2);</span>
<span class="nc" id="L567">                    p33 = cameraMatrix.getElementAt(2, 2);</span>

<span class="nc" id="L569">                    p14 = cameraMatrix.getElementAt(0, 3);</span>
<span class="nc" id="L570">                    p24 = cameraMatrix.getElementAt(1, 3);</span>
<span class="nc" id="L571">                    p34 = cameraMatrix.getElementAt(2, 3);</span>

<span class="nc" id="L573">                    weight = weights[cameraCounter];</span>

                    // 1st row
<span class="nc" id="L576">                    fill2ndRowAnd1stRowEquation(p11, p21, p12, p22, p13, p23, p14, p24, a, eqCounter);</span>
<span class="nc" id="L577">                    applyWeight(row, eqCounter, weight);</span>
<span class="nc" id="L578">                    eqCounter++;</span>

                    // 2nd row
<span class="nc" id="L581">                    fill3rdRowAnd1stRowEquation(p11, p31, p12, p32, p13, p33, p14, p34, a, eqCounter);</span>
<span class="nc" id="L582">                    applyWeight(row, eqCounter, weight);</span>
<span class="nc" id="L583">                    eqCounter++;</span>

                    // 3rd row
<span class="nc" id="L586">                    fill3rdRowAnd2ndRowEquation(p21, p31, p22, p32, p23, p33, p24, p34, a, eqCounter);</span>
<span class="nc" id="L587">                    applyWeight(row, eqCounter, weight);</span>

                    // transRow = row'
<span class="nc" id="L590">                    row.transpose(transRow);</span>
<span class="nc" id="L591">                    transRow.multiply(row, tmp);</span>

<span class="nc" id="L593">                    tmp.multiplyByScalar(1.0 / previousNorm);</span>

                    // a += 1.0 / previousNorm * tmp
<span class="nc" id="L596">                    a.add(tmp);</span>
                    // normalize
<span class="nc" id="L598">                    previousNorm = Utils.normF(a);</span>
<span class="nc" id="L599">                    a.multiplyByScalar(1.0 / previousNorm);</span>
                }

<span class="nc" id="L602">                cameraCounter++;</span>
<span class="nc" id="L603">            }</span>

<span class="nc" id="L605">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="nc" id="L606">            enforceRank3IfNeeded(decomposer, result);</span>

<span class="nc" id="L608">        } catch (final AlgebraException | SortingException | NumericalException e) {</span>
<span class="nc" id="L609">            throw new DualAbsoluteQuadricEstimatorException(e);</span>
<span class="nc" id="L610">        }</span>
<span class="nc" id="L611">    }</span>

    /**
     * Estimates Dual Absolute Quadric (DAQ) assuming that principal point is
     * zero.
     *
     * @param result instance where resulting estimated Dual Absolute Quadrics
     *               will be stored.
     * @throws DualAbsoluteQuadricEstimatorException if an error occurs during
     *                                               estimation, usually because repeated cameras are
     *                                               provided, or cameras corresponding to critical motion
     *                                               sequences such as pure parallel translations are
     *                                               provided, where no additional data is really provided.
     */
    private void estimatePrincipalPointAtOrigin(DualAbsoluteQuadric result)
            throws DualAbsoluteQuadricEstimatorException {

        try {
<span class="nc" id="L629">            final var nCams = Math.min(cameras.size(), maxCameras);</span>

<span class="nc" id="L631">            final var selection = WeightSelection.selectWeights(weights, sortWeights, nCams);</span>
<span class="nc" id="L632">            final var selected = selection.getSelected();</span>

<span class="nc" id="L634">            final var a = new Matrix(BaseQuadric.N_PARAMS, BaseQuadric.N_PARAMS);</span>
<span class="nc" id="L635">            final var row = new Matrix(2, BaseQuadric.N_PARAMS);</span>
<span class="nc" id="L636">            final var transRow = new Matrix(BaseQuadric.N_PARAMS, 2);</span>
<span class="nc" id="L637">            final var tmp = new Matrix(BaseQuadric.N_PARAMS, BaseQuadric.N_PARAMS);</span>

            Matrix cameraMatrix;
            double p11;
            double p12;
            double p13;
            double p14;
            double p21;
            double p22;
            double p23;
            double p24;
            double p31;
            double p32;
            double p33;
            double p34;
            int eqCounter;
<span class="nc" id="L653">            var cameraCounter = 0;</span>
            double weight;
<span class="nc" id="L655">            var previousNorm = 1.0;</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">            for (final var camera : cameras) {</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">                if (selected[cameraCounter]) {</span>
<span class="nc" id="L658">                    eqCounter = 0;</span>

                    // normalize cameras to increase accuracy
<span class="nc" id="L661">                    camera.normalize();</span>

<span class="nc" id="L663">                    cameraMatrix = camera.getInternalMatrix();</span>

<span class="nc" id="L665">                    p11 = cameraMatrix.getElementAt(0, 0);</span>
<span class="nc" id="L666">                    p21 = cameraMatrix.getElementAt(1, 0);</span>
<span class="nc" id="L667">                    p31 = cameraMatrix.getElementAt(2, 0);</span>

<span class="nc" id="L669">                    p12 = cameraMatrix.getElementAt(0, 1);</span>
<span class="nc" id="L670">                    p22 = cameraMatrix.getElementAt(1, 1);</span>
<span class="nc" id="L671">                    p32 = cameraMatrix.getElementAt(2, 1);</span>

<span class="nc" id="L673">                    p13 = cameraMatrix.getElementAt(0, 2);</span>
<span class="nc" id="L674">                    p23 = cameraMatrix.getElementAt(1, 2);</span>
<span class="nc" id="L675">                    p33 = cameraMatrix.getElementAt(2, 2);</span>

<span class="nc" id="L677">                    p14 = cameraMatrix.getElementAt(0, 3);</span>
<span class="nc" id="L678">                    p24 = cameraMatrix.getElementAt(1, 3);</span>
<span class="nc" id="L679">                    p34 = cameraMatrix.getElementAt(2, 3);</span>

<span class="nc" id="L681">                    weight = weights[cameraCounter];</span>

                    // 1st row
<span class="nc" id="L684">                    fill3rdRowAnd1stRowEquation(p11, p31, p12, p32, p13, p33, p14, p34, a, eqCounter);</span>
<span class="nc" id="L685">                    applyWeight(row, eqCounter, weight);</span>
<span class="nc" id="L686">                    eqCounter++;</span>

                    // 2nd row
<span class="nc" id="L689">                    fill3rdRowAnd2ndRowEquation(p21, p31, p22, p32, p23, p33, p24, p34, a, eqCounter);</span>
<span class="nc" id="L690">                    applyWeight(row, eqCounter, weight);</span>

                    // transRow = row'
<span class="nc" id="L693">                    row.transpose(transRow);</span>
<span class="nc" id="L694">                    transRow.multiply(row, tmp);</span>

<span class="nc" id="L696">                    tmp.multiplyByScalar(1.0 / previousNorm);</span>

                    // a += 1.0 / previousNorm * tmp
<span class="nc" id="L699">                    a.add(tmp);</span>
                    // normalize
<span class="nc" id="L701">                    previousNorm = Utils.normF(a);</span>
<span class="nc" id="L702">                    a.multiplyByScalar(1.0 / previousNorm);</span>
                }

<span class="nc" id="L705">                cameraCounter++;</span>
<span class="nc" id="L706">            }</span>

<span class="nc" id="L708">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="nc" id="L709">            enforceRank3IfNeeded(decomposer, result);</span>

<span class="nc" id="L711">        } catch (final AlgebraException | SortingException | NumericalException e) {</span>
<span class="nc" id="L712">            throw new DualAbsoluteQuadricEstimatorException(e);</span>
<span class="nc" id="L713">        }</span>
<span class="nc" id="L714">    }</span>

    /**
     * Apply provided weight to matrix at provided row.
     *
     * @param a      matrix to apply weight to.
     * @param row    row within matrix to apply weight.
     * @param weight weight to be applied.
     */
    private void applyWeight(final Matrix a, final int row, final double weight) {
<span class="fc" id="L724">        final var cols = a.getColumns();</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">        for (var i = 0; i &lt; cols; i++) {</span>
<span class="fc" id="L726">            a.setElementAt(row, i, a.getElementAt(row, i) * weight);</span>
        }
<span class="fc" id="L728">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>