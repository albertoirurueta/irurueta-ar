<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WeightedImageOfAbsoluteConicEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.calibration.estimators</a> &gt; <span class="el_source">WeightedImageOfAbsoluteConicEstimator.java</span></div><h1>WeightedImageOfAbsoluteConicEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2015 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.calibration.estimators;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.SingularValueDecomposer;
import com.irurueta.ar.calibration.ImageOfAbsoluteConic;
import com.irurueta.geometry.ProjectiveTransformation2D;
import com.irurueta.geometry.Transformation2D;
import com.irurueta.geometry.estimators.LockedException;
import com.irurueta.geometry.estimators.NotReadyException;
import com.irurueta.numerical.robust.WeightSelection;
import com.irurueta.sorting.SortingException;

import java.util.List;

/**
 * This class implements an Image of Absolute Conic (IAC) estimator using a
 * weighted algorithm and correspondences.
 * Weights can be used so that homographies assumed to have a better quality
 * (i.e. more precisely estimated) are considered to be more relevant.
 * Aside from enabling constraints whenever possible to obtain more stable and
 * accurate results, its is discouraged to use a large number of homographies,
 * even if they are correctly weighted, since as the number of homographies
 * increase so do the rounding errors.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class WeightedImageOfAbsoluteConicEstimator extends ImageOfAbsoluteConicEstimator {

    /**
     * Default number of homographies to be weighted and taken into account.
     */
    public static final int DEFAULT_MAX_HOMOGRAPHIES = 50;

    /**
     * Indicates if weights are sorted by default so that largest weighted
     * correspondences are used first.
     */
    public static final boolean DEFAULT_SORT_WEIGHTS = true;

    /**
     * Maximum number of homographies (i.e. correspondences) to be weighted and
     * taken into account.
     */
    private int maxHomographies;

    /**
     * Indicates if weights are sorted by default so that largest weighted
     * correspondences are used first.
     */
    private boolean sortWeights;

    /**
     * Array containing weights for all homographies.
     */
    private double[] weights;

    /**
     * Constructor.
     */
    public WeightedImageOfAbsoluteConicEstimator() {
<span class="fc" id="L76">        super();</span>
<span class="fc" id="L77">        maxHomographies = DEFAULT_MAX_HOMOGRAPHIES;</span>
<span class="fc" id="L78">        sortWeights = DEFAULT_SORT_WEIGHTS;</span>
<span class="fc" id="L79">    }</span>

    /**
     * Constructor with listener.
     *
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     */
    public WeightedImageOfAbsoluteConicEstimator(final ImageOfAbsoluteConicEstimatorListener listener) {
<span class="fc" id="L88">        super(listener);</span>
<span class="fc" id="L89">        maxHomographies = DEFAULT_MAX_HOMOGRAPHIES;</span>
<span class="fc" id="L90">        sortWeights = DEFAULT_SORT_WEIGHTS;</span>
<span class="fc" id="L91">    }</span>

    /**
     * Constructor.
     *
     * @param homographies list of homographies (2D transformations) used to
     *                     estimate the image of absolute conic (IAC), which can be used to obtain
     *                     pinhole camera intrinsic parameters.
     * @param weights      array containing a weight amount for each homography.
     *                     The larger the value of a weight, the most significant the correspondence
     *                     will be.
     * @throws IllegalArgumentException if not enough homographies are provided
     *                                  for default constraints during IAC estimation.
     */
    public WeightedImageOfAbsoluteConicEstimator(final List&lt;Transformation2D&gt; homographies, final double[] weights) {
<span class="fc" id="L106">        super();</span>
<span class="fc" id="L107">        internalSetHomographiesAndWeights(homographies, weights);</span>
<span class="fc" id="L108">        maxHomographies = DEFAULT_MAX_HOMOGRAPHIES;</span>
<span class="fc" id="L109">        sortWeights = DEFAULT_SORT_WEIGHTS;</span>
<span class="fc" id="L110">    }</span>

    /**
     * Constructor.
     *
     * @param homographies list of homographies (2D transformations) used to
     *                     estimate the image of absolute conic (IAC), which can be used to obtain
     *                     pinhole camera intrinsic parameters.
     * @param weights      array containing a weight amount for each homography.
     *                     The larger the value of a weight, the most significant the correspondence
     *                     will be.
     * @param listener     listener to be notified of events such as when estimation
     *                     starts, ends or estimation progress changes.
     * @throws IllegalArgumentException if not enough homographies are provided
     *                                  for default constraints during IAC estimation.
     */
    public WeightedImageOfAbsoluteConicEstimator(final List&lt;Transformation2D&gt; homographies, final double[] weights,
                                                 final ImageOfAbsoluteConicEstimatorListener listener) {
<span class="fc" id="L128">        super(listener);</span>
<span class="fc" id="L129">        internalSetHomographiesAndWeights(homographies, weights);</span>
<span class="fc" id="L130">        maxHomographies = DEFAULT_MAX_HOMOGRAPHIES;</span>
<span class="fc" id="L131">        sortWeights = DEFAULT_SORT_WEIGHTS;</span>
<span class="fc" id="L132">    }</span>

    /**
     * Sets list of homographies to estimate IAC.
     * This method override always throws an IllegalArgumentException because
     * it is expected to provide both homographies and their weights.
     *
     * @param homographies list of homographies to estimate IAC.
     * @throws IllegalArgumentException always thrown in this implementation.
     */
    @Override
    public void setHomographies(final List&lt;Transformation2D&gt; homographies) {
<span class="fc" id="L144">        throw new IllegalArgumentException();</span>
    }

    /**
     * Sets list of homographies to estimate IAC along with their corresponding
     * weights.
     *
     * @param homographies list of homographies to estimate IAC.
     * @param weights      array containing a weight amount for each homography.
     *                     The larger the value of a weight, the most significant the correspondence
     *                     will be.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if not enough homographies are provided
     *                                  for default constraints during IAC estimation.
     */
    public void setHomographiesAndWeights(
            final List&lt;Transformation2D&gt; homographies, final double[] weights) throws LockedException {
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L162">            throw new LockedException();</span>
        }
<span class="fc" id="L164">        internalSetHomographiesAndWeights(homographies, weights);</span>
<span class="fc" id="L165">    }</span>

    /**
     * Returns array containing a weight amount for each homography.
     * The larger the value of a weight, the most significant the correspondence
     * will be.
     *
     * @return array containing weights for each correspondence.
     */
    public double[] getWeights() {
<span class="fc" id="L175">        return weights;</span>
    }

    /**
     * Returns boolean indicating whether weights have been provided and are
     * available for retrieval.
     *
     * @return true if weights are available, false otherwise.
     */
    public boolean areWeightsAvailable() {
<span class="fc bfc" id="L185" title="All 2 branches covered.">        return weights != null;</span>
    }

    /**
     * Returns maximum number of homographies to be weighted and taken into
     * account.
     *
     * @return maximum number of homographies to be weighted.
     */
    public int getMaxHomographies() {
<span class="fc" id="L195">        return maxHomographies;</span>
    }

    /**
     * Sets maximum number of homographies to be weighted and taken into
     * account.
     * This method must be called after enforcing constraints, because the
     * minimum number of required homographies will be checked based on current
     * settings.
     *
     * @param maxHomographies maximum number of homographies to be weighted.
     * @throws IllegalArgumentException if provided value is less than the
     *                                  minimum allowed number of homographies.
     * @throws LockedException          if this instance is locked.
     */
    public void setMaxHomographies(final int maxHomographies) throws LockedException {
<span class="fc bfc" id="L211" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L212">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (maxHomographies &lt; getMinNumberOfRequiredHomographies()) {</span>
<span class="fc" id="L215">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L218">        this.maxHomographies = maxHomographies;</span>
<span class="fc" id="L219">    }</span>

    /**
     * Indicates if weights are sorted by so that largest weighted homographies
     * are used first.
     *
     * @return true if weights are sorted, false otherwise.
     */
    public boolean isSortWeightsEnabled() {
<span class="fc" id="L228">        return sortWeights;</span>
    }

    /**
     * Specifies whether weights are sorted by so that largest weighted
     * homographies are used first.
     *
     * @param sortWeights true if weights are sorted, false otherwise.
     * @throws LockedException if this instance is locked.
     */
    public void setSortWeightsEnabled(final boolean sortWeights) throws LockedException {
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L240">            throw new LockedException();</span>
        }

<span class="fc" id="L243">        this.sortWeights = sortWeights;</span>
<span class="fc" id="L244">    }</span>

    /**
     * Indicates if this estimator is ready to start the estimation.
     * Estimator will be ready once both list of homographies and weights are
     * available and enough homobraphies have been provided
     *
     * @return true if estimator is ready, false otherwise.
     */
    @Override
    public boolean isReady() {
<span class="pc bpc" id="L255" title="2 of 6 branches missed.">        return super.isReady() &amp;&amp; areWeightsAvailable() &amp;&amp; homographies.size() == weights.length;</span>
    }

    /**
     * Estimates Image of Absolute Conic (IAC).
     *
     * @return estimated IAC.
     * @throws LockedException                        if estimator is locked.
     * @throws NotReadyException                      if input has not yet been provided.
     * @throws ImageOfAbsoluteConicEstimatorException if an error occurs during
     *                                                estimation, usually because repeated homographies are
     *                                                provided, or homographies corresponding to degenerate
     *                                                camera movements such as pure parallel translations
     *                                                where no additional data is really provided. Indeed,
     *                                                if provided homographies belong to the group of affine
     *                                                transformations (or other groups contained within such
     *                                                as metric or Euclidean ones), this exception will
     *                                                raise because camera movements will be degenerate. To
     *                                                avoid this exception, homographies must be purely
     *                                                projective.
     */
    @Override
    public ImageOfAbsoluteConic estimate() throws LockedException, NotReadyException,
            ImageOfAbsoluteConicEstimatorException {
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L280">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L283">            throw new NotReadyException();</span>
        }

        try {
<span class="fc" id="L287">            locked = true;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L289">                listener.onEstimateStart(this);</span>
            }

            final ImageOfAbsoluteConic iac;
<span class="fc bfc" id="L293" title="All 4 branches covered.">            if (zeroSkewness &amp;&amp; principalPointAtOrigin) {</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">                if (focalDistanceAspectRatioKnown) {</span>
<span class="fc" id="L295">                    iac = estimateZeroSkewnessPrincipalPointAtOriginAndKnownFocalDistanceAspectRatio();</span>
                } else {
<span class="fc" id="L297">                    iac = estimateZeroSkewnessAndPrincipalPointAtOrigin();</span>
                }
<span class="fc bfc" id="L299" title="All 2 branches covered.">            } else if (zeroSkewness) { //&amp;&amp; !mPrincipalPointAtOrigin</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">                if (focalDistanceAspectRatioKnown) {</span>
<span class="fc" id="L301">                    iac = estimateZeroSkewnessAndKnownFocalDistanceAspectRatio();</span>
                } else {
<span class="fc" id="L303">                    iac = estimateZeroSkewness();</span>
                }
<span class="fc bfc" id="L305" title="All 2 branches covered.">            } else if (principalPointAtOrigin) { //&amp;&amp; !mZeroSkewness</span>
<span class="fc" id="L306">                iac = estimatePrincipalPointAtOrigin();</span>
            } else {
<span class="fc" id="L308">                iac = estimateNoConstraints();</span>
            }

<span class="fc bfc" id="L311" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L312">                listener.onEstimateEnd(this);</span>
            }

<span class="fc" id="L315">            return iac;</span>
        } finally {
<span class="fc" id="L317">            locked = false;</span>
        }
    }

    /**
     * Returns type of IAC estimator.
     *
     * @return type of IAC estimator.
     */
    @Override
    public ImageOfAbsoluteConicEstimatorType getType() {
<span class="fc" id="L328">        return ImageOfAbsoluteConicEstimatorType.WEIGHTED_IAC_ESTIMATOR;</span>
    }

    /**
     * Sets list of homographies to estimate IAC.
     * This method does not check whether estimator is locked.
     *
     * @param homographies list of homographies to estimate IAC.
     * @param weights      array containing a weight amount for each homography.
     *                     The larger the value of a weight, the more significant the correspondence
     *                     will be.
     * @throws IllegalArgumentException if provided list of homographies does not
     *                                  contain enough elements to estimate the IAC using current settings.
     */
    private void internalSetHomographiesAndWeights(final List&lt;Transformation2D&gt; homographies, double[] weights) {
<span class="pc bpc" id="L343" title="1 of 6 branches missed.">        if (weights == null || homographies == null || weights.length != homographies.size()) {</span>
<span class="fc" id="L344">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L346">        internalSetHomographies(homographies);</span>
<span class="fc" id="L347">        this.weights = weights;</span>
<span class="fc" id="L348">    }</span>

    /**
     * Estimates Image of Absolute Conic (IAC) without constraints.
     *
     * @return estimated IAC.
     * @throws ImageOfAbsoluteConicEstimatorException if an error occurs during
     *                                                estimation, usually because repeated homographies
     *                                                are provided, or homographies corresponding to
     *                                                degenerate camera movements such as pure parallel
     *                                                translations where no additional data is really
     *                                                provided.
     */
    private ImageOfAbsoluteConic estimateNoConstraints() throws ImageOfAbsoluteConicEstimatorException {

        try {
<span class="fc" id="L364">            final var selection = WeightSelection.selectWeights(weights, sortWeights, maxHomographies);</span>
<span class="fc" id="L365">            final var selected = selection.getSelected();</span>
<span class="fc" id="L366">            final var nHomographies = selection.getNumSelected();</span>

<span class="fc" id="L368">            final var a = new Matrix(2 * nHomographies, 6);</span>

<span class="fc" id="L370">            var index = 0;</span>
<span class="fc" id="L371">            var counter = 0;</span>
<span class="fc" id="L372">            ProjectiveTransformation2D t = null;</span>
<span class="fc" id="L373">            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);</span>
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            double weight;
            double factor;
<span class="fc bfc" id="L384" title="All 2 branches covered.">            for (final var homography : homographies) {</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">                if (selected[index]) {</span>
<span class="fc" id="L386">                    weight = weights[index];</span>

                    // convert homography into projective so it can be normalized
<span class="fc" id="L389">                    homography.asMatrix(h);</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">                    if (t == null) {</span>
<span class="fc" id="L391">                        t = new ProjectiveTransformation2D(h);</span>
                    } else {
<span class="fc" id="L393">                        t.setT(h);</span>
                    }

                    // normalize
<span class="fc" id="L397">                    t.normalize();</span>

                    // obtain elements of projective transformation matrix
                    // there is no need to retrieve internal matrix h, as we already
                    // hold a reference
<span class="fc" id="L402">                    h11 = h.getElementAt(0, 0);</span>
<span class="fc" id="L403">                    h12 = h.getElementAt(0, 1);</span>

<span class="fc" id="L405">                    h21 = h.getElementAt(1, 0);</span>
<span class="fc" id="L406">                    h22 = h.getElementAt(1, 1);</span>

<span class="fc" id="L408">                    h31 = h.getElementAt(2, 0);</span>
<span class="fc" id="L409">                    h32 = h.getElementAt(2, 1);</span>

                    // fill first equation
<span class="fc" id="L412">                    a.setElementAt(counter, 0, h11 * h12);</span>
<span class="fc" id="L413">                    a.setElementAt(counter, 1, h11 * h22 + h21 * h12);</span>
<span class="fc" id="L414">                    a.setElementAt(counter, 2, h21 * h22);</span>
<span class="fc" id="L415">                    a.setElementAt(counter, 3, h11 * h32 + h31 * h12);</span>
<span class="fc" id="L416">                    a.setElementAt(counter, 4, h21 * h32 + h31 * h22);</span>
<span class="fc" id="L417">                    a.setElementAt(counter, 5, h31 * h32);</span>

                    // normalize row
<span class="fc" id="L420">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L421">                            + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L422">                            + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L423">                            + Math.pow(a.getElementAt(counter, 3), 2.0)</span>
<span class="fc" id="L424">                            + Math.pow(a.getElementAt(counter, 4), 2.0)</span>
<span class="fc" id="L425">                            + Math.pow(a.getElementAt(counter, 5), 2.0));</span>
<span class="fc" id="L426">                    factor = weight / rowNorm;</span>

<span class="fc" id="L428">                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);</span>
<span class="fc" id="L429">                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);</span>
<span class="fc" id="L430">                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);</span>
<span class="fc" id="L431">                    a.setElementAt(counter, 3, a.getElementAt(counter, 3) * factor);</span>
<span class="fc" id="L432">                    a.setElementAt(counter, 4, a.getElementAt(counter, 4) * factor);</span>
<span class="fc" id="L433">                    a.setElementAt(counter, 5, a.getElementAt(counter, 5) * factor);</span>

<span class="fc" id="L435">                    counter++;</span>

                    // fill second equation
<span class="fc" id="L438">                    a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0));</span>
<span class="fc" id="L439">                    a.setElementAt(counter, 1, 2.0 * (h11 * h21 - h12 * h22));</span>
<span class="fc" id="L440">                    a.setElementAt(counter, 2, Math.pow(h21, 2.0) - Math.pow(h22, 2.0));</span>
<span class="fc" id="L441">                    a.setElementAt(counter, 3, 2.0 * (h11 * h31 - h12 * h32));</span>
<span class="fc" id="L442">                    a.setElementAt(counter, 4, 2.0 * (h21 * h31 - h22 * h32));</span>
<span class="fc" id="L443">                    a.setElementAt(counter, 5, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));</span>

                    // normalize row
<span class="fc" id="L446">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L447">                            + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L448">                            + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L449">                            + Math.pow(a.getElementAt(counter, 3), 2.0)</span>
<span class="fc" id="L450">                            + Math.pow(a.getElementAt(counter, 4), 2.0)</span>
<span class="fc" id="L451">                            + Math.pow(a.getElementAt(counter, 5), 2.0));</span>
<span class="fc" id="L452">                    factor = weight / rowNorm;</span>

<span class="fc" id="L454">                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);</span>
<span class="fc" id="L455">                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);</span>
<span class="fc" id="L456">                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);</span>
<span class="fc" id="L457">                    a.setElementAt(counter, 3, a.getElementAt(counter, 3) * factor);</span>
<span class="fc" id="L458">                    a.setElementAt(counter, 4, a.getElementAt(counter, 4) * factor);</span>
<span class="fc" id="L459">                    a.setElementAt(counter, 5, a.getElementAt(counter, 5) * factor);</span>

<span class="fc" id="L461">                    counter++;</span>
                }

<span class="fc" id="L464">                index++;</span>
<span class="fc" id="L465">            }</span>

<span class="fc" id="L467">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L468">            decomposer.decompose();</span>

<span class="pc bpc" id="L470" title="1 of 2 branches missed.">            if (decomposer.getNullity() &gt; 1) {</span>
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
<span class="nc" id="L474">                throw new ImageOfAbsoluteConicEstimatorException();</span>
            }

<span class="fc" id="L477">            final var v = decomposer.getV();</span>

            // use last column of V as IAC vector

            // the last column of V contains IAC matrix (B), which is symmetric
            // and positive definite, ordered as follows: B11, B12, B22, B13,
            // B23, B33
<span class="fc" id="L484">            final var b11 = v.getElementAt(0, 5);</span>
<span class="fc" id="L485">            final var b12 = v.getElementAt(1, 5);</span>
<span class="fc" id="L486">            final var b22 = v.getElementAt(2, 5);</span>
<span class="fc" id="L487">            final var b13 = v.getElementAt(3, 5);</span>
<span class="fc" id="L488">            final var b23 = v.getElementAt(4, 5);</span>
<span class="fc" id="L489">            final var b33 = v.getElementAt(5, 5);</span>

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
<span class="fc" id="L494">            return new ImageOfAbsoluteConic(b11, b12, b22, b13, b23, b33);</span>
<span class="nc" id="L495">        } catch (final AlgebraException | SortingException e) {</span>
<span class="nc" id="L496">            throw new ImageOfAbsoluteConicEstimatorException(e);</span>
        }
    }

    /**
     * Estimates Image of Absolute Conic (IAC) assuming that skewness is zero.
     *
     * @return estimated IAC.
     * @throws ImageOfAbsoluteConicEstimatorException if an error occurs during
     *                                                estimation, usually because repeated homographies
     *                                                are provided, or homographies corresponding to
     *                                                degenerate camera movements such as pure parallel
     *                                                translations where no additional data is really
     *                                                provided.
     */
    private ImageOfAbsoluteConic estimateZeroSkewness() throws ImageOfAbsoluteConicEstimatorException {
        try {
<span class="fc" id="L513">            final var nHomographies = homographies.size();</span>

<span class="fc" id="L515">            final var selection = WeightSelection.selectWeights(weights, sortWeights, maxHomographies);</span>
<span class="fc" id="L516">            final var selected = selection.getSelected();</span>

<span class="fc" id="L518">            final var a = new Matrix(2 * nHomographies, 5);</span>

<span class="fc" id="L520">            var index = 0;</span>
<span class="fc" id="L521">            var counter = 0;</span>
<span class="fc" id="L522">            ProjectiveTransformation2D t = null;</span>
<span class="fc" id="L523">            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);</span>
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            double weight;
            double factor;
<span class="fc bfc" id="L534" title="All 2 branches covered.">            for (final var homography : homographies) {</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">                if (selected[index]) {</span>
<span class="fc" id="L536">                    weight = weights[index];</span>

                    // convert homography into projective so it can be normalized
<span class="fc" id="L539">                    homography.asMatrix(h);</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">                    if (t == null) {</span>
<span class="fc" id="L541">                        t = new ProjectiveTransformation2D(h);</span>
                    } else {
<span class="fc" id="L543">                        t.setT(h);</span>
                    }

                    // normalize
<span class="fc" id="L547">                    t.normalize();</span>

                    // obtain elements of projective transformation matrix
                    // there is no need to retrieve internal matrix h, as we already
                    // hold a reference
<span class="fc" id="L552">                    h11 = h.getElementAt(0, 0);</span>
<span class="fc" id="L553">                    h12 = h.getElementAt(0, 1);</span>

<span class="fc" id="L555">                    h21 = h.getElementAt(1, 0);</span>
<span class="fc" id="L556">                    h22 = h.getElementAt(1, 1);</span>

<span class="fc" id="L558">                    h31 = h.getElementAt(2, 0);</span>
<span class="fc" id="L559">                    h32 = h.getElementAt(2, 1);</span>

                    // fill first equation
<span class="fc" id="L562">                    a.setElementAt(counter, 0, h11 * h12);</span>
<span class="fc" id="L563">                    a.setElementAt(counter, 1, h21 * h22);</span>
<span class="fc" id="L564">                    a.setElementAt(counter, 2, h11 * h32 + h31 * h12);</span>
<span class="fc" id="L565">                    a.setElementAt(counter, 3, h21 * h32 + h31 * h22);</span>
<span class="fc" id="L566">                    a.setElementAt(counter, 4, h31 * h32);</span>

                    // normalize row
<span class="fc" id="L569">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L570">                            + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L571">                            + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L572">                            + Math.pow(a.getElementAt(counter, 3), 2.0)</span>
<span class="fc" id="L573">                            + Math.pow(a.getElementAt(counter, 4), 2.0));</span>
<span class="fc" id="L574">                    factor = weight / rowNorm;</span>

<span class="fc" id="L576">                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);</span>
<span class="fc" id="L577">                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);</span>
<span class="fc" id="L578">                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);</span>
<span class="fc" id="L579">                    a.setElementAt(counter, 3, a.getElementAt(counter, 3) * factor);</span>
<span class="fc" id="L580">                    a.setElementAt(counter, 4, a.getElementAt(counter, 4) * factor);</span>

<span class="fc" id="L582">                    counter++;</span>

                    // fill second equation
<span class="fc" id="L585">                    a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0));</span>
<span class="fc" id="L586">                    a.setElementAt(counter, 1, Math.pow(h21, 2.0) - Math.pow(h22, 2.0));</span>
<span class="fc" id="L587">                    a.setElementAt(counter, 2, 2.0 * (h11 * h31 - h12 * h32));</span>
<span class="fc" id="L588">                    a.setElementAt(counter, 3, 2.0 * (h21 * h31 - h22 * h32));</span>
<span class="fc" id="L589">                    a.setElementAt(counter, 4, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));</span>

                    // normalize row
<span class="fc" id="L592">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L593">                            + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L594">                            + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L595">                            + Math.pow(a.getElementAt(counter, 3), 2.0)</span>
<span class="fc" id="L596">                            + Math.pow(a.getElementAt(counter, 4), 2.0));</span>
<span class="fc" id="L597">                    factor = weight / rowNorm;</span>

<span class="fc" id="L599">                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);</span>
<span class="fc" id="L600">                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);</span>
<span class="fc" id="L601">                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);</span>
<span class="fc" id="L602">                    a.setElementAt(counter, 3, a.getElementAt(counter, 3) * factor);</span>
<span class="fc" id="L603">                    a.setElementAt(counter, 4, a.getElementAt(counter, 4) * factor);</span>

<span class="fc" id="L605">                    counter++;</span>
                }

<span class="fc" id="L608">                index++;</span>
<span class="fc" id="L609">            }</span>

<span class="fc" id="L611">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L612">            decomposer.decompose();</span>

<span class="pc bpc" id="L614" title="1 of 2 branches missed.">            if (decomposer.getNullity() &gt; 1) {</span>
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
<span class="nc" id="L618">                throw new ImageOfAbsoluteConicEstimatorException();</span>
            }

<span class="fc" id="L621">            final var v = decomposer.getV();</span>

            // use last column of V as IAC vector

            // the last column of V contains IAC matrix (B), which is symmetric
            // and positive definite, ordered as follows: B11, B12, B22, B13,
            // B23, B33
<span class="fc" id="L628">            final var b11 = v.getElementAt(0, 4);</span>
<span class="fc" id="L629">            final var b22 = v.getElementAt(1, 4);</span>
<span class="fc" id="L630">            final var b13 = v.getElementAt(2, 4);</span>
<span class="fc" id="L631">            final var b23 = v.getElementAt(3, 4);</span>
<span class="fc" id="L632">            final var b33 = v.getElementAt(4, 4);</span>

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
            // Since skewness is zero b12 = B = 0.0
<span class="fc" id="L638">            return new ImageOfAbsoluteConic(b11, 0.0, b22, b13, b23, b33);</span>
<span class="nc" id="L639">        } catch (final AlgebraException | SortingException e) {</span>
<span class="nc" id="L640">            throw new ImageOfAbsoluteConicEstimatorException(e);</span>
        }
    }

    /**
     * Estimates Image of Absolute Conic (IAC) assuming that principal point is
     * located at origin of coordinates.
     *
     * @return estimated IAC.
     * @throws ImageOfAbsoluteConicEstimatorException if an error occurs during
     *                                                estimation, usually because repeated homographies
     *                                                are provided, or homographies corresponding to
     *                                                degenerate camera movements such as pure parallel
     *                                                translations where no additional data is really
     *                                                provided.
     */
    private ImageOfAbsoluteConic estimatePrincipalPointAtOrigin() throws ImageOfAbsoluteConicEstimatorException {

        try {
<span class="fc" id="L659">            final var nHomographies = homographies.size();</span>

<span class="fc" id="L661">            final var selection = WeightSelection.selectWeights(weights, sortWeights, maxHomographies);</span>
<span class="fc" id="L662">            final var selected = selection.getSelected();</span>

<span class="fc" id="L664">            final var a = new Matrix(2 * nHomographies, 4);</span>

<span class="fc" id="L666">            var index = 0;</span>
<span class="fc" id="L667">            var counter = 0;</span>
<span class="fc" id="L668">            ProjectiveTransformation2D t = null;</span>
<span class="fc" id="L669">            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);</span>
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            double weight;
            double factor;
<span class="fc bfc" id="L680" title="All 2 branches covered.">            for (final var homography : homographies) {</span>
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">                if (selected[index]) {</span>
<span class="fc" id="L682">                    weight = weights[index];</span>

                    // convert homography into projective so it can be normalized
<span class="fc" id="L685">                    homography.asMatrix(h);</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">                    if (t == null) {</span>
<span class="fc" id="L687">                        t = new ProjectiveTransformation2D(h);</span>
                    } else {
<span class="fc" id="L689">                        t.setT(h);</span>
                    }

                    // normalize
<span class="fc" id="L693">                    t.normalize();</span>

                    // obtain elements of projective transformation matrix
                    // there is no need to retrieve internal matrix h, as we already
                    // hold a reference
<span class="fc" id="L698">                    h11 = h.getElementAt(0, 0);</span>
<span class="fc" id="L699">                    h12 = h.getElementAt(0, 1);</span>

<span class="fc" id="L701">                    h21 = h.getElementAt(1, 0);</span>
<span class="fc" id="L702">                    h22 = h.getElementAt(1, 1);</span>

<span class="fc" id="L704">                    h31 = h.getElementAt(2, 0);</span>
<span class="fc" id="L705">                    h32 = h.getElementAt(2, 1);</span>

                    // fill first equation
<span class="fc" id="L708">                    a.setElementAt(counter, 0, h11 * h12);</span>
<span class="fc" id="L709">                    a.setElementAt(counter, 1, h11 * h22 + h21 * h12);</span>
<span class="fc" id="L710">                    a.setElementAt(counter, 2, h21 * h22);</span>
<span class="fc" id="L711">                    a.setElementAt(counter, 3, h31 * h32);</span>

                    // normalize row
<span class="fc" id="L714">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L715">                            + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L716">                            + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L717">                            + Math.pow(a.getElementAt(counter, 3), 2.0));</span>
<span class="fc" id="L718">                    factor = weight / rowNorm;</span>

<span class="fc" id="L720">                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);</span>
<span class="fc" id="L721">                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);</span>
<span class="fc" id="L722">                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);</span>
<span class="fc" id="L723">                    a.setElementAt(counter, 3, a.getElementAt(counter, 3) * factor);</span>

<span class="fc" id="L725">                    counter++;</span>

                    // fill second equation
<span class="fc" id="L728">                    a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0));</span>
<span class="fc" id="L729">                    a.setElementAt(counter, 1, 2.0 * (h11 * h21 - h12 * h22));</span>
<span class="fc" id="L730">                    a.setElementAt(counter, 2, Math.pow(h21, 2.0) - Math.pow(h22, 2.0));</span>
<span class="fc" id="L731">                    a.setElementAt(counter, 3, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));</span>

                    // normalize row
<span class="fc" id="L734">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L735">                            + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L736">                            + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L737">                            + Math.pow(a.getElementAt(counter, 3), 2.0));</span>
<span class="fc" id="L738">                    factor = weight / rowNorm;</span>

<span class="fc" id="L740">                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);</span>
<span class="fc" id="L741">                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);</span>
<span class="fc" id="L742">                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);</span>
<span class="fc" id="L743">                    a.setElementAt(counter, 3, a.getElementAt(counter, 3) * factor);</span>

<span class="fc" id="L745">                    counter++;</span>
                }

<span class="fc" id="L748">                index++;</span>
<span class="fc" id="L749">            }</span>

<span class="fc" id="L751">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L752">            decomposer.decompose();</span>

<span class="pc bpc" id="L754" title="1 of 2 branches missed.">            if (decomposer.getNullity() &gt; 1) {</span>
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
<span class="nc" id="L758">                throw new ImageOfAbsoluteConicEstimatorException();</span>
            }

<span class="fc" id="L761">            var v = decomposer.getV();</span>

            // use last column of V as IAC vector

            // the last column of V contains IAC matrix (B), which is symmetric
            // and positive definite, ordered as follows: B11, B12, B22, B13,
            // B23, B33
<span class="fc" id="L768">            final var b11 = v.getElementAt(0, 3);</span>
<span class="fc" id="L769">            final var b12 = v.getElementAt(1, 3);</span>
<span class="fc" id="L770">            final var b22 = v.getElementAt(2, 3);</span>
<span class="fc" id="L771">            final var b33 = v.getElementAt(3, 3);</span>

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
            // Since principal point is at origin of coordinates
            // b13 = D = 0.0, b23 = E = 0.0
<span class="fc" id="L778">            return new ImageOfAbsoluteConic(b11, b12, b22, 0.0, 0.0, b33);</span>
<span class="nc" id="L779">        } catch (final AlgebraException | SortingException e) {</span>
<span class="nc" id="L780">            throw new ImageOfAbsoluteConicEstimatorException(e);</span>
        }
    }

    /**
     * Estimates Image of Absolute Conic (IAC) assuming that skewness is zero
     * and that principal point is located at origin of coordinates.
     *
     * @return estimated IAC.
     * @throws ImageOfAbsoluteConicEstimatorException if an error occurs during
     *                                                estimation, usually because repeated homographies
     *                                                are provided, or homographies corresponding to
     *                                                degenerate camera movements such as pure parallel
     *                                                translations where no additional data is really
     *                                                provided.
     */
    private ImageOfAbsoluteConic estimateZeroSkewnessAndPrincipalPointAtOrigin()
            throws ImageOfAbsoluteConicEstimatorException {

        try {
<span class="fc" id="L800">            final var nHomographies = homographies.size();</span>

<span class="fc" id="L802">            final var selection = WeightSelection.selectWeights(weights, sortWeights, maxHomographies);</span>
<span class="fc" id="L803">            final var selected = selection.getSelected();</span>

<span class="fc" id="L805">            final var a = new Matrix(2 * nHomographies, 3);</span>

<span class="fc" id="L807">            var index = 0;</span>
<span class="fc" id="L808">            var counter = 0;</span>
<span class="fc" id="L809">            ProjectiveTransformation2D t = null;</span>
<span class="fc" id="L810">            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);</span>
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            double weight;
            double factor;
<span class="fc bfc" id="L821" title="All 2 branches covered.">            for (final var homography : homographies) {</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">                if (selected[index]) {</span>
<span class="fc" id="L823">                    weight = weights[index];</span>

                    // convert homography into projective so it can be normalized
<span class="fc" id="L826">                    homography.asMatrix(h);</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">                    if (t == null) {</span>
<span class="fc" id="L828">                        t = new ProjectiveTransformation2D(h);</span>
                    } else {
<span class="fc" id="L830">                        t.setT(h);</span>
                    }

                    // normalize
<span class="fc" id="L834">                    t.normalize();</span>

                    // obtain elements of projective transformation matrix
                    // there is no need to retrieve internal matrix h, as we already
                    // hold a reference
<span class="fc" id="L839">                    h11 = h.getElementAt(0, 0);</span>
<span class="fc" id="L840">                    h12 = h.getElementAt(0, 1);</span>

<span class="fc" id="L842">                    h21 = h.getElementAt(1, 0);</span>
<span class="fc" id="L843">                    h22 = h.getElementAt(1, 1);</span>

<span class="fc" id="L845">                    h31 = h.getElementAt(2, 0);</span>
<span class="fc" id="L846">                    h32 = h.getElementAt(2, 1);</span>

                    // fill first equation
<span class="fc" id="L849">                    a.setElementAt(counter, 0, h11 * h12);</span>
<span class="fc" id="L850">                    a.setElementAt(counter, 1, h21 * h22);</span>
<span class="fc" id="L851">                    a.setElementAt(counter, 2, h31 * h32);</span>

                    // normalize row
<span class="fc" id="L854">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L855">                            + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L856">                            + Math.pow(a.getElementAt(counter, 2), 2.0));</span>
<span class="fc" id="L857">                    factor = weight / rowNorm;</span>

<span class="fc" id="L859">                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);</span>
<span class="fc" id="L860">                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);</span>
<span class="fc" id="L861">                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);</span>

<span class="fc" id="L863">                    counter++;</span>

                    // fill second equation
<span class="fc" id="L866">                    a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0));</span>
<span class="fc" id="L867">                    a.setElementAt(counter, 1, Math.pow(h21, 2.0) - Math.pow(h22, 2.0));</span>
<span class="fc" id="L868">                    a.setElementAt(counter, 2, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));</span>

                    // normalize row
<span class="fc" id="L871">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L872">                            + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L873">                            + Math.pow(a.getElementAt(counter, 2), 2.0));</span>
<span class="fc" id="L874">                    factor = weight / rowNorm;</span>

<span class="fc" id="L876">                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);</span>
<span class="fc" id="L877">                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);</span>
<span class="fc" id="L878">                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);</span>

<span class="fc" id="L880">                    counter++;</span>
                }

<span class="fc" id="L883">                index++;</span>
<span class="fc" id="L884">            }</span>

<span class="fc" id="L886">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L887">            decomposer.decompose();</span>

<span class="pc bpc" id="L889" title="1 of 2 branches missed.">            if (decomposer.getNullity() &gt; 1) {</span>
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
<span class="nc" id="L893">                throw new ImageOfAbsoluteConicEstimatorException();</span>
            }

<span class="fc" id="L896">            final var v = decomposer.getV();</span>

            // use last column of V as IAC vector

            // the last column of V contains IAC matrix (B), which is symmetric
            // and positive definite, ordered as follows: B11, B12, B22, B13,
            // B23, B33
<span class="fc" id="L903">            final var b11 = v.getElementAt(0, 2);</span>
<span class="fc" id="L904">            final var b22 = v.getElementAt(1, 2);</span>
<span class="fc" id="L905">            final var b33 = v.getElementAt(2, 2);</span>

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
            // Since principal point is at origin of coordinates
            // b12 = B = 0, b13 = D = 0.0, b23 = E = 0.0
<span class="fc" id="L912">            return new ImageOfAbsoluteConic(b11, 0.0, b22, 0.0, 0.0, b33);</span>
<span class="nc" id="L913">        } catch (final AlgebraException | SortingException e) {</span>
<span class="nc" id="L914">            throw new ImageOfAbsoluteConicEstimatorException(e);</span>
        }
    }

    /**
     * Estimates Image of Absolute Conic (IAC) assuming that skewness is zero
     * and that aspect ratio of focal distances is known.
     *
     * @return estimated IAC.
     * @throws ImageOfAbsoluteConicEstimatorException if an error occurs during
     *                                                estimation, usually because repeated homographies
     *                                                are provided, or homographies corresponding to
     *                                                degenerate camera movements such as pure parallel
     *                                                translations where no additional data is really
     *                                                provided.
     */
    private ImageOfAbsoluteConic estimateZeroSkewnessAndKnownFocalDistanceAspectRatio()
            throws ImageOfAbsoluteConicEstimatorException {
        try {
<span class="fc" id="L933">            final var nHomographies = homographies.size();</span>

<span class="fc" id="L935">            final var selection = WeightSelection.selectWeights(weights, sortWeights, maxHomographies);</span>
<span class="fc" id="L936">            final var selected = selection.getSelected();</span>

<span class="fc" id="L938">            final var a = new Matrix(2 * nHomographies, 4);</span>
<span class="fc" id="L939">            final var sqrAspectRatio = Math.pow(focalDistanceAspectRatio, 2.0);</span>

<span class="fc" id="L941">            var index = 0;</span>
<span class="fc" id="L942">            var counter = 0;</span>
<span class="fc" id="L943">            ProjectiveTransformation2D t = null;</span>
<span class="fc" id="L944">            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);</span>
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            double weight;
            double factor;
<span class="fc bfc" id="L955" title="All 2 branches covered.">            for (final var homography : homographies) {</span>
<span class="pc bpc" id="L956" title="1 of 2 branches missed.">                if (selected[index]) {</span>
<span class="fc" id="L957">                    weight = weights[index];</span>

                    // convert homography into projective so it can be normalized
<span class="fc" id="L960">                    homography.asMatrix(h);</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">                    if (t == null) {</span>
<span class="fc" id="L962">                        t = new ProjectiveTransformation2D(h);</span>
                    } else {
<span class="fc" id="L964">                        t.setT(h);</span>
                    }

                    // normalize
<span class="fc" id="L968">                    t.normalize();</span>

                    // obtain elements of projective transformation matrix
                    // there is no need to retrieve internal matrix h, as we already
                    // hold a reference
<span class="fc" id="L973">                    h11 = h.getElementAt(0, 0);</span>
<span class="fc" id="L974">                    h12 = h.getElementAt(0, 1);</span>

<span class="fc" id="L976">                    h21 = h.getElementAt(1, 0);</span>
<span class="fc" id="L977">                    h22 = h.getElementAt(1, 1);</span>

<span class="fc" id="L979">                    h31 = h.getElementAt(2, 0);</span>
<span class="fc" id="L980">                    h32 = h.getElementAt(2, 1);</span>

                    // fill first equation
<span class="fc" id="L983">                    a.setElementAt(counter, 0, h11 * h12 + h21 * h22 / sqrAspectRatio);</span>
<span class="fc" id="L984">                    a.setElementAt(counter, 1, h11 * h32 + h31 * h12);</span>
<span class="fc" id="L985">                    a.setElementAt(counter, 2, h21 * h32 + h31 * h22);</span>
<span class="fc" id="L986">                    a.setElementAt(counter, 3, h31 * h32);</span>

                    // normalize row
<span class="fc" id="L989">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L990">                            + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L991">                            + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L992">                            + Math.pow(a.getElementAt(counter, 3), 2.0));</span>
<span class="fc" id="L993">                    factor = weight / rowNorm;</span>

<span class="fc" id="L995">                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);</span>
<span class="fc" id="L996">                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);</span>
<span class="fc" id="L997">                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);</span>
<span class="fc" id="L998">                    a.setElementAt(counter, 3, a.getElementAt(counter, 3) * factor);</span>

<span class="fc" id="L1000">                    counter++;</span>

                    // fill second equation
<span class="fc" id="L1003">                    a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0)</span>
<span class="fc" id="L1004">                            + (Math.pow(h21, 2.0) - Math.pow(h22, 2.0)) / sqrAspectRatio);</span>
<span class="fc" id="L1005">                    a.setElementAt(counter, 1, 2.0 * (h11 * h31 - h12 * h32));</span>
<span class="fc" id="L1006">                    a.setElementAt(counter, 2, 2.0 * (h21 * h31 - h22 * h32));</span>
<span class="fc" id="L1007">                    a.setElementAt(counter, 3, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));</span>

                    // normalize row
<span class="fc" id="L1010">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L1011">                            + Math.pow(a.getElementAt(counter, 1), 2.0)</span>
<span class="fc" id="L1012">                            + Math.pow(a.getElementAt(counter, 2), 2.0)</span>
<span class="fc" id="L1013">                            + Math.pow(a.getElementAt(counter, 3), 2.0));</span>
<span class="fc" id="L1014">                    factor = weight / rowNorm;</span>

<span class="fc" id="L1016">                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);</span>
<span class="fc" id="L1017">                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);</span>
<span class="fc" id="L1018">                    a.setElementAt(counter, 2, a.getElementAt(counter, 2) * factor);</span>
<span class="fc" id="L1019">                    a.setElementAt(counter, 3, a.getElementAt(counter, 3) * factor);</span>

<span class="fc" id="L1021">                    counter++;</span>
                }

<span class="fc" id="L1024">                index++;</span>
<span class="fc" id="L1025">            }</span>

<span class="fc" id="L1027">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L1028">            decomposer.decompose();</span>

<span class="pc bpc" id="L1030" title="1 of 2 branches missed.">            if (decomposer.getNullity() &gt; 1) {</span>
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
<span class="nc" id="L1034">                throw new ImageOfAbsoluteConicEstimatorException();</span>
            }

<span class="fc" id="L1037">            final var v = decomposer.getV();</span>

            // use last column of V as IAC vector

            // the last column of V contains IAC matrix (B), which is symmetric
            // and positive definite, ordered as follows: B11, B12, B22, B13,
            // B23, B33
<span class="fc" id="L1044">            final var b11 = v.getElementAt(0, 3);</span>
<span class="fc" id="L1045">            final var b13 = v.getElementAt(1, 3);</span>
<span class="fc" id="L1046">            final var b23 = v.getElementAt(2, 3);</span>
<span class="fc" id="L1047">            final var b33 = v.getElementAt(3, 3);</span>

<span class="fc" id="L1049">            final var b22 = b11 / sqrAspectRatio;</span>

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
            // Since skewness is zero b12 = B = 0.0
<span class="fc" id="L1055">            return new ImageOfAbsoluteConic(b11, 0.0, b22, b13, b23, b33);</span>
<span class="nc" id="L1056">        } catch (final AlgebraException | SortingException e) {</span>
<span class="nc" id="L1057">            throw new ImageOfAbsoluteConicEstimatorException(e);</span>
        }
    }

    /**
     * Estimates Image of Absolute Conic (IAC) assuming that skewness is zero,
     * principal point is located at origin of coordinates and that aspect ratio
     * of focal distances is known.
     *
     * @return estimated IAC.
     * @throws ImageOfAbsoluteConicEstimatorException if an error occurs during
     *                                                estimation, usually because repeated homographies
     *                                                are provided, or homographies corresponding to
     *                                                degenerate camera movements such as pure parallel
     *                                                translations where no additional data is really
     *                                                provided.
     */
    private ImageOfAbsoluteConic estimateZeroSkewnessPrincipalPointAtOriginAndKnownFocalDistanceAspectRatio()
            throws ImageOfAbsoluteConicEstimatorException {

        try {
<span class="fc" id="L1078">            final var nHomographies = homographies.size();</span>

<span class="fc" id="L1080">            final var selection = WeightSelection.selectWeights(weights, sortWeights, maxHomographies);</span>
<span class="fc" id="L1081">            final var selected = selection.getSelected();</span>

<span class="fc" id="L1083">            final var a = new Matrix(2 * nHomographies, 2);</span>

<span class="fc" id="L1085">            final var sqrAspectRatio = Math.pow(focalDistanceAspectRatio, 2.0);</span>

<span class="fc" id="L1087">            var index = 0;</span>
<span class="fc" id="L1088">            var counter = 0;</span>
<span class="fc" id="L1089">            ProjectiveTransformation2D t = null;</span>
<span class="fc" id="L1090">            final var h = new Matrix(ProjectiveTransformation2D.HOM_COORDS, ProjectiveTransformation2D.HOM_COORDS);</span>
            // elements ij of homography (last column is not required)
            double h11;
            double h12;
            double h21;
            double h22;
            double h31;
            double h32;
            double rowNorm;
            double weight;
            double factor;
<span class="fc bfc" id="L1101" title="All 2 branches covered.">            for (final var homography : homographies) {</span>
<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">                if (selected[index]) {</span>
<span class="fc" id="L1103">                    weight = weights[index];</span>

                    // convert homography into projective so it can be normalized
<span class="fc" id="L1106">                    homography.asMatrix(h);</span>
<span class="fc bfc" id="L1107" title="All 2 branches covered.">                    if (t == null) {</span>
<span class="fc" id="L1108">                        t = new ProjectiveTransformation2D(h);</span>
                    } else {
<span class="fc" id="L1110">                        t.setT(h);</span>
                    }

                    // normalize
<span class="fc" id="L1114">                    t.normalize();</span>

                    // obtain elements of projective transformation matrix
                    // there is no need to retrieve internal matrix h, as we already
                    // hold a reference
<span class="fc" id="L1119">                    h11 = h.getElementAt(0, 0);</span>
<span class="fc" id="L1120">                    h12 = h.getElementAt(0, 1);</span>

<span class="fc" id="L1122">                    h21 = h.getElementAt(1, 0);</span>
<span class="fc" id="L1123">                    h22 = h.getElementAt(1, 1);</span>

<span class="fc" id="L1125">                    h31 = h.getElementAt(2, 0);</span>
<span class="fc" id="L1126">                    h32 = h.getElementAt(2, 1);</span>

                    // fill first equation
<span class="fc" id="L1129">                    a.setElementAt(counter, 0, h11 * h12 + h21 * h22 / sqrAspectRatio);</span>
<span class="fc" id="L1130">                    a.setElementAt(counter, 1, h31 * h32);</span>

                    // normalize row
<span class="fc" id="L1133">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L1134">                            + Math.pow(a.getElementAt(counter, 1), 2.0));</span>
<span class="fc" id="L1135">                    factor = weight / rowNorm;</span>

<span class="fc" id="L1137">                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);</span>
<span class="fc" id="L1138">                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);</span>

<span class="fc" id="L1140">                    counter++;</span>

                    // fill second equation
<span class="fc" id="L1143">                    a.setElementAt(counter, 0, Math.pow(h11, 2.0) - Math.pow(h12, 2.0)</span>
<span class="fc" id="L1144">                            + (Math.pow(h21, 2.0) - Math.pow(h22, 2.0)) / sqrAspectRatio);</span>
<span class="fc" id="L1145">                    a.setElementAt(counter, 1, Math.pow(h31, 2.0) - Math.pow(h32, 2.0));</span>

                    // normalize row
<span class="fc" id="L1148">                    rowNorm = Math.sqrt(Math.pow(a.getElementAt(counter, 0), 2.0)</span>
<span class="fc" id="L1149">                            + Math.pow(a.getElementAt(counter, 1), 2.0));</span>
<span class="fc" id="L1150">                    factor = weight / rowNorm;</span>

<span class="fc" id="L1152">                    a.setElementAt(counter, 0, a.getElementAt(counter, 0) * factor);</span>
<span class="fc" id="L1153">                    a.setElementAt(counter, 1, a.getElementAt(counter, 1) * factor);</span>

<span class="fc" id="L1155">                    counter++;</span>
                }

<span class="fc" id="L1158">                index++;</span>
<span class="fc" id="L1159">            }</span>

<span class="fc" id="L1161">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L1162">            decomposer.decompose();</span>

<span class="pc bpc" id="L1164" title="1 of 2 branches missed.">            if (decomposer.getNullity() &gt; 1) {</span>
                // homographies constitute a degenerate camera movement.
                // A linear combination of possible IAC's exist (i.e. solution is
                // not unique up to scale)
<span class="nc" id="L1168">                throw new ImageOfAbsoluteConicEstimatorException();</span>
            }

<span class="fc" id="L1171">            final var v = decomposer.getV();</span>

            // use last column of V as IAC vector

            // the last column of V contains IAC matrix (B), which is symmetric
            // and positive definite, ordered as follows: B11, B12, B22, B13,
            // B23, B33
<span class="fc" id="L1178">            final var b11 = v.getElementAt(0, 1);</span>
<span class="fc" id="L1179">            final var b33 = v.getElementAt(1, 1);</span>

<span class="fc" id="L1181">            final var b22 = b11 / sqrAspectRatio;</span>

            // A conic is defined as [A  B   D]
            //                       [B  C   E]
            //                       [D  E   F]
            // Since principal point is at origin of coordinates
            // b12 = B = 0, b13 = D = 0.0, b23 = E = 0.0
<span class="fc" id="L1188">            return new ImageOfAbsoluteConic(b11, 0.0, b22, 0.0, 0.0, b33);</span>
<span class="nc" id="L1189">        } catch (final AlgebraException | SortingException e) {</span>
<span class="nc" id="L1190">            throw new ImageOfAbsoluteConicEstimatorException(e);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>