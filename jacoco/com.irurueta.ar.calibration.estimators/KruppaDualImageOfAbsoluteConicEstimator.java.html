<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KruppaDualImageOfAbsoluteConicEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.calibration.estimators</a> &gt; <span class="el_source">KruppaDualImageOfAbsoluteConicEstimator.java</span></div><h1>KruppaDualImageOfAbsoluteConicEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2016 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.calibration.estimators;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.CholeskyDecomposer;
import com.irurueta.algebra.Complex;
import com.irurueta.algebra.SingularValueDecomposer;
import com.irurueta.ar.calibration.DualImageOfAbsoluteConic;
import com.irurueta.ar.epipolar.FundamentalMatrix;
import com.irurueta.geometry.PinholeCameraIntrinsicParameters;
import com.irurueta.geometry.estimators.LockedException;
import com.irurueta.geometry.estimators.NotReadyException;
import com.irurueta.numerical.NumericalException;
import com.irurueta.numerical.polynomials.Polynomial;

/**
 * Estimates the DIAC (Dual Image of Absolute Conic) by solving Kruppa's
 * equations and assuming known principal point and zero skewness.
 * This estimator allows enforcing a known aspect ratio as well.
 * The DIAC can be used to obtain the intrinsic parameters of a pair of
 * cameras related by a fundamental matrix.
 * Hence, this class can be used for auto-calibration purposes.
 * Notice that the {@link DualAbsoluteQuadricEstimator} is a more robust method of
 * auto-calibration.
 * This class is based on:
 * S.D. Hippisley-Cox &amp;amp; J.Porrill. Auto-calibration - Kruppa's equations and the
 * intrinsic parameters of a camera. AI Vision Research Unit. University of
 * Sheffield.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class KruppaDualImageOfAbsoluteConicEstimator {

    /**
     * Degree of polynomial to solve Kruppa's equation when aspect ratio is
     * known.
     */
    private static final int POLY_DEGREE_UNKNOWN_ASPECT_RATIO = 4;

    /**
     * Default value for horizontal principal point coordinate.
     */
    public static final double DEFAULT_PRINCIPAL_POINT_X = 0.0;

    /**
     * Default value for vertical principal point coordinate.
     */
    public static final double DEFAULT_PRINCIPAL_POINT_Y = 0.0;

    /**
     * Constant defining whether aspect ratio of focal distance (i.e. vertical
     * focal distance divided by horizontal focal distance) is known or not.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio. Typically, LCD sensor cells are square and hence aspect
     * ratio of focal distances is known and equal to 1.
     */
    public static final boolean DEFAULT_FOCAL_DISTANCE_ASPECT_RATIO_KNOWN = true;

    /**
     * Constant defining default aspect ratio of focal distances. This constant
     * takes into account that typically LCD sensor cells are square and hence
     * aspect ratio of focal distances is known and equal to 1.
     */
    public static final double DEFAULT_FOCAL_DISTANCE_ASPECT_RATIO = 1.0;

    /**
     * Minimum absolute value allowed for aspect ratio of focal distances.
     */
    public static final double MIN_ABS_FOCAL_DISTANCE_ASPECT_RATIO = 1e-6;

    /**
     * Known horizontal principal point coordinate.
     */
    private double principalPointX;

    /**
     * Known vertical principal point coordinate.
     */
    private double principalPointY;

    /**
     * Indicates whether aspect ratio of focal distances (i.e. vertical focal
     * distance divided by horizontal focal distance) is known or not.
     * Notice that focal distance aspect ratio is not related to image aspect
     * ratio. Typically, LCD sensor cells are square and hence aspect ratio of
     * focal distances is known and equal to 1.
     */
    private boolean focalDistanceAspectRatioKnown;

    /**
     * Contains aspect ratio of focal distances (i.e. vertical focal distance
     * divided by horizontal focal distance).
     * By default, this is 1.0, since it is taken into account that typically
     * LCD sensor cells are square and hence aspect ratio focal distance is
     * known and equal to 1.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio.
     */
    private double focalDistanceAspectRatio;

    /**
     * True when estimator is estimating the DIAC.
     */
    private boolean locked;

    /**
     * Listener to be notified of events such as when estimation starts, ends or
     * estimation progress changes.
     */
    private KruppaDualImageOfAbsoluteConicEstimatorListener listener;

    /**
     * Fundamental matrix to estimate DIAC from.
     */
    private FundamentalMatrix fundamentalMatrix;

    /**
     * Constructor.
     */
<span class="fc" id="L133">    public KruppaDualImageOfAbsoluteConicEstimator() {</span>
<span class="fc" id="L134">        principalPointX = DEFAULT_PRINCIPAL_POINT_X;</span>
<span class="fc" id="L135">        principalPointY = DEFAULT_PRINCIPAL_POINT_Y;</span>
<span class="fc" id="L136">        focalDistanceAspectRatioKnown = DEFAULT_FOCAL_DISTANCE_ASPECT_RATIO_KNOWN;</span>
<span class="fc" id="L137">        focalDistanceAspectRatio = DEFAULT_FOCAL_DISTANCE_ASPECT_RATIO;</span>

<span class="fc" id="L139">        locked = false;</span>
<span class="fc" id="L140">        listener = null;</span>
<span class="fc" id="L141">        fundamentalMatrix = null;</span>
<span class="fc" id="L142">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     */
    public KruppaDualImageOfAbsoluteConicEstimator(final KruppaDualImageOfAbsoluteConicEstimatorListener listener) {
<span class="fc" id="L151">        this();</span>
<span class="fc" id="L152">        this.listener = listener;</span>
<span class="fc" id="L153">    }</span>

    /**
     * Constructor.
     *
     * @param fundamentalMatrix fundamental matrix to estimate DIAC from.
     */
    public KruppaDualImageOfAbsoluteConicEstimator(final FundamentalMatrix fundamentalMatrix) {
<span class="fc" id="L161">        this();</span>
<span class="fc" id="L162">        this.fundamentalMatrix = fundamentalMatrix;</span>
<span class="fc" id="L163">    }</span>

    /**
     * Constructor.
     *
     * @param fundamentalMatrix fundamental matrix to estimate DIAC from.
     * @param listener          listener to be notified of events such as when estimation
     *                          starts, ends or estimation progress changes.
     */
    public KruppaDualImageOfAbsoluteConicEstimator(
            final FundamentalMatrix fundamentalMatrix, final KruppaDualImageOfAbsoluteConicEstimatorListener listener) {
<span class="fc" id="L174">        this(fundamentalMatrix);</span>
<span class="fc" id="L175">        this.listener = listener;</span>
<span class="fc" id="L176">    }</span>

    /**
     * Gets known horizontal principal point coordinate.
     *
     * @return known horizontal principal point coordinate.
     */
    public double getPrincipalPointX() {
<span class="fc" id="L184">        return principalPointX;</span>
    }

    /**
     * Sets known horizontal principal point coordinate.
     *
     * @param principalPointX known horizontal principal point coordinate to be
     *                        set.
     * @throws LockedException if estimator is locked.
     */
    public void setPrincipalPointX(final double principalPointX) throws LockedException {
<span class="fc bfc" id="L195" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L196">            throw new LockedException();</span>
        }
<span class="fc" id="L198">        this.principalPointX = principalPointX;</span>
<span class="fc" id="L199">    }</span>

    /**
     * Gets known vertical principal point coordinate.
     *
     * @return known vertical principal point coordinate.
     */
    public double getPrincipalPointY() {
<span class="fc" id="L207">        return principalPointY;</span>
    }

    /**
     * Sets known vertical principal point coordinate.
     *
     * @param principalPointY known vertical principal point coordinate to be
     *                        set.
     * @throws LockedException if estimator is locked.
     */
    public void setPrincipalPointY(final double principalPointY) throws LockedException {
<span class="fc bfc" id="L218" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L219">            throw new LockedException();</span>
        }
<span class="fc" id="L221">        this.principalPointY = principalPointY;</span>
<span class="fc" id="L222">    }</span>

    /**
     * Returns boolean indicating whether aspect ratio of focal distances (i.e.
     * vertical focal distance divided by horizontal focal distance) is known or
     * not.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio. Typically, LCD sensor cells are square and hence aspect
     * ratio of focal distances is known and equal to 1.
     * This value is only taken into account if skewness is assumed to be zero,
     * otherwise it is ignored.
     *
     * @return true if focal distance aspect ratio is known, false otherwise.
     */
    public boolean isFocalDistanceAspectRatioKnown() {
<span class="fc" id="L237">        return focalDistanceAspectRatioKnown;</span>
    }

    /**
     * Sets value indicating whether aspect ratio of focal distances (i.e.
     * vertical focal distance divided by horizontal focal distance) is known or
     * not.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio. Typically, LCD sensor cells are square and hence aspect
     * ratio of focal distances is known and equal to 1.
     * This value is only taken into account if skewness is assumed to be
     * otherwise it is ignored.
     *
     * @param focalDistanceAspectRatioKnown true if focal distance aspect ratio
     *                                      is known, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setFocalDistanceAspectRatioKnown(final boolean focalDistanceAspectRatioKnown) throws LockedException {
<span class="fc bfc" id="L255" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L256">            throw new LockedException();</span>
        }

<span class="fc" id="L259">        this.focalDistanceAspectRatioKnown = focalDistanceAspectRatioKnown;</span>
<span class="fc" id="L260">    }</span>

    /**
     * Returns aspect ratio of focal distances (i.e. vertical focal distance
     * divided by horizontal focal distance).
     * By default, this is 1.0, since it is taken into account that typically
     * LCD sensor cells are square and hence aspect ratio focal distances is
     * known and equal to 1.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio
     * Notice that a negative aspect ratio indicates that vertical axis is
     * reversed. This can be useful in some situations where image vertical
     * coordinates are reversed respect to the physical world (i.e. in computer
     * graphics typically image vertical coordinates go downwards, while in
     * physical world they go upwards).
     *
     * @return aspect ratio of focal distances.
     */
    public double getFocalDistanceAspectRatio() {
<span class="fc" id="L279">        return focalDistanceAspectRatio;</span>
    }

    /**
     * Sets aspect ratio of focal distances (i.e. vertical focal distance
     * divided by horizontal focal distance).
     * This value is only taken into account if aspect ratio is marked as known,
     * otherwise it is ignored.
     * By default, this is 1.0, since it is taken into account that typically
     * LCD sensor cells are square and hence aspect ratio focal distances is
     * known and equal to 1.
     * Notice that focal distance aspect ratio is not related to image size
     * aspect ratio.
     * Notice that a negative aspect ratio indicates that vertical axis is
     * reversed. This can be useful in some situations where image vertical
     * coordinates are reversed respect to the physical world (i.e. in computer
     * graphics typically image vertical coordinates go downwards, while in
     * physical world they go upwards).
     *
     * @param focalDistanceAspectRatio aspect ratio of focal distances to be
     *                                 set.
     * @throws LockedException          if estimator is locked.
     * @throws IllegalArgumentException if focal distance aspect ratio is too
     *                                  close to zero, as it might produce numerical instabilities.
     */
    public void setFocalDistanceAspectRatio(final double focalDistanceAspectRatio) throws LockedException {
<span class="fc bfc" id="L305" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L306">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">        if (Math.abs(focalDistanceAspectRatio) &lt; MIN_ABS_FOCAL_DISTANCE_ASPECT_RATIO) {</span>
<span class="nc" id="L309">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L312">        this.focalDistanceAspectRatio = focalDistanceAspectRatio;</span>
<span class="fc" id="L313">    }</span>

    /**
     * Indicates whether this instance is locked.
     *
     * @return true if this estimator is busy estimating a DIAC, false
     * otherwise.
     */
    public boolean isLocked() {
<span class="fc" id="L322">        return locked;</span>
    }

    /**
     * Returns listener to be notified of events such as when estimation starts,
     * ends or estimation progress changes.
     *
     * @return listener to be notified of events.
     */
    public KruppaDualImageOfAbsoluteConicEstimatorListener getListener() {
<span class="fc" id="L332">        return listener;</span>
    }

    /**
     * Sets listener to be notified of events such as when estimation starts,
     * ends or estimation progress changes.
     *
     * @param listener listener to be notified of events.
     * @throws LockedException if estimator is locked.
     */
    public void setListener(
            final KruppaDualImageOfAbsoluteConicEstimatorListener listener) throws LockedException {
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L345">            throw new LockedException();</span>
        }
<span class="fc" id="L347">        this.listener = listener;</span>
<span class="fc" id="L348">    }</span>

    /**
     * Gets fundamental matrix to estimate DIAC from.
     *
     * @return fundamental matrix to estimate DIAC from.
     */
    public FundamentalMatrix getFundamentalMatrix() {
<span class="fc" id="L356">        return fundamentalMatrix;</span>
    }

    /**
     * Sets fundamental matrix to estimate DIAC from.
     *
     * @param fundamentalMatrix fundamental matrix to estimate DIAC from.
     * @throws LockedException if estimator is locked.
     */
    public void setFundamentalMatrix(final FundamentalMatrix fundamentalMatrix) throws LockedException {
<span class="fc bfc" id="L366" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L367">            throw new LockedException();</span>
        }
<span class="fc" id="L369">        this.fundamentalMatrix = fundamentalMatrix;</span>
<span class="fc" id="L370">    }</span>

    /**
     * Returns value indicating whether required data has been provided so that
     * DIAC estimation can start.
     * If true, estimator is ready to compute the DIAC, otherwise more data
     * needs to be provided.
     *
     * @return true if estimator is ready, false otherwise.
     */
    public boolean isReady() {
<span class="fc bfc" id="L381" title="All 2 branches covered.">        return fundamentalMatrix != null;</span>
    }

    /**
     * Estimates Dual Image of Absolute Conic (DIAC).
     *
     * @return estimated DIAC.
     * @throws LockedException                                  if estimator is locked.
     * @throws NotReadyException                                if input has not yet been provided.
     * @throws KruppaDualImageOfAbsoluteConicEstimatorException if an error
     *                                                          occurs during estimation, usually because
     *                                                          fundamental matrix corresponds to
     *                                                          degenerate camera movements, or because of
     *                                                          numerical instabilities.
     */
    public DualImageOfAbsoluteConic estimate() throws LockedException, NotReadyException,
            KruppaDualImageOfAbsoluteConicEstimatorException {
<span class="fc" id="L398">        final var result = new DualImageOfAbsoluteConic(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);</span>
<span class="fc" id="L399">        estimate(result);</span>
<span class="fc" id="L400">        return result;</span>
    }

    /**
     * Estimates Dual Image of Absolute Conic (DIAC).
     *
     * @param result instance where estimated DIAC will be stored.
     * @throws LockedException                                  if estimator is locked.
     * @throws NotReadyException                                if input has not yet been provided.
     * @throws KruppaDualImageOfAbsoluteConicEstimatorException if an error
     *                                                          occurs during estimation, usually because
     *                                                          fundamental matrix corresponds to
     *                                                          degenerate camera movements, or because of
     *                                                          numerical instabilities.
     */
    public void estimate(final DualImageOfAbsoluteConic result) throws LockedException, NotReadyException,
            KruppaDualImageOfAbsoluteConicEstimatorException {
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L418">            throw new LockedException();</span>
        }
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">        if (!isReady()) {</span>
<span class="nc" id="L421">            throw new NotReadyException();</span>
        }

        try {
<span class="fc" id="L425">            locked = true;</span>

<span class="fc bfc" id="L427" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L428">                listener.onEstimateStart(this);</span>
            }

<span class="fc bfc" id="L431" title="All 2 branches covered.">            if (focalDistanceAspectRatioKnown) {</span>
<span class="fc" id="L432">                estimateKnownAspectRatio(result);</span>
            } else {
<span class="fc" id="L434">                estimateUnknownAspectRatio(result);</span>
            }

<span class="fc bfc" id="L437" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L438">                listener.onEstimateEnd(this);</span>
            }
        } finally {
<span class="fc" id="L441">            locked = false;</span>
        }
<span class="fc" id="L443">    }</span>

    /**
     * Builds a DIAC from estimated focal length components and current
     * principal point assuming zero skewness.
     *
     * @param horizontalFocalLength estimated horizontal focal length component.
     * @param verticalFocalLength   estimated vertical focal length component.
     * @param result                instance where estimated DIAC will be stored.
     * @return true if estimated DIAC is valid, false otherwise.
     */
    private boolean buildDiac(final double horizontalFocalLength, final double verticalFocalLength,
                              final DualImageOfAbsoluteConic result) {

        try {
<span class="fc" id="L458">            final var intrinsic = new PinholeCameraIntrinsicParameters(horizontalFocalLength, verticalFocalLength,</span>
                    principalPointX, principalPointY, 0.0);
<span class="fc" id="L460">            result.setFromPinholeCameraIntrinsicParameters(intrinsic);</span>

<span class="fc" id="L462">            final var m = result.asMatrix();</span>
<span class="fc" id="L463">            final var decomposer = new CholeskyDecomposer(m);</span>
<span class="fc" id="L464">            decomposer.decompose();</span>
<span class="fc" id="L465">            return decomposer.isSPD();</span>
<span class="nc" id="L466">        } catch (final AlgebraException e) {</span>
            // there are numerical instabilities
<span class="nc" id="L468">            return false;</span>
        }
    }

    /**
     * Estimates the DIAC assuming unknown aspect ratio.
     *
     * @param result instance where estimated DIAC will be stored.
     * @throws KruppaDualImageOfAbsoluteConicEstimatorException if an error
     *                                                          occurs during estimation, usually because
     *                                                          fundamental matrix corresponds to
     *                                                          degenerate camera movements, or because of
     *                                                          numerical instabilities.
     */
    private void estimateUnknownAspectRatio(final DualImageOfAbsoluteConic result)
            throws KruppaDualImageOfAbsoluteConicEstimatorException {
        try {
<span class="fc" id="L485">            final var x0 = principalPointX;</span>
<span class="fc" id="L486">            final var y0 = principalPointY;</span>

            // SVD decompose fundamental matrix
<span class="fc" id="L489">            fundamentalMatrix.normalize();</span>
<span class="fc" id="L490">            final var decomposer = new SingularValueDecomposer(fundamentalMatrix.getInternalMatrix());</span>
<span class="fc" id="L491">            decomposer.decompose();</span>

<span class="fc" id="L493">            final var sigmas = decomposer.getSingularValues();</span>
<span class="fc" id="L494">            final var u = decomposer.getU();</span>
<span class="fc" id="L495">            final var v = decomposer.getV();</span>

<span class="fc" id="L497">            final var sigma1 = sigmas[0];</span>
<span class="fc" id="L498">            final var sigma2 = sigmas[1];</span>

            // Column u1
<span class="fc" id="L501">            final var u11 = u.getElementAt(0, 0);</span>
<span class="fc" id="L502">            final var u21 = u.getElementAt(1, 0);</span>
<span class="fc" id="L503">            final var u31 = u.getElementAt(2, 0);</span>

            // Column u2
<span class="fc" id="L506">            final var u12 = u.getElementAt(0, 1);</span>
<span class="fc" id="L507">            final var u22 = u.getElementAt(1, 1);</span>
<span class="fc" id="L508">            final var u32 = u.getElementAt(2, 1);</span>

            // Column v1
<span class="fc" id="L511">            final var v11 = v.getElementAt(0, 0);</span>
<span class="fc" id="L512">            final var v21 = v.getElementAt(1, 0);</span>
<span class="fc" id="L513">            final var v31 = v.getElementAt(2, 0);</span>

            // Column v2
<span class="fc" id="L516">            final var v12 = v.getElementAt(0, 1);</span>
<span class="fc" id="L517">            final var v22 = v.getElementAt(1, 1);</span>
<span class="fc" id="L518">            final var v32 = v.getElementAt(2, 1);</span>

            // build Kruppa equations
<span class="fc" id="L521">            final var polyA = u12 * u11;</span>
<span class="fc" id="L522">            final var polyB = u22 * u21;</span>
<span class="fc" id="L523">            final var polyC = Math.pow(x0, 2.0) * u12 * u11 + x0 * y0 * u22 * u11 + x0 * u32 * u11</span>
<span class="fc" id="L524">                    + x0 * y0 * u12 * u21 + Math.pow(y0, 2.0) * u22 * u21 + y0 * u32 * u21</span>
                    + x0 * u12 * u31 + y0 * u22 * u31 + u32 * u31;
<span class="fc" id="L526">            final var polyD = Math.pow(sigma2, 2.0) * v12 * v12;</span>
<span class="fc" id="L527">            final var polyE = Math.pow(sigma2, 2.0) * v22 * v22;</span>
<span class="fc" id="L528">            final var polyF = Math.pow(sigma2 * x0, 2.0) * v12 * v12</span>
<span class="fc" id="L529">                    + Math.pow(sigma2, 2.0) * x0 * y0 * v22 * v12</span>
<span class="fc" id="L530">                    + Math.pow(sigma2, 2.0) * x0 * v32 * v12</span>
<span class="fc" id="L531">                    + Math.pow(sigma2, 2.0) * x0 * y0 * v12 * v22</span>
<span class="fc" id="L532">                    + Math.pow(sigma2 * y0, 2.0) * v22 * v22</span>
<span class="fc" id="L533">                    + Math.pow(sigma2, 2.0) * y0 * v32 * v22</span>
<span class="fc" id="L534">                    + Math.pow(sigma2, 2.0) * x0 * v12 * v32</span>
<span class="fc" id="L535">                    + Math.pow(sigma2, 2.0) * y0 * v22 * v32</span>
<span class="fc" id="L536">                    + Math.pow(sigma2, 2.0) * v32 * v32;</span>
<span class="fc" id="L537">            final var polyG = u11 * u11;</span>
<span class="fc" id="L538">            final var polyH = u21 * u21;</span>
<span class="fc" id="L539">            final var polyI = Math.pow(x0, 2.0) * u11 * u11 + x0 * y0 * u21 * u11 + x0 * u31 * u11</span>
<span class="fc" id="L540">                    + x0 * y0 * u11 * u21 + Math.pow(y0, 2.0) * u21 * u21 + y0 * u31 * u21</span>
                    + x0 * u11 * u31 + y0 * u21 * u31 + u31 * u31;
<span class="fc" id="L542">            final var polyJ = sigma1 * sigma2 * v12 * v11;</span>
<span class="fc" id="L543">            final var polyK = sigma1 * sigma2 * v22 * v21;</span>
<span class="fc" id="L544">            final var polyL = sigma1 * sigma2 * Math.pow(x0, 2.0) * v12 * v11</span>
                    + sigma1 * sigma2 * x0 * y0 * v22 * v11 + sigma1 * sigma2 * x0 * v32 * v11
                    + sigma1 * sigma2 * x0 * y0 * v12 * v21
<span class="fc" id="L547">                    + sigma1 * sigma2 * Math.pow(y0, 2.0) * v22 * v21</span>
                    + sigma1 * sigma2 * y0 * v32 * v21 + sigma1 * sigma2 * x0 * v12 * v31
                    + sigma1 * sigma2 * y0 * v22 * v31 + sigma1 * sigma2 * v32 * v31;
<span class="fc" id="L550">            final var polyM = Math.pow(sigma1, 2.0) * v11 * v11;</span>
<span class="fc" id="L551">            final var polyN = Math.pow(sigma1, 2.0) * v21 * v21;</span>
<span class="fc" id="L552">            final var polyO = Math.pow(sigma1 * x0, 2.0) * v11 * v11</span>
<span class="fc" id="L553">                    + Math.pow(sigma1, 2.0) * x0 * y0 * v21 * v11</span>
<span class="fc" id="L554">                    + Math.pow(sigma1, 2.0) * x0 * v31 * v11</span>
<span class="fc" id="L555">                    + Math.pow(sigma1, 2.0) * x0 * y0 * v11 * v21</span>
<span class="fc" id="L556">                    + Math.pow(sigma1 * y0, 2.0) * v21 * v21</span>
<span class="fc" id="L557">                    + Math.pow(sigma1, 2.0) * y0 * v31 * v21</span>
<span class="fc" id="L558">                    + Math.pow(sigma1, 2.0) * x0 * v11 * v31</span>
<span class="fc" id="L559">                    + Math.pow(sigma1, 2.0) * y0 * v21 * v31</span>
<span class="fc" id="L560">                    + Math.pow(sigma1, 2.0) * v31 * v31;</span>
<span class="fc" id="L561">            final var polyP = u12 * u12;</span>
<span class="fc" id="L562">            final var polyQ = u22 * u22;</span>
<span class="fc" id="L563">            final var polyR = Math.pow(x0, 2.0) * u12 * u12 + x0 * y0 * u22 * u12 + x0 * u32 * u12</span>
<span class="fc" id="L564">                    + x0 * y0 * u12 * u22 + Math.pow(y0, 2.0) * u22 * u22 + y0 * u32 * u22</span>
                    + x0 * u12 * u32 + y0 * u22 * u32 + u32 * u32;


<span class="fc" id="L568">            final var tmp = (polyP * polyJ + polyA * polyM) / (polyG * polyM - polyP * polyD);</span>
<span class="fc" id="L569">            final var polyS = (tmp * (polyH * polyN - polyQ * polyE) - (polyQ * polyK + polyB * polyN));</span>
<span class="fc" id="L570">            final var polyT = (tmp * (polyG * polyN + polyH * polyM - polyP * polyE - polyQ * polyD)</span>
                    - (polyP * polyK + polyQ * polyJ + polyA * polyN + polyB * polyM));
<span class="fc" id="L572">            final var polyU = (tmp * (polyG * polyO + polyM * polyI - polyP * polyF - polyD * polyR)</span>
                    - (polyP * polyL + polyJ * polyR + polyA * polyO + polyM * polyC));
<span class="fc" id="L574">            final var polyV = (tmp * (polyH * polyO + polyN * polyI - polyQ * polyF - polyE * polyR)</span>
                    - (polyQ * polyL + polyK * polyR + polyB * polyO + polyN * polyC));
<span class="fc" id="L576">            final var polyW = (tmp * (polyO * polyI - polyF * polyR) - (polyL * polyR + polyO * polyC));</span>

            // assuming that x = ax^2, y = ay^2 which are the horizontal and
            // vertical focal lengths, we obtain the following equations

            // x = (-y^2*S - y*V - W) / (y*T + U)
            // (-y^2*S - y*V - W)^2 *(-A*D - G*J) + y^2*(y*T + U)^2*(-B*E - H*K) +
            // (-y^2*S - y*V - W)*(y*T + U)*y*(-A*E - B*D - G*K - H*J) +
            // (-y^2*S - y*V - W)*(y*T + U)*(-A*F - D*C - G*L - J*I) +
            // y*(y*T + U)^2*(-B*F - E*C - H*L - K*I) +
            // (y*T + U)^2*(- F*C - L*I) = 0
            // (-y^2*S - y*V - W)^2*(G*M - P*D) + y^2*(y*T + U)^2*(H*N - Q*E) +
            // (-y^2*S - y*V - W)*(y*T + U)*y*(G*N + H*M - P*E - Q*D) +
            // (-y^2*S - y*V - W)*(y*T + U)*(G*O + M*I - P*F - D*R) +
            // y*(y*T + U)^2*(H*O + N*I - Q*F - E*R) + (y*T + U)^2*(O*I - F*R) = 0

            // where we can solve y using any of the two latter equations, and
            // then use obtained y to solve x
<span class="fc" id="L594">            final var roots = unknownAspectRatioRoots(polyA, polyB, polyC, polyD, polyE, polyF, polyG, polyH, polyI,</span>
                    polyJ, polyK, polyL, polyM, polyN, polyO, polyP, polyQ, polyR, polyS, polyT, polyU, polyV, polyW);

            // roots contain possible y values. We use only their real part
            // and find x = (-y^2*S - y*V - W) / (y*T + U)

            // pick the best x, y values that produce a positive definite DIAC
            // matrix
<span class="fc" id="L602">            final var diac = new DualImageOfAbsoluteConic(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);</span>
<span class="fc" id="L603">            var valid = false;</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">            if (roots != null) {</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">                for (final var root : roots) {</span>
<span class="fc" id="L606">                    final var y = root.getReal();</span>
<span class="fc" id="L607">                    final var x = getXFromY(y, polyS, polyT, polyU, polyV, polyW);</span>

                    // build DIAC matrix and check if it is positive definite
<span class="pc bpc" id="L610" title="1 of 4 branches missed.">                    if (x &gt;= 0.0 &amp;&amp; y &gt;= 0.0) {</span>
<span class="fc" id="L611">                        final var horizontalFocalLength = Math.sqrt(x);</span>
<span class="fc" id="L612">                        final var verticalFocalLength = Math.sqrt(y);</span>
<span class="fc" id="L613">                        valid = buildDiac(horizontalFocalLength, verticalFocalLength, diac);</span>
                    }

<span class="fc bfc" id="L616" title="All 2 branches covered.">                    if (valid) {</span>
<span class="fc" id="L617">                        break;</span>
                    }
                }
            } else {
<span class="fc" id="L621">                throw new KruppaDualImageOfAbsoluteConicEstimatorException();</span>
            }

<span class="fc bfc" id="L624" title="All 2 branches covered.">            if (valid) {</span>
                // copy to result
<span class="fc" id="L626">                result.setParameters(diac.getA(), diac.getB(), diac.getC(), diac.getD(), diac.getE(), diac.getF());</span>
            } else {
                // no valid DIAC could be found
<span class="fc" id="L629">                throw new KruppaDualImageOfAbsoluteConicEstimatorException();</span>
            }

<span class="fc" id="L632">        } catch (final KruppaDualImageOfAbsoluteConicEstimatorException ex) {</span>
<span class="fc" id="L633">            throw ex;</span>
<span class="nc" id="L634">        } catch (final Exception ex) {</span>
<span class="nc" id="L635">            throw new KruppaDualImageOfAbsoluteConicEstimatorException(ex);</span>
<span class="fc" id="L636">        }</span>
<span class="fc" id="L637">    }</span>

    /**
     * Gets x value from current y value.
     * X and y values are the squared values of estimated focal length
     * components.
     * This method is used internally when aspect ratio is not known.
     *
     * @param y y value to obtain x value from.
     * @param s internal value from Kruppa's equations.
     * @param t internal value from Kruppa's equations.
     * @param u internal value from Kruppa's equations.
     * @param v internal value from Kruppa's equations.
     * @param w internal value from Kruppa's equations.
     * @return x value.
     */
    private double getXFromY(final double y, final double s, final double t, final double u, final double v,
                             final double w) {
<span class="fc" id="L655">        return (-Math.pow(y, 2.0) * s - y * v - w) / (y * t + u);</span>
    }

    /**
     * One of Kruppa's equations expressed as a polynomial of degree 4 to solve
     * y value, which is the squared value of vertical focal length.
     * This method is only used when aspect ratio is unknown.
     *
     * @param a internal value from Kruppa's equations.
     * @param b internal value from Kruppa's equations.
     * @param c internal value from Kruppa's equations.
     * @param d internal value from Kruppa's equations.
     * @param e internal value from Kruppa's equations.
     * @param f internal value from Kruppa's equations.
     * @param g internal value from Kruppa's equations.
     * @param h internal value from Kruppa's equations.
     * @param i internal value from Kruppa's equations.
     * @param j internal value from Kruppa's equations.
     * @param k internal value from Kruppa's equations.
     * @param l internal value from Kruppa's equations.
     * @param s internal value from Kruppa's equations.
     * @param t internal value from Kruppa's equations.
     * @param u internal value from Kruppa's equations.
     * @param v internal value from Kruppa's equations.
     * @param w internal value from Kruppa's equations.
     * @return a polynomial.
     */
    private Polynomial buildPolynomial1(
            final double a, final double b, final double c, final double d,
            final double e, final double f, final double g, final double h,
            final double i, final double j, final double k, final double l,
            final double s, final double t, final double u, final double v,
            final double w) {
        // (-y^2*S - y*V - W)^2 *(-A*D - G*J) + y^2*(y*T + U)^2*(-B*E - H*K) +
        // (-y^2*S - y*V - W)*(y*T + U)*y*(-A*E - B*D - G*K - H*J) +
        // (-y^2*S - y*V - W)*(y*T + U)*(-A*F - D*C - G*L - J*I) +
        // y*(y*T + U)^2*(-B*F - E*C - H*L - K*I) + (y*T + U)^2*(- F*C - L*I) = 0

<span class="fc" id="L693">        final var result = new Polynomial(POLY_DEGREE_UNKNOWN_ASPECT_RATIO + 1);</span>

        // (-y^2*S - y*V - W)^2 *(-A*D - G*J)
<span class="fc" id="L696">        final var tmp = new Polynomial(-w, -v, -s);</span>
<span class="fc" id="L697">        final var tmp2 = new Polynomial(-w, -v, -s);</span>
<span class="fc" id="L698">        tmp.multiply(tmp2);</span>
<span class="fc" id="L699">        tmp.multiplyByScalar(-a * d - g * j);</span>
<span class="fc" id="L700">        result.add(tmp);</span>

        // y^2*(y*T + U)^2*(-B*E - H*K)
<span class="fc" id="L703">        tmp.setPolyParams(0.0, 0.0, 1.0);</span>
<span class="fc" id="L704">        tmp2.setPolyParams(u, t);</span>
<span class="fc" id="L705">        tmp.multiply(tmp2);</span>
<span class="fc" id="L706">        tmp.multiply(tmp2);</span>
<span class="fc" id="L707">        tmp.multiplyByScalar(-b * e - h * k);</span>
<span class="fc" id="L708">        result.add(tmp);</span>

        // (-y^2*S - y*V - W)*(y*T + U)*y*(-A*E - B*D - G*K - H*J)
<span class="fc" id="L711">        tmp.setPolyParams(-w, -v, -s);</span>
<span class="fc" id="L712">        tmp2.setPolyParams(u, t);</span>
<span class="fc" id="L713">        tmp.multiply(tmp2);</span>
<span class="fc" id="L714">        tmp2.setPolyParams(0.0, 1);</span>
<span class="fc" id="L715">        tmp.multiply(tmp2);</span>
<span class="fc" id="L716">        tmp.multiplyByScalar(-a * e - b * d - g * k - h * j);</span>
<span class="fc" id="L717">        result.add(tmp);</span>

        // (-y^2*S - y*V - W)*(y*T + U)*(-A*F - D*C - G*L - J*I)
<span class="fc" id="L720">        tmp.setPolyParams(-w, -v, -s);</span>
<span class="fc" id="L721">        tmp2.setPolyParams(u, t);</span>
<span class="fc" id="L722">        tmp.multiply(tmp2);</span>
<span class="fc" id="L723">        tmp.multiplyByScalar(-a * f - d * c - g * l - j * i);</span>
<span class="fc" id="L724">        result.add(tmp);</span>

        // y*(y*T + U)^2*(-B*F - E*C - H*L - K*I)
<span class="fc" id="L727">        tmp.setPolyParams(0.0, 1.0);</span>
<span class="fc" id="L728">        tmp2.setPolyParams(u, t);</span>
<span class="fc" id="L729">        tmp.multiply(tmp2);</span>
<span class="fc" id="L730">        tmp.multiply(tmp2);</span>
<span class="fc" id="L731">        tmp.multiplyByScalar(-b * f - e * c - h * l - k * i);</span>
<span class="fc" id="L732">        result.add(tmp);</span>

        // (y*T + U)^2*(- F*C - L*I)
<span class="fc" id="L735">        tmp.setPolyParams(u, t);</span>
<span class="fc" id="L736">        tmp2.setPolyParams(u, t);</span>
<span class="fc" id="L737">        tmp.multiply(tmp2);</span>
<span class="fc" id="L738">        tmp.multiplyByScalar(-f * c - l * i);</span>
<span class="fc" id="L739">        result.add(tmp);</span>

<span class="fc" id="L741">        return result;</span>
    }

    /**
     * Another of Kruppa's equations expressed as a polynomial of degree 4 to
     * solve y value, which is the squared value of vertical focal length.
     * This method is only used when aspect ratio is unknown.
     *
     * @param d internal value from Kruppa's equations.
     * @param e internal value from Kruppa's equations.
     * @param f internal value from Kruppa's equations.
     * @param g internal value from Kruppa's equations.
     * @param h internal value from Kruppa's equations.
     * @param i internal value from Kruppa's equations.
     * @param m internal value from Kruppa's equations.
     * @param n internal value from Kruppa's equations.
     * @param o internal value from Kruppa's equations.
     * @param p internal value from Kruppa's equations.
     * @param q internal value from Kruppa's equations.
     * @param r internal value from Kruppa's equations.
     * @param s internal value from Kruppa's equations.
     * @param t internal value from Kruppa's equations.
     * @param u internal value from Kruppa's equations.
     * @param v internal value from Kruppa's equations.
     * @param w internal value from Kruppa's equations.
     * @return a polynomial.
     */
    private Polynomial buildPolynomial2(
            final double d, final double e, final double f, final double g,
            final double h, final double i, final double m, final double n,
            final double o, final double p, final double q, final double r,
            final double s, final double t, final double u, final double v,
            final double w) {
        // (-y^2*S - y*V - W)^2*(G*M - P*D) + y^2*(y*T + U)^2*(H*N - Q*E) +
        // (-y^2*S - y*V - W)*(y*T + U)*y*(G*N + H*M - P*E - Q*D) +
        // (-y^2*S - y*V - W)*(y*T + U)*(G*O + M*I - P*F - D*R) +
        // y*(y*T + U)^2*(H*O + N*I - Q*F - E*R) + (y*T + U)^2*(O*I - F*R) = 0
<span class="nc" id="L778">        final var result = new Polynomial(POLY_DEGREE_UNKNOWN_ASPECT_RATIO + 1);</span>

        // (-y^2*S - y*V - W)^2*(G*M - P*D)
<span class="nc" id="L781">        final var tmp = new Polynomial(-w, -v, -s);</span>
<span class="nc" id="L782">        final var tmp2 = new Polynomial(-w, -v, -s);</span>
<span class="nc" id="L783">        tmp.multiply(tmp2);</span>
<span class="nc" id="L784">        tmp.multiplyByScalar(g * m - p * d);</span>
<span class="nc" id="L785">        result.add(tmp);</span>

        // y^2*(y*T + U)^2*(H*N - Q*E)
<span class="nc" id="L788">        tmp.setPolyParams(0.0, 0.0, 1.0);</span>
<span class="nc" id="L789">        tmp2.setPolyParams(u, t);</span>
<span class="nc" id="L790">        tmp.multiply(tmp2);</span>
<span class="nc" id="L791">        tmp.multiply(tmp2);</span>
<span class="nc" id="L792">        tmp.multiplyByScalar(h * n - q * e);</span>
<span class="nc" id="L793">        result.add(tmp);</span>

        // (-y^2*S - y*V - W)*(y*T + U)*y*(G*N + H*M - P*E - Q*D)
<span class="nc" id="L796">        tmp.setPolyParams(-w, -v, -s);</span>
<span class="nc" id="L797">        tmp2.setPolyParams(u, t);</span>
<span class="nc" id="L798">        tmp.multiply(tmp2);</span>
<span class="nc" id="L799">        tmp2.setPolyParams(0.0, 1.0);</span>
<span class="nc" id="L800">        tmp.multiply(tmp2);</span>
<span class="nc" id="L801">        tmp.multiplyByScalar(g * n + h * m - p * e - q * d);</span>
<span class="nc" id="L802">        result.add(tmp);</span>

        // (-y^2*S - y*V - W)*(y*T + U)*(G*O + M*I - P*F - D*R)
<span class="nc" id="L805">        tmp.setPolyParams(-w, -v, -s);</span>
<span class="nc" id="L806">        tmp2.setPolyParams(u, t);</span>
<span class="nc" id="L807">        tmp.multiply(tmp2);</span>
<span class="nc" id="L808">        tmp.multiplyByScalar(g * o + m * i - p * f - d * r);</span>
<span class="nc" id="L809">        result.add(tmp);</span>

        // y*(y*T + U)^2*(H*O + N*I - Q*F - E*R)
<span class="nc" id="L812">        tmp.setPolyParams(0.0, 1.0);</span>
<span class="nc" id="L813">        tmp2.setPolyParams(u, t);</span>
<span class="nc" id="L814">        tmp.multiply(tmp2);</span>
<span class="nc" id="L815">        tmp.multiplyByScalar(h * o + n * i - q * f - e * r);</span>
<span class="nc" id="L816">        result.add(tmp);</span>

        // (y*T + U)^2*(O*I - F*R)
<span class="nc" id="L819">        tmp.setPolyParams(u, t);</span>
<span class="nc" id="L820">        tmp2.setPolyParams(u, t);</span>
<span class="nc" id="L821">        tmp.multiply(tmp2);</span>
<span class="nc" id="L822">        tmp.multiplyByScalar(o * i - f * r);</span>
<span class="nc" id="L823">        result.add(tmp);</span>

<span class="nc" id="L825">        return result;</span>
    }

    /**
     * Estimates the DIAC assuming known aspect ratio.
     *
     * @param result instance where estimated DIAC will be stored.
     * @throws KruppaDualImageOfAbsoluteConicEstimatorException if an error
     *                                                          occurs during estimation, usually because
     *                                                          fundamental matrix corresponds to
     *                                                          degenerate camera movements, or because of
     *                                                          numerical instabilities.
     */
    private void estimateKnownAspectRatio(final DualImageOfAbsoluteConic result)
            throws KruppaDualImageOfAbsoluteConicEstimatorException {
        try {
<span class="fc" id="L841">            final var x0 = principalPointX;</span>
<span class="fc" id="L842">            final var y0 = principalPointY;</span>

            // SVD decompose fundamental matrix
<span class="fc" id="L845">            fundamentalMatrix.normalize();</span>
<span class="fc" id="L846">            final var decomposer = new SingularValueDecomposer(fundamentalMatrix.getInternalMatrix());</span>
<span class="fc" id="L847">            decomposer.decompose();</span>

<span class="fc" id="L849">            final var sigmas = decomposer.getSingularValues();</span>
<span class="fc" id="L850">            final var u = decomposer.getU();</span>
<span class="fc" id="L851">            final var v = decomposer.getV();</span>

<span class="fc" id="L853">            final var sigma1 = sigmas[0];</span>
<span class="fc" id="L854">            final var sigma2 = sigmas[1];</span>

            // Column u1
<span class="fc" id="L857">            final var u11 = u.getElementAt(0, 0);</span>
<span class="fc" id="L858">            final var u21 = u.getElementAt(1, 0);</span>
<span class="fc" id="L859">            final var u31 = u.getElementAt(2, 0);</span>

            // Column u2
<span class="fc" id="L862">            final var u12 = u.getElementAt(0, 1);</span>
<span class="fc" id="L863">            final var u22 = u.getElementAt(1, 1);</span>
<span class="fc" id="L864">            final var u32 = u.getElementAt(2, 1);</span>

            // Column v1
<span class="fc" id="L867">            final var v11 = v.getElementAt(0, 0);</span>
<span class="fc" id="L868">            final var v21 = v.getElementAt(1, 0);</span>
<span class="fc" id="L869">            final var v31 = v.getElementAt(2, 0);</span>

            // Column v2
<span class="fc" id="L872">            final var v12 = v.getElementAt(0, 1);</span>
<span class="fc" id="L873">            final var v22 = v.getElementAt(1, 1);</span>
<span class="fc" id="L874">            final var v32 = v.getElementAt(2, 1);</span>

            // build Kruppa equations
<span class="fc" id="L877">            final var polyA = u12 * u11;</span>
<span class="fc" id="L878">            final var polyB = u22 * u21;</span>
<span class="fc" id="L879">            final var polyC = Math.pow(x0, 2.0) * u12 * u11 + x0 * y0 * u22 * u11 + x0 * u32 * u11</span>
<span class="fc" id="L880">                    + x0 * y0 * u12 * u21 + Math.pow(y0, 2.0) * u22 * u21 + y0 * u32 * u21</span>
                    + x0 * u12 * u31 + y0 * u22 * u31 + u32 * u31;
<span class="fc" id="L882">            final var polyD = Math.pow(sigma2, 2.0) * v12 * v12;</span>
<span class="fc" id="L883">            final var polyE = Math.pow(sigma2, 2.0) * v22 * v22;</span>
<span class="fc" id="L884">            final var polyF = Math.pow(sigma2 * x0, 2.0) * v12 * v12</span>
<span class="fc" id="L885">                    + Math.pow(sigma2, 2.0) * x0 * y0 * v22 * v12</span>
<span class="fc" id="L886">                    + Math.pow(sigma2, 2.0) * x0 * v32 * v12</span>
<span class="fc" id="L887">                    + Math.pow(sigma2, 2.0) * x0 * y0 * v12 * v22</span>
<span class="fc" id="L888">                    + Math.pow(sigma2 * y0, 2.0) * v22 * v22</span>
<span class="fc" id="L889">                    + Math.pow(sigma2, 2.0) * y0 * v32 * v22</span>
<span class="fc" id="L890">                    + Math.pow(sigma2, 2.0) * x0 * v12 * v32</span>
<span class="fc" id="L891">                    + Math.pow(sigma2, 2.0) * y0 * v22 * v32</span>
<span class="fc" id="L892">                    + Math.pow(sigma2, 2.0) * v32 * v32;</span>
<span class="fc" id="L893">            final var polyG = u11 * u11;</span>
<span class="fc" id="L894">            final var polyH = u21 * u21;</span>
<span class="fc" id="L895">            final var polyI = Math.pow(x0, 2.0) * u11 * u11 + x0 * y0 * u21 * u11 + x0 * u31 * u11</span>
<span class="fc" id="L896">                    + x0 * y0 * u11 * u21 + Math.pow(y0, 2.0) * u21 * u21 + y0 * u31 * u21</span>
                    + x0 * u11 * u31 + y0 * u21 * u31 + u31 * u31;
<span class="fc" id="L898">            final var polyJ = sigma1 * sigma2 * v12 * v11;</span>
<span class="fc" id="L899">            final var polyK = sigma1 * sigma2 * v22 * v21;</span>
<span class="fc" id="L900">            final var polyL = sigma1 * sigma2 * Math.pow(x0, 2.0) * v12 * v11</span>
                    + sigma1 * sigma2 * x0 * y0 * v22 * v11 + sigma1 * sigma2 * x0 * v32 * v11
                    + sigma1 * sigma2 * x0 * y0 * v12 * v21
<span class="fc" id="L903">                    + sigma1 * sigma2 * Math.pow(y0, 2.0) * v22 * v21</span>
                    + sigma1 * sigma2 * y0 * v32 * v21 + sigma1 * sigma2 * x0 * v12 * v31
                    + sigma1 * sigma2 * y0 * v22 * v31 + sigma1 * sigma2 * v32 * v31;
<span class="fc" id="L906">            final var polyM = Math.pow(sigma1, 2.0) * v11 * v11;</span>
<span class="fc" id="L907">            final var polyN = Math.pow(sigma1, 2.0) * v21 * v21;</span>
<span class="fc" id="L908">            final var polyO = Math.pow(sigma1 * x0, 2.0) * v11 * v11</span>
<span class="fc" id="L909">                    + Math.pow(sigma1, 2.0) * x0 * y0 * v21 * v11</span>
<span class="fc" id="L910">                    + Math.pow(sigma1, 2.0) * x0 * v31 * v11</span>
<span class="fc" id="L911">                    + Math.pow(sigma1, 2.0) * x0 * y0 * v11 * v21</span>
<span class="fc" id="L912">                    + Math.pow(sigma1 * y0, 2.0) * v21 * v21</span>
<span class="fc" id="L913">                    + Math.pow(sigma1, 2.0) * y0 * v31 * v21</span>
<span class="fc" id="L914">                    + Math.pow(sigma1, 2.0) * x0 * v11 * v31</span>
<span class="fc" id="L915">                    + Math.pow(sigma1, 2.0) * y0 * v21 * v31</span>
<span class="fc" id="L916">                    + Math.pow(sigma1, 2.0) * v31 * v31;</span>
<span class="fc" id="L917">            final var polyP = u12 * u12;</span>
<span class="fc" id="L918">            final var polyQ = u22 * u22;</span>
<span class="fc" id="L919">            final var polyR = Math.pow(x0, 2.0) * u12 * u12 + x0 * y0 * u22 * u12 + x0 * u32 * u12</span>
<span class="fc" id="L920">                    + x0 * y0 * u12 * u22 + Math.pow(y0, 2.0) * u22 * u22 + y0 * u32 * u22</span>
                    + x0 * u12 * u32 + y0 * u22 * u32 + u32 * u32;

            // try to solve any of Kruppa's equations
<span class="fc" id="L924">            final var roots = knownAspectRatioRoots(polyA, polyB, polyC, polyD, polyE, polyF, polyG, polyH, polyI,</span>
                    polyJ, polyK, polyL, polyM, polyN, polyO, polyP, polyQ, polyR);

            // roots contain possible x values. We use only their real part

            // pick the best x, y values that produce a positive definite DIAC
            // matrix
<span class="fc" id="L931">            final var diac = new DualImageOfAbsoluteConic(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);</span>
<span class="fc" id="L932">            var valid = false;</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">            if (roots != null) {</span>
<span class="fc" id="L934">                final var r = focalDistanceAspectRatio;</span>
<span class="fc" id="L935">                final var r2 = r * r;</span>
<span class="fc bfc" id="L936" title="All 2 branches covered.">                for (final var root : roots) {</span>
<span class="fc" id="L937">                    final var x = root.getReal();</span>
<span class="fc" id="L938">                    final var y = r2 * x;</span>

                    // build DIAC matrix and check if it is positive definite
<span class="pc bpc" id="L941" title="1 of 4 branches missed.">                    if (x &gt;= 0.0 &amp;&amp; y &gt;= 0.0) {</span>
<span class="fc" id="L942">                        final var horizontalFocalLength = Math.sqrt(x);</span>
<span class="fc" id="L943">                        final var verticalFocalLength = Math.sqrt(y);</span>
<span class="fc" id="L944">                        valid = buildDiac(horizontalFocalLength, verticalFocalLength, diac);</span>
                    }

<span class="fc bfc" id="L947" title="All 2 branches covered.">                    if (valid) {</span>
<span class="fc" id="L948">                        break;</span>
                    }
                }
<span class="fc" id="L951">            } else {</span>
<span class="fc" id="L952">                throw new KruppaDualImageOfAbsoluteConicEstimatorException();</span>
            }

<span class="fc bfc" id="L955" title="All 2 branches covered.">            if (valid) {</span>
                // copy to result
<span class="fc" id="L957">                result.setParameters(diac.getA(), diac.getB(), diac.getC(), diac.getD(), diac.getE(), diac.getF());</span>
            } else {
                // no valid DIAC could be found
<span class="fc" id="L960">                throw new KruppaDualImageOfAbsoluteConicEstimatorException();</span>
            }

<span class="fc" id="L963">        } catch (final KruppaDualImageOfAbsoluteConicEstimatorException ex) {</span>
<span class="fc" id="L964">            throw ex;</span>
<span class="nc" id="L965">        } catch (final Exception ex) {</span>
<span class="nc" id="L966">            throw new KruppaDualImageOfAbsoluteConicEstimatorException(ex);</span>
<span class="fc" id="L967">        }</span>
<span class="fc" id="L968">    }</span>

    /**
     * Another of Kruppa's equations expressed as a polynomial of degree 2 to
     * solve x value, which is the squared value of horizontal focal length.
     * This method is only used when aspect ratio is known.
     *
     * @param a internal value from Kruppa's equations.
     * @param b internal value from Kruppa's equations.
     * @param c internal value from Kruppa's equations.
     * @param d internal value from Kruppa's equations.
     * @param e internal value from Kruppa's equations.
     * @param f internal value from Kruppa's equations.
     * @param g internal value from Kruppa's equations.
     * @param h internal value from Kruppa's equations.
     * @param i internal value from Kruppa's equations.
     * @param j internal value from Kruppa's equations.
     * @param k internal value from Kruppa's equations.
     * @param l internal value from Kruppa's equations.
     * @return a polynomial.
     */
    private Polynomial buildPolynomial3(
            final double a, final double b, final double c, final double d,
            final double e, final double f, final double g, final double h,
            final double i, final double j, final double k, final double l) {

        // x^2*((-A*D - G*J) + r^4*(-B*E - H*K) + r^2*(-A*E - B*D - G*K - H*J)) +
        // x*((-A*F - D*C - G*L - J*I) + r^2*(-B*F - E*C - H*L - K*I)) +
        // (- F*C - L*I) = 0
<span class="fc" id="L997">        final var r = focalDistanceAspectRatio;</span>
<span class="fc" id="L998">        final var r2 = r * r;</span>
<span class="fc" id="L999">        final var r4 = r2 * r2;</span>
<span class="fc" id="L1000">        return new Polynomial(-f * c - l * i,</span>
                (-a * f - d * c - g * l - j * i) + r2 * (-b * f - e * c - h * l - k * i),
                ((-a * d - g * j) + r4 * (-b * e - h * k) + r2 * (-a * e - b * d - g * k - h * j)));
    }

    /**
     * Another of Kruppa's equations expressed as a polynomial of degree 2 to
     * solve x value, which is the squared value of horizontal focal length.
     * This method is only used when aspect ratio is known.
     *
     * @param d internal value from Kruppa's equations.
     * @param e internal value from Kruppa's equations.
     * @param f internal value from Kruppa's equations.
     * @param g internal value from Kruppa's equations.
     * @param h internal value from Kruppa's equations.
     * @param i internal value from Kruppa's equations.
     * @param m internal value from Kruppa's equations.
     * @param n internal value from Kruppa's equations.
     * @param o internal value from Kruppa's equations.
     * @param p internal value from Kruppa's equations.
     * @param q internal value from Kruppa's equations.
     * @param r internal value from Kruppa's equations.
     * @return a polynomial.
     */
    private Polynomial buildPolynomial4(
            final double d, final double e, final double f, final double g,
            final double h, final double i, final double m, final double n,
            final double o, final double p, final double q, final double r) {

        // x^2*((G*M - P*D) + r^4*(H*N - Q*E) + r^2*(G*N + H*M - P*E - Q*D)) +
        // x*((G*O + M*I - P*F - D*R) + r^2*(H*O + N*I - Q*F - E*R)) +
        // (O*I - F*R) = 0
<span class="nc" id="L1032">        final var r1 = focalDistanceAspectRatio;</span>
<span class="nc" id="L1033">        final var r2 = r1 * r1;</span>
<span class="nc" id="L1034">        final var r4 = r2 * r2;</span>
<span class="nc" id="L1035">        return new Polynomial(o * i - f * r,</span>
                (g * o + m * i - p * f - d * r) + r2 * (h * o + n * i - q * f - e * r),
                (g * m - p * d) + r4 * (h * n - q * e) + r2 * (g * n + h * m - p * e - q * d));
    }

    /**
     * Another of Kruppa's equations expressed as a polynomial of degree 2 to
     * solve x value, which is the squared value of horizontal focal length.
     * This method is only used when aspect ratio is known.
     *
     * @param a internal value from Kruppa's equations.
     * @param b internal value from Kruppa's equations.
     * @param c internal value from Kruppa's equations.
     * @param j internal value from Kruppa's equations.
     * @param k internal value from Kruppa's equations.
     * @param l internal value from Kruppa's equations.
     * @param m internal value from Kruppa's equations.
     * @param n internal value from Kruppa's equations.
     * @param o internal value from Kruppa's equations.
     * @param p internal value from Kruppa's equations.
     * @param q internal value from Kruppa's equations.
     * @param r internal value from Kruppa's equations.
     * @return a polynomial.
     */
    private Polynomial buildPolynomial5(
            final double a, final double b, final double c, final double j,
            final double k, final double l, final double m, final double n,
            final double o, final double p, final double q, final double r) {

        // x^2*((P*J + A*M) + r^4*(Q*K + B*N) + r^2*(P*K + Q*J + A*N + B*M)) +
        // x*((P*L + J*R + A*O + M*C) + r^2*(Q*L + K*R + B*O + N*C)) +
        // (L*R + O*C) = 0
<span class="nc" id="L1067">        final var r1 = focalDistanceAspectRatio;</span>
<span class="nc" id="L1068">        final var r2 = r1 * r1;</span>
<span class="nc" id="L1069">        final var r4 = r2 * r2;</span>
<span class="nc" id="L1070">        return new Polynomial(l * r + o * c,</span>
                (p * l + j * r + a * o + m * c) + r2 * (q * l + k * r + b * o + n * c),
                (p * j + a * m) + r4 * (q * k + b * n) + r2 * (p * k + q * j + a * n + b * m));
    }

    /**
     * Solves Kruppa's equations when aspect ratio is unknown
     *
     * @param polyA A parameter of Kruppa's polynomial equation.
     * @param polyB B parameter of Kruppa's polynomial equation.
     * @param polyC C parameter of Kruppa's polynomial equation.
     * @param polyD D parameter of Kruppa's polynomial equation.
     * @param polyE E parameter of Kruppa's polynomial equation.
     * @param polyF F parameter of Kruppa's polynomial equation.
     * @param polyG G parameter of Kruppa's polynomial equation.
     * @param polyH H parameter of Kruppa's polynomial equation.
     * @param polyI I parameter of Kruppa's polynomial equation.
     * @param polyJ J parameter of Kruppa's polynomial equation.
     * @param polyK K parameter of Kruppa's polynomial equation.
     * @param polyL L parameter of Kruppa's polynomial equation.
     * @param polyM M parameter of Kruppa's polynomial equation.
     * @param polyN N parameter of Kruppa's polynomial equation.
     * @param polyO O parameter of Kruppa's polynomial equation.
     * @param polyP P parameter of Kruppa's polynomial equation.
     * @param polyQ Q parameter of Kruppa's polynomial equation.
     * @param polyR R parameter of Kruppa's polynomial equation.
     * @param polyS S parameter of Kruppa's polynomial equation.
     * @param polyT T parameter of Kruppa's polynomial equation.
     * @param polyU U parameter of Kruppa's polynomial equation.
     * @param polyV V parameter of Kruppa's polynomial equation.
     * @param polyW W parameter of Kruppa's polynomial equation.
     * @return roots solving Kruppa's equations.
     * @throws NumericalException if there are numerical instabilities.
     */
    private Complex[] unknownAspectRatioRoots(
            final double polyA, final double polyB, final double polyC, final double polyD,
            final double polyE, final double polyF, final double polyG, final double polyH,
            final double polyI, final double polyJ, final double polyK, final double polyL,
            final double polyM, final double polyN, final double polyO, final double polyP,
            final double polyQ, final double polyR, final double polyS, final double polyT,
            final double polyU, final double polyV, final double polyW) throws NumericalException {
        Complex[] roots;
        try {
<span class="fc" id="L1113">            final var poly1 = buildPolynomial1(polyA, polyB, polyC, polyD, polyE, polyF, polyG,</span>
                    polyH, polyI, polyJ, polyK, polyL, polyS, polyT, polyU, polyV, polyW);
<span class="fc" id="L1115">            roots = poly1.getRoots();</span>
<span class="nc" id="L1116">        } catch (final NumericalException ex1) {</span>
            // if solution for poly1 fails, try with second polynomial
<span class="nc" id="L1118">            final var poly2 = buildPolynomial2(polyD, polyE, polyF, polyG, polyH, polyI,</span>
                    polyM, polyN, polyO, polyP, polyQ, polyR, polyS, polyT, polyU, polyV, polyW);
<span class="nc" id="L1120">            roots = poly2.getRoots();</span>
<span class="fc" id="L1121">        }</span>

<span class="fc" id="L1123">        return roots;</span>
    }

    /**
     * Solves Kruppa's equations when aspect ratio is known
     *
     * @param polyA A parameter of Kruppa's polynomial equation.
     * @param polyB B parameter of Kruppa's polynomial equation.
     * @param polyC C parameter of Kruppa's polynomial equation.
     * @param polyD D parameter of Kruppa's polynomial equation.
     * @param polyE E parameter of Kruppa's polynomial equation.
     * @param polyF F parameter of Kruppa's polynomial equation.
     * @param polyG G parameter of Kruppa's polynomial equation.
     * @param polyH H parameter of Kruppa's polynomial equation.
     * @param polyI I parameter of Kruppa's polynomial equation.
     * @param polyJ J parameter of Kruppa's polynomial equation.
     * @param polyK K parameter of Kruppa's polynomial equation.
     * @param polyL L parameter of Kruppa's polynomial equation.
     * @param polyM M parameter of Kruppa's polynomial equation.
     * @param polyN N parameter of Kruppa's polynomial equation.
     * @param polyO O parameter of Kruppa's polynomial equation.
     * @param polyP P parameter of Kruppa's polynomial equation.
     * @param polyQ Q parameter of Kruppa's polynomial equation.
     * @param polyR R parameter of Kruppa's polynomial equation.
     * @return roots solving Kruppa's equations.
     * @throws NumericalException if there are numerical instabilities.
     */
    private Complex[] knownAspectRatioRoots(
            final double polyA, final double polyB, final double polyC, final double polyD,
            final double polyE, final double polyF, final double polyG, final double polyH,
            final double polyI, final double polyJ, final double polyK, final double polyL,
            final double polyM, final double polyN, final double polyO, final double polyP,
            final double polyQ, final double polyR) throws NumericalException {
        Complex[] roots;
        try {
<span class="fc" id="L1158">            final var poly3 = buildPolynomial3(polyA, polyB, polyC, polyD, polyE, polyF, polyG,</span>
                    polyH, polyI, polyJ, polyK, polyL);
<span class="fc" id="L1160">            roots = poly3.getRoots();</span>
<span class="nc" id="L1161">        } catch (final NumericalException e3) {</span>
            try {
                // if solution for poly3 fails, try with 4th polynomial
<span class="nc" id="L1164">                final var poly4 = buildPolynomial4(polyD, polyE, polyF, polyG, polyH,</span>
                        polyI, polyM, polyN, polyO, polyP, polyQ, polyR);
<span class="nc" id="L1166">                roots = poly4.getRoots();</span>
<span class="nc" id="L1167">            } catch (final NumericalException e4) {</span>
<span class="nc" id="L1168">                final var poly5 = buildPolynomial5(polyA, polyB, polyC,</span>
                        polyJ, polyK, polyL, polyM, polyN, polyO, polyP, polyQ, polyR);
<span class="nc" id="L1170">                roots = poly5.getRoots();</span>
<span class="nc" id="L1171">            }</span>
<span class="fc" id="L1172">        }</span>

<span class="fc" id="L1174">        return roots;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>