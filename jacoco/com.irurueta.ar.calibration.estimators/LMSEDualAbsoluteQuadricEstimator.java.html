<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LMSEDualAbsoluteQuadricEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-ar</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.ar.calibration.estimators</a> &gt; <span class="el_source">LMSEDualAbsoluteQuadricEstimator.java</span></div><h1>LMSEDualAbsoluteQuadricEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2016 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.ar.calibration.estimators;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.SingularValueDecomposer;
import com.irurueta.ar.calibration.DualAbsoluteQuadric;
import com.irurueta.geometry.BaseQuadric;
import com.irurueta.geometry.PinholeCamera;
import com.irurueta.geometry.estimators.LockedException;
import com.irurueta.geometry.estimators.NotReadyException;
import com.irurueta.numerical.NumericalException;

import java.util.List;

/**
 * Implementation of a Dual Absolute Quadric estimator using an LMSE (Least Mean
 * Squared Error) solution for provided pinhole cameras.
 * This implementation assumes that:
 * - cameras are arbitrary (usually the initial camera is the identity and must
 * be discarded) as it creates a numerical degeneracy.
 * - all provided cameras have the same intrinsic parameters.
 * - it is assumed that skewness is zero, the principal point is at the center
 * of the image plane (zero), and both horizontal and vertical focal planes are
 * equal.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class LMSEDualAbsoluteQuadricEstimator extends DualAbsoluteQuadricEstimator {

    /**
     * Indicates if by default an LMSE (the Least Mean Square Error) solution is
     * allowed if more pinhole cameras than the minimum are provided.
     */
    public static final boolean DEFAULT_ALLOW_LMSE_SOLUTION = false;

    /**
     * Indicates if by default an LMSE (the Least Mean Square Error) solution is
     * allowed if more pinhole cameras than the minimum are provided.
     */
    private boolean allowLMSESolution;

    /**
     * Constructor.
     */
    public LMSEDualAbsoluteQuadricEstimator() {
<span class="fc" id="L60">        super();</span>
<span class="fc" id="L61">        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;</span>
<span class="fc" id="L62">    }</span>

    /**
     * Constructor with listener.
     *
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     */
    public LMSEDualAbsoluteQuadricEstimator(final DualAbsoluteQuadricEstimatorListener listener) {
<span class="fc" id="L71">        super(listener);</span>
<span class="fc" id="L72">        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;</span>
<span class="fc" id="L73">    }</span>

    /**
     * Constructor.
     *
     * @param cameras list of cameras used to estimate the Dual Absolute Quadric
     *                (DAQ).
     * @throws IllegalArgumentException if list of cameras is null or invalid
     *                                  for default constraints.
     */
    public LMSEDualAbsoluteQuadricEstimator(final List&lt;PinholeCamera&gt; cameras) {
<span class="fc" id="L84">        super(cameras);</span>
<span class="fc" id="L85">        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;</span>
<span class="fc" id="L86">    }</span>

    /**
     * Constructor.
     *
     * @param cameras  list of cameras used to estimate the Dual Absolute Quadric
     *                 (DAQ).
     * @param listener listener to be notified of events such as when estimation
     *                 starts, ends or estimation progress changes.
     * @throws IllegalArgumentException if list of cameras is null or invalid
     *                                  for default constraints.
     */
    public LMSEDualAbsoluteQuadricEstimator(
            final List&lt;PinholeCamera&gt; cameras, final DualAbsoluteQuadricEstimatorListener listener) {
<span class="fc" id="L100">        super(cameras, listener);</span>
<span class="fc" id="L101">        allowLMSESolution = DEFAULT_ALLOW_LMSE_SOLUTION;</span>
<span class="fc" id="L102">    }</span>

    /**
     * Indicates if an LMSE (the Least Mean Square Error) solution is allowed if
     * more pinhole cameras than the minimum are provided. If false, the
     * exceeding correspondences will be ignored and only the 2 first ones
     * will be used.
     *
     * @return true if LMSE solution is allowed, false otherwise.
     */
    public boolean isLMSESolutionAllowed() {
<span class="fc" id="L113">        return allowLMSESolution;</span>
    }

    /**
     * Specifies if an LMSE (the Least Mean Square Error) solution is allowed if
     * more pinhole cameras than the minimum are provided. If false, the
     * exceeding correspondences will be ignored and only the 2 first ones
     * will be used.
     *
     * @param allowed true if LMSE solution is allowed, false otherwise.
     * @throws LockedException if estimator is locked.
     */
    public void setLMSESolutionAllowed(final boolean allowed) throws LockedException {
<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L127">            throw new LockedException();</span>
        }
<span class="fc" id="L129">        allowLMSESolution = allowed;</span>
<span class="fc" id="L130">    }</span>

    /**
     * Indicates whether current constraints are enough to start the estimation.
     * In order to obtain a linear solution for the DAQ estimation, we need at
     * least the principal point at origin constraint.
     *
     * @return true if constraints are valid, false otherwise.
     */
    @Override
    public boolean areValidConstraints() {
<span class="fc" id="L141">        final var valid = super.areValidConstraints();</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (!valid) {</span>
<span class="fc" id="L143">            return false;</span>
        }

<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (allowLMSESolution) {</span>
<span class="fc bfc" id="L147" title="All 4 branches covered.">            return !(focalDistanceAspectRatioKnown &amp;&amp; singularityEnforced);</span>
        } else {
<span class="fc" id="L149">            return true;</span>
        }
    }


    /**
     * Estimates the Dual Absolute Quadric using provided cameras.
     *
     * @param result instance where estimated Dual Absolute Quadric (DAQ) will
     *               be stored.
     * @throws LockedException                       if estimator is locked.
     * @throws NotReadyException                     if no valid input data has already been
     *                                               provided.
     * @throws DualAbsoluteQuadricEstimatorException if an error occurs during
     *                                               estimation, usually because input data is not valid or
     *                                               numerically unstable.
     */
    @Override
    public void estimate(final DualAbsoluteQuadric result) throws LockedException, NotReadyException,
            DualAbsoluteQuadricEstimatorException {

<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (isLocked()) {</span>
<span class="fc" id="L171">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (!isReady()) {</span>
<span class="fc" id="L174">            throw new NotReadyException();</span>
        }

        try {
<span class="fc" id="L178">            locked = true;</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L180">                listener.onEstimateStart(this);</span>
            }

<span class="pc bpc" id="L183" title="1 of 2 branches missed.">            if (principalPointAtOrigin) {</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                if (zeroSkewness) {</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">                    if (focalDistanceAspectRatioKnown) {</span>
<span class="fc" id="L186">                        estimateZeroSkewnessPrincipalPointAtOriginAndKnownFocalDistanceAspectRatio(result);</span>
                    } else {
<span class="fc" id="L188">                        estimateZeroSkewnessAndPrincipalPointAtOrigin(result);</span>
                    }
                } else {
<span class="fc" id="L191">                    estimatePrincipalPointAtOrigin(result);</span>
                }
            }

<span class="fc bfc" id="L195" title="All 2 branches covered.">            if (listener != null) {</span>
<span class="fc" id="L196">                listener.onEstimateEnd(this);</span>
            }
        } finally {
<span class="fc" id="L199">            locked = false;</span>
        }
<span class="fc" id="L201">    }</span>

    /**
     * Returns type of Dual Absolute Quadric estimator.
     *
     * @return type of DAQ estimator.
     */
    @Override
    public DualAbsoluteQuadricEstimatorType getType() {
<span class="fc" id="L210">        return DualAbsoluteQuadricEstimatorType.LMSE_DUAL_ABSOLUTE_QUADRIC_ESTIMATOR;</span>
    }

    /**
     * Gets minimum number of equations required to find a solution.
     *
     * @return minimum number of equations required to find a solution.
     */
    private int getMinRequiredEquations() {
<span class="fc bfc" id="L219" title="All 2 branches covered.">        return singularityEnforced ? MIN_REQUIRED_EQUATIONS - 1 : MIN_REQUIRED_EQUATIONS;</span>
    }

    /**
     * Estimates Dual Absolute Quadric (DAQ) assuming that skewness is zero,
     * principal point is located at origin of coordinates and that aspect ratio
     * of focal distances is known.
     *
     * @param result instance where resulting estimated Dual Absolute Quadric
     *               will be stored.
     * @throws DualAbsoluteQuadricEstimatorException if an error occurs during
     *                                               estimation, usually because repeated cameras are
     *                                               provided, or cameras corresponding to critical motion
     *                                               sequences such as pure parallel translations are
     *                                               provided, where no additional data is really provided.
     */
    private void estimateZeroSkewnessPrincipalPointAtOriginAndKnownFocalDistanceAspectRatio(
            final DualAbsoluteQuadric result) throws DualAbsoluteQuadricEstimatorException {
        try {
<span class="fc" id="L238">            final var nCams = cameras.size();</span>

            final Matrix a;
<span class="fc bfc" id="L241" title="All 2 branches covered.">            if (isLMSESolutionAllowed()) {</span>
<span class="fc" id="L242">                a = new Matrix(4 * nCams, BaseQuadric.N_PARAMS);</span>
            } else {
<span class="fc bfc" id="L244" title="All 2 branches covered.">                a = new Matrix(singularityEnforced ? 8 : 12, BaseQuadric.N_PARAMS);</span>
            }

            Matrix cameraMatrix;
            double p11;
            double p12;
            double p13;
            double p14;
            double p21;
            double p22;
            double p23;
            double p24;
            double p31;
            double p32;
            double p33;
            double p34;
<span class="fc" id="L260">            var eqCounter = 0;</span>
<span class="fc" id="L261">            final var minReqEqs = getMinRequiredEquations();</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">            for (final var camera : cameras) {</span>

                // normalize cameras to increase accuracy
<span class="fc" id="L265">                camera.normalize();</span>

<span class="fc" id="L267">                cameraMatrix = camera.getInternalMatrix();</span>

<span class="fc" id="L269">                p11 = cameraMatrix.getElementAt(0, 0);</span>
<span class="fc" id="L270">                p21 = cameraMatrix.getElementAt(1, 0);</span>
<span class="fc" id="L271">                p31 = cameraMatrix.getElementAt(2, 0);</span>

<span class="fc" id="L273">                p12 = cameraMatrix.getElementAt(0, 1);</span>
<span class="fc" id="L274">                p22 = cameraMatrix.getElementAt(1, 1);</span>
<span class="fc" id="L275">                p32 = cameraMatrix.getElementAt(2, 1);</span>

<span class="fc" id="L277">                p13 = cameraMatrix.getElementAt(0, 2);</span>
<span class="fc" id="L278">                p23 = cameraMatrix.getElementAt(1, 2);</span>
<span class="fc" id="L279">                p33 = cameraMatrix.getElementAt(2, 2);</span>

<span class="fc" id="L281">                p14 = cameraMatrix.getElementAt(0, 3);</span>
<span class="fc" id="L282">                p24 = cameraMatrix.getElementAt(1, 3);</span>
<span class="fc" id="L283">                p34 = cameraMatrix.getElementAt(2, 3);</span>

                // 1st row
<span class="fc" id="L286">                fill2ndRowAnd1stRowEquation(p11, p21, p12, p22, p13, p23, p14, p24, a, eqCounter);</span>
<span class="fc" id="L287">                eqCounter++;</span>

                // 2nd row
<span class="fc" id="L290">                fill3rdRowAnd1stRowEquation(p11, p31, p12, p32, p13, p33, p14, p34, a, eqCounter);</span>
<span class="fc" id="L291">                eqCounter++;</span>

                // 3rd row
<span class="fc" id="L294">                fill3rdRowAnd2ndRowEquation(p21, p31, p22, p32, p23, p33, p24, p34, a, eqCounter);</span>
<span class="fc" id="L295">                eqCounter++;</span>

                // 4th row
<span class="fc" id="L298">                fill1stRowEqualTo2ndRowEquation(p11, p21, p12, p22, p13, p23, p14, p24, a, eqCounter);</span>
<span class="fc" id="L299">                eqCounter++;</span>

<span class="fc bfc" id="L301" title="All 4 branches covered.">                if (!isLMSESolutionAllowed() &amp;&amp; eqCounter &gt;= minReqEqs) {</span>
<span class="fc" id="L302">                    break;</span>
                }
<span class="fc" id="L304">            }</span>

<span class="fc" id="L306">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L307">            enforceRank3IfNeeded(decomposer, result);</span>

<span class="nc" id="L309">        } catch (final AlgebraException | NumericalException e) {</span>
<span class="nc" id="L310">            throw new DualAbsoluteQuadricEstimatorException(e);</span>
<span class="fc" id="L311">        }</span>
<span class="fc" id="L312">    }</span>

    /**
     * Estimates Dual Absolute Quadric (DAQ) assuming that skewness is zero,
     * and principal point is located at origin of coordinates.
     *
     * @param result instance where resulting estimated Dual Absolute Quadric
     *               will be stored.
     * @throws DualAbsoluteQuadricEstimatorException if an error occurs during
     *                                               estimation, usually because repeated cameras are
     *                                               provided, or cameras corresponding to critical motion
     *                                               sequences such as pure parallel translations are
     *                                               provided, where no additional data is really provided.
     */
    private void estimateZeroSkewnessAndPrincipalPointAtOrigin(final DualAbsoluteQuadric result)
            throws DualAbsoluteQuadricEstimatorException {
        try {
<span class="fc" id="L329">            final var nCams = cameras.size();</span>

            final Matrix a;
<span class="fc bfc" id="L332" title="All 2 branches covered.">            if (isLMSESolutionAllowed()) {</span>
<span class="fc" id="L333">                a = new Matrix(3 * nCams, BaseQuadric.N_PARAMS);</span>
            } else {
<span class="fc" id="L335">                a = new Matrix(9, BaseQuadric.N_PARAMS);</span>
            }

            Matrix cameraMatrix;
            double p11;
            double p12;
            double p13;
            double p14;
            double p21;
            double p22;
            double p23;
            double p24;
            double p31;
            double p32;
            double p33;
            double p34;
<span class="fc" id="L351">            var eqCounter = 0;</span>
<span class="fc" id="L352">            final var minReqEqs = getMinRequiredEquations();</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">            for (final var camera : cameras) {</span>

                // normalize cameras to increase accuracy
<span class="fc" id="L356">                camera.normalize();</span>

<span class="fc" id="L358">                cameraMatrix = camera.getInternalMatrix();</span>

<span class="fc" id="L360">                p11 = cameraMatrix.getElementAt(0, 0);</span>
<span class="fc" id="L361">                p21 = cameraMatrix.getElementAt(1, 0);</span>
<span class="fc" id="L362">                p31 = cameraMatrix.getElementAt(2, 0);</span>

<span class="fc" id="L364">                p12 = cameraMatrix.getElementAt(0, 1);</span>
<span class="fc" id="L365">                p22 = cameraMatrix.getElementAt(1, 1);</span>
<span class="fc" id="L366">                p32 = cameraMatrix.getElementAt(2, 1);</span>

<span class="fc" id="L368">                p13 = cameraMatrix.getElementAt(0, 2);</span>
<span class="fc" id="L369">                p23 = cameraMatrix.getElementAt(1, 2);</span>
<span class="fc" id="L370">                p33 = cameraMatrix.getElementAt(2, 2);</span>

<span class="fc" id="L372">                p14 = cameraMatrix.getElementAt(0, 3);</span>
<span class="fc" id="L373">                p24 = cameraMatrix.getElementAt(1, 3);</span>
<span class="fc" id="L374">                p34 = cameraMatrix.getElementAt(2, 3);</span>

                // 1st row
<span class="fc" id="L377">                fill2ndRowAnd1stRowEquation(p11, p21, p12, p22, p13, p23, p14, p24, a, eqCounter);</span>
<span class="fc" id="L378">                eqCounter++;</span>

                // 2nd row
<span class="fc" id="L381">                fill3rdRowAnd1stRowEquation(p11, p31, p12, p32, p13, p33, p14, p34, a, eqCounter);</span>
<span class="fc" id="L382">                eqCounter++;</span>

                // 3rd row
<span class="fc" id="L385">                fill3rdRowAnd2ndRowEquation(p21, p31, p22, p32, p23, p33, p24, p34, a, eqCounter);</span>
<span class="fc" id="L386">                eqCounter++;</span>

<span class="fc bfc" id="L388" title="All 4 branches covered.">                if (!isLMSESolutionAllowed() &amp;&amp; eqCounter &gt;= minReqEqs) {</span>
<span class="fc" id="L389">                    break;</span>
                }
<span class="fc" id="L391">            }</span>

<span class="fc" id="L393">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L394">            enforceRank3IfNeeded(decomposer, result);</span>

<span class="nc" id="L396">        } catch (final AlgebraException | NumericalException e) {</span>
<span class="nc" id="L397">            throw new DualAbsoluteQuadricEstimatorException(e);</span>
<span class="fc" id="L398">        }</span>
<span class="fc" id="L399">    }</span>

    /**
     * Estimates Dual Absolute Quadric (DAQ) assuming that principal point is
     * zero.
     *
     * @param result instance where resulting estimated Dual Absolute Quadric
     *               will be stored.
     * @throws DualAbsoluteQuadricEstimatorException if an error occurs during
     *                                               estimation, usually because repeated cameras are
     *                                               provided, or cameras corresponding to critical motion
     *                                               sequences such as pure parallel translations are
     *                                               provided, where no additional data is really provided.
     */
    private void estimatePrincipalPointAtOrigin(final DualAbsoluteQuadric result)
            throws DualAbsoluteQuadricEstimatorException {
        try {
<span class="fc" id="L416">            final var nCams = cameras.size();</span>

            final Matrix a;
<span class="fc bfc" id="L419" title="All 2 branches covered.">            if (isLMSESolutionAllowed()) {</span>
<span class="fc" id="L420">                a = new Matrix(2 * nCams, BaseQuadric.N_PARAMS);</span>
            } else {
<span class="fc bfc" id="L422" title="All 2 branches covered.">                a = new Matrix(singularityEnforced ? 8 : 10, BaseQuadric.N_PARAMS);</span>
            }

            Matrix cameraMatrix;
            double p11;
            double p12;
            double p13;
            double p14;
            double p21;
            double p22;
            double p23;
            double p24;
            double p31;
            double p32;
            double p33;
            double p34;
<span class="fc" id="L438">            var eqCounter = 0;</span>
<span class="fc" id="L439">            final var minReqEqs = getMinRequiredEquations();</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">            for (final var camera : cameras) {</span>

                // normalize cameras to increase accuracy
<span class="fc" id="L443">                camera.normalize();</span>

<span class="fc" id="L445">                cameraMatrix = camera.getInternalMatrix();</span>

<span class="fc" id="L447">                p11 = cameraMatrix.getElementAt(0, 0);</span>
<span class="fc" id="L448">                p21 = cameraMatrix.getElementAt(1, 0);</span>
<span class="fc" id="L449">                p31 = cameraMatrix.getElementAt(2, 0);</span>

<span class="fc" id="L451">                p12 = cameraMatrix.getElementAt(0, 1);</span>
<span class="fc" id="L452">                p22 = cameraMatrix.getElementAt(1, 1);</span>
<span class="fc" id="L453">                p32 = cameraMatrix.getElementAt(2, 1);</span>

<span class="fc" id="L455">                p13 = cameraMatrix.getElementAt(0, 2);</span>
<span class="fc" id="L456">                p23 = cameraMatrix.getElementAt(1, 2);</span>
<span class="fc" id="L457">                p33 = cameraMatrix.getElementAt(2, 2);</span>

<span class="fc" id="L459">                p14 = cameraMatrix.getElementAt(0, 3);</span>
<span class="fc" id="L460">                p24 = cameraMatrix.getElementAt(1, 3);</span>
<span class="fc" id="L461">                p34 = cameraMatrix.getElementAt(2, 3);</span>

                // 1st row
<span class="fc" id="L464">                fill3rdRowAnd1stRowEquation(p11, p31, p12, p32, p13, p33, p14, p34, a, eqCounter);</span>
<span class="fc" id="L465">                eqCounter++;</span>

                // 2nd row
<span class="fc" id="L468">                fill3rdRowAnd2ndRowEquation(p21, p31, p22, p32, p23, p33, p24, p34, a, eqCounter);</span>
<span class="fc" id="L469">                eqCounter++;</span>

<span class="fc bfc" id="L471" title="All 4 branches covered.">                if (!isLMSESolutionAllowed() &amp;&amp; eqCounter &gt;= minReqEqs) {</span>
<span class="fc" id="L472">                    break;</span>
                }
<span class="fc" id="L474">            }</span>

<span class="fc" id="L476">            final var decomposer = new SingularValueDecomposer(a);</span>
<span class="fc" id="L477">            enforceRank3IfNeeded(decomposer, result);</span>

<span class="nc" id="L479">        } catch (final AlgebraException | NumericalException e) {</span>
<span class="nc" id="L480">            throw new DualAbsoluteQuadricEstimatorException(e);</span>
<span class="fc" id="L481">        }</span>
<span class="fc" id="L482">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>